import{C as p}from"./enums-DDkmfb-t.js";import{d5 as re,oL as ie,ac as ne,aO as oe,s as ae,D as ce,cN as m,oM as Pt,aP as St,oN as q,jj as ue,oO as le,jk as pe,oP as he}from"./main-C02UbYD7.js";import{Q as wt,A as bt,i as vt,g as v,C as fe,q as Tt,B as Et,S as Q,w as Mt,j as de,m as xe,o as me,F as ye,H as _e,O as ge,D as ke,E as Pe,p as L}from"./UpdateTracking2D-Dbow3jYu.js";import{g as It,i as Nt,l as Se}from"./GeometryUtils-C38J0GTP.js";import{a as j,c as J,t as D,R as we,d as be,e as ve,V as Te,A as Ee}from"./definitions-Doe0g1C2.js";import{a as Me,i as Ie,c as Ne}from"./TurboLine-D8sSVSI9.js";import{a as Ae,e as De,f as Ye,g as At}from"./LabelMetric-BYq7UFJE.js";import"./earcut-BxtRhkib.js";import{t as $}from"./constants-DVpDF9P6.js";import{U as it,e as nt,w as ot,n as at,i as Dt}from"./enums-BsbtGCGp.js";function Be(t,e,s,r,i,n,o){lt=0;const a=(r-s)*n,c=i&&i.length,l=c?(i[0]-s)*n:a;let u,h,f,d,x,y=Yt(e,s,r,0,l,n,!0);if(y&&y.next!==y.prev){if(c&&(y=Ge(e,s,r,i,y,n)),a>80*n){u=f=e[0+s*n],h=d=e[1+s*n];for(let _=n;_<l;_+=n){const P=e[_+s*n],w=e[_+1+s*n];u=Math.min(u,P),h=Math.min(h,w),f=Math.max(f,P),d=Math.max(d,w)}x=Math.max(f-u,d-h),x=x!==0?1/x:0}C(y,t,n,u,h,x,o,0)}}function Yt(t,e,s,r,i,n,o){let a;if(o===Ue(t,e,s,r,i,n)>0)for(let c=r;c<i;c+=n)a=Bt(c+e*n,t[c+e*n],t[c+1+e*n],a);else for(let c=i-n;c>=r;c-=n)a=Bt(c+e*n,t[c+e*n],t[c+1+e*n],a);return a&&M(a,a.next)&&(W(a),a=a.next),a}function O(t,e=t){if(!t)return t;let s,r=t;do if(s=!1,r.steiner||!M(r,r.next)&&k(r.prev,r,r.next)!==0)r=r.next;else{if(W(r),r=e=r.prev,r===r.next)break;s=!0}while(s||r!==e);return e}function C(t,e,s,r,i,n,o,a){if(!t)return;!a&&n&&(t=zt(t,r,i,n));let c=t;for(;t.prev!==t.next;){const l=t.prev,u=t.next;if(n?Fe(t,r,i,n):ze(t))e.push(l.index/s+o),e.push(t.index/s+o),e.push(u.index/s+o),W(t),t=u.next,c=u.next;else if((t=u)===c){a?a===1?C(t=Xe(t,e,s,o),e,s,r,i,n,o,2):a===2&&Ve(t,e,s,r,i,n,o):C(O(t),e,s,r,i,n,o,1);break}}}function ze(t){const e=t.prev,s=t,r=t.next;if(k(e,s,r)>=0)return!1;let i=t.next.next;const n=i;let o=0;for(;i!==t.prev&&(o===0||i!==n);){if(o++,Y(e.x,e.y,s.x,s.y,r.x,r.y,i.x,i.y)&&k(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Fe(t,e,s,r){const i=t.prev,n=t,o=t.next;if(k(i,n,o)>=0)return!1;const a=i.x<n.x?i.x<o.x?i.x:o.x:n.x<o.x?n.x:o.x,c=i.y<n.y?i.y<o.y?i.y:o.y:n.y<o.y?n.y:o.y,l=i.x>n.x?i.x>o.x?i.x:o.x:n.x>o.x?n.x:o.x,u=i.y>n.y?i.y>o.y?i.y:o.y:n.y>o.y?n.y:o.y,h=ct(a,c,e,s,r),f=ct(l,u,e,s,r);let d=t.prevZ,x=t.nextZ;for(;d&&d.z>=h&&x&&x.z<=f;){if(d!==t.prev&&d!==t.next&&Y(i.x,i.y,n.x,n.y,o.x,o.y,d.x,d.y)&&k(d.prev,d,d.next)>=0||(d=d.prevZ,x!==t.prev&&x!==t.next&&Y(i.x,i.y,n.x,n.y,o.x,o.y,x.x,x.y)&&k(x.prev,x,x.next)>=0))return!1;x=x.nextZ}for(;d&&d.z>=h;){if(d!==t.prev&&d!==t.next&&Y(i.x,i.y,n.x,n.y,o.x,o.y,d.x,d.y)&&k(d.prev,d,d.next)>=0)return!1;d=d.prevZ}for(;x&&x.z<=f;){if(x!==t.prev&&x!==t.next&&Y(i.x,i.y,n.x,n.y,o.x,o.y,x.x,x.y)&&k(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function Bt(t,e,s,r){const i=F.create(t,e,s);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function W(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Re(t){let e=t,s=t;do(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next;while(e!==t);return s}function Ge(t,e,s,r,i,n){const o=new Array;for(let a=0,c=r.length;a<c;a++){const l=Yt(t,e,s,r[a]*n,a<c-1?r[a+1]*n:s*n,n,!1);l===l.next&&(l.steiner=!0),o.push(Re(l))}o.sort(He);for(const a of o)i=Le(a,i);return i}function Le(t,e){const s=Oe(t,e);if(!s)return e;const r=Rt(s,t);return O(r,r.next),O(s,s.next)}function Oe(t,e){let s=e;const r=t.x,i=t.y;let n,o=-1/0;do{if(i<=s.y&&i>=s.next.y&&s.next.y!==s.y){const f=s.x+(i-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(f<=r&&f>o){if(o=f,f===r){if(i===s.y)return s;if(i===s.next.y)return s.next}n=s.x<s.next.x?s:s.next}}s=s.next}while(s!==e);if(!n)return null;if(r===o)return n.prev;const a=n,c=n.x,l=n.y;let u,h=1/0;for(s=n.next;s!==a;)r>=s.x&&s.x>=c&&r!==s.x&&Y(i<l?r:o,i,c,l,i<l?o:r,i,s.x,s.y)&&(u=Math.abs(i-s.y)/(r-s.x),(u<h||u===h&&s.x>n.x)&&U(s,t)&&(n=s,h=u)),s=s.next;return n}function zt(t,e,s,r){let i;for(;i!==t;i=i.next){if(i=i||t,i.z===null&&(i.z=ct(i.x,i.y,e,s,r)),i.prev.next!==i||i.next.prev!==i)return i.prev.next=i,i.next.prev=i,zt(t,e,s,r);i.prevZ=i.prev,i.nextZ=i.next}return t.prevZ.nextZ=null,t.prevZ=null,Ce(t)}function Ce(t){let e,s=1;for(;;){let r,i=t;t=null,e=null;let n=0;for(;i;){n++,r=i;let o=0;for(;o<s&&r;o++)r=r.nextZ;let a=s;for(;o>0||a>0&&r;){let c;o===0?(c=r,r=r.nextZ,a--):a!==0&&r?i.z<=r.z?(c=i,i=i.nextZ,o--):(c=r,r=r.nextZ,a--):(c=i,i=i.nextZ,o--),e?e.nextZ=c:t=c,c.prevZ=e,e=c}i=r}if(e.nextZ=null,s*=2,n<2)return t}}function k(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function Ft(t,e,s,r){return!!(M(t,e)&&M(s,r)||M(t,r)&&M(s,e))||k(t,e,s)>0!=k(t,e,r)>0&&k(s,r,t)>0!=k(s,r,e)>0}function We(t,e){let s=t;do{if(s.index!==t.index&&s.next.index!==t.index&&s.index!==e.index&&s.next.index!==e.index&&Ft(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}function Ue(t,e,s,r,i,n){let o=0;for(let a=r,c=i-n;a<i;a+=n)o+=(t[c+e*n]-t[a+e*n])*(t[a+1+e*n]+t[c+1+e*n]),c=a;return o}function Y(t,e,s,r,i,n,o,a){return(i-o)*(e-a)-(t-o)*(n-a)>=0&&(t-o)*(r-a)-(s-o)*(e-a)>=0&&(s-o)*(n-a)-(i-o)*(r-a)>=0}function U(t,e){return k(t.prev,t,t.next)<0?k(t,e,t.next)>=0&&k(t,t.prev,e)>=0:k(t,e,t.prev)<0||k(t,t.next,e)<0}function ct(t,e,s,r,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-s)*i)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-r)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function M(t,e){return t.x===e.x&&t.y===e.y}function He(t,e){return t.x-e.x}function Xe(t,e,s,r){let i=t;do{const n=i.prev,o=i.next.next;!M(n,o)&&Ft(n,i,i.next,o)&&U(n,o)&&U(o,n)&&(e.push(n.index/s+r),e.push(i.index/s+r),e.push(o.index/s+r),W(i),W(i.next),i=t=o),i=i.next}while(i!==t);return i}function Ve(t,e,s,r,i,n,o){let a=t;do{let c=a.next.next;for(;c!==a.prev;){if(a.index!==c.index&&Ze(a,c)){let l=Rt(a,c);return a=O(a,a.next),l=O(l,l.next),C(a,e,s,r,i,n,o,0),void C(l,e,s,r,i,n,o,0)}c=c.next}a=a.next}while(a!==t)}function Ze(t,e){return t.next.index!==e.index&&t.prev.index!==e.index&&!We(t,e)&&U(t,e)&&U(e,t)&&qe(t,e)}function qe(t,e){let s=t,r=!1;const i=(t.x+e.x)/2,n=(t.y+e.y)/2;do s.y>n!=s.next.y>n&&s.next.y!==s.y&&i<(s.next.x-s.x)*(n-s.y)/(s.next.y-s.y)+s.x&&(r=!r),s=s.next;while(s!==t);return r}function Rt(t,e){const s=F.create(t.index,t.x,t.y),r=F.create(e.index,e.x,e.y),i=t.next,n=e.prev;return t.next=e,e.prev=t,s.next=i,i.prev=s,r.next=s,s.prev=r,n.next=r,r.prev=n,r}class F{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(e,s,r){const i=lt<ut.length?ut[lt++]:new F;return i.index=e,i.x=s,i.y=r,i.prev=null,i.next=null,i.z=null,i.prevZ=null,i.nextZ=null,i.steiner=!1,i}}const ut=[],Qe=8096;let lt=0;for(let t=0;t<Qe;t++)ut.push(new F);const je=1e-5,I=new It(0,0,0,1,0),pt=new It(0,0,0,1,0);function Gt(t,e,s){let r=0;for(let i=1;i<s;i++){const n=t[2*(e+i-1)],o=t[2*(e+i-1)+1];r+=(t[2*(e+i)]-n)*(t[2*(e+i)+1]+o)}return r}function Je(t,e,s,r,i){let n=0;const o=2;for(let a=s;a<r;a+=3){const c=(t[a]-i)*o,l=(t[a+1]-i)*o,u=(t[a+2]-i)*o;n+=Math.abs((e[c]-e[u])*(e[l+1]-e[c+1])-(e[c]-e[l])*(e[u+1]-e[c+1]))}return n}function $e(t,e){const{coords:s,lengths:r,hasIndeterminateRingOrder:i}=e,n=0,o=t;if(i)return!1;let a=0;for(let c=0;c<r.length;){let l=c,u=r[c],h=Gt(s,a,u);const f=[];for(;++l<r.length;){const _=r[l],P=Gt(s,a+u,_);if(!(P>0))break;h+=P,f.push(a+u),u+=_}const d=o.length;Be(o,s,a,a+u,f,2,n);const x=Je(o,s,d,o.length,n),y=Math.abs(h);if(Math.abs((x-y)/Math.max(1e-7,y))>je)return o.length=0,!1;c=l,a+=u}return!0}function Ke(t){const{coords:e,lengths:s}=t,{buffer:r}=Me(e,s);return r}function ts(t,e,s){let r=0;for(let i=0;i<t.lengths.length;i++){const n=t.lengths[i];for(let o=0;o<n;o++){const a=t.coords[2*(o+r)],c=t.coords[2*(o+r)+1];if(a<e||a>s||c<e||c>s)return!0}r+=n}return!1}function Lt(t,e){if(t==null)return null;if(!ts(t,-128,j+128))return t;I.setPixelMargin(e),I.reset(Nt.Polygon);let s=0;for(let o=0;o<t.lengths.length;o++){const a=t.lengths[o];let c=t.coords[2*(0+s)],l=t.coords[2*(0+s)+1];I.moveTo(c,l);for(let u=1;u<a;u++)c=t.coords[2*(u+s)],l=t.coords[2*(u+s)+1],I.lineTo(c,l);I.close(),s+=a}const r=I.result(!1);if(!r)return null;const i=[],n=[];for(const o of r){let a=0;for(const c of o)n.push(c.x),n.push(c.y),a++;i.push(a)}return new re(i,n)}function es(t,e){pt.setPixelMargin(e);const s=pt,r=-e,i=j+e;let n=[],o=!1;if(!t.nextPath())return null;let a=!0;for(;a;){t.seekPathStart();const c=[];if(!t.pathSize)return null;s.reset(Nt.LineString),t.nextPoint();let l=t.x,u=t.y;if(o)s.moveTo(l,u);else{if(l<r||l>i||u<r||u>i){o=!0;continue}c.push({x:l,y:u})}let h=!1;for(;t.nextPoint();)if(l=t.x,u=t.y,o)s.lineTo(l,u);else{if(l<r||l>i||u<r||u>i){h=!0;break}c.push({x:l,y:u})}if(h)o=!0;else{if(o){const f=s.resultWithStarts();if(f)for(const d of f)n.push(d)}else n.push({line:c,start:0});a=t.nextPath(),o=!1}}return n=n.filter(c=>c.line.length>1),n.length===0?null:n}I.setExtent(j),pt.setExtent(j);const ss=96/72;let Ot=class{static executeEffects(t,e,s,r){const i=ss,n=wt(t);let o=new vt(e);for(const a of t){const c=bt(a);c&&(o=c.execute(o,a,i,s,r,n))}return o}static applyEffects(t,e,s){if(!t)return e;const r=wt(t);let i,n=new vt(v.fromJSONCIM(e));for(const c of t){const l=bt(c);l&&(n=l.execute(n,c,1,null,s,r))}const o=[];let a=null;for(;i=n.next();)o.push(...ie(i)),a=i.geometryType;return o.length===0||a===null?null:a==="esriGeometryPolygon"?{rings:o}:{paths:o}}},Ct=null;function ht(){return Ct}async function rs(){Ct=await import("./geometryEngineJSON-CH_JEiIX.js").then(t=>t.g)}function Wt(t){switch(t){case p.BYTE:case p.UNSIGNED_BYTE:return 1;case p.SHORT:case p.UNSIGNED_SHORT:case p.HALF_FLOAT:return 2;case p.FLOAT:case p.INT:case p.UNSIGNED_INT:return 4}}function is(t){const e=[],s=[],r=[];for(const i of t){const n=Wt(i.type)*i.count;switch(n%2||n%4||4){case 4:e.push(i);continue;case 2:s.push(i);continue;case 1:r.push(i);continue;default:throw new Error("Found unexpected dataType byte count")}}return e.push(...s),e.push(...r),e}let ns=class te{static fromVertexSpec(e,s){const{attributes:r,optionalAttributes:i}=e;let n,o,a;const c=[];for(const y in r){const _=r[y];_.pack==="position"?n={..._,name:y,offset:0}:_.pack==="id"?o={..._,name:y,offset:4}:y==="bitset"?a={..._,name:y,offset:7}:c.push({..._,name:y})}for(const y in i)if(s[y]===!0){const _=i[y];c.push({..._,name:y})}const l=is(c),u=[];let h=8,f=1;for(const y of l)u.push({...y,offset:h}),h+=Wt(y.type)*y.count,y.packAlternating&&(f=Math.max(y.packAlternating.count,f));const d=Uint32Array.BYTES_PER_ELEMENT,x=h%d;return new te(n,o,a,u,h+(x?d-x:0),f)}constructor(e,s,r,i,n,o){this.position=e,this.id=s,this.bitset=r,this.standardAttributes=i,this.stride=n,this.packVertexCount=o,i.push(r),this._attributes=[e,s,r,...i]}get attributeLayout(){if(!this._attributeLayout){const e=Ae(this._attributes),s=this._attributes.map(r=>({name:r.name,count:r.count,offset:r.offset,type:r.type,packPrecisionFactor:r.packPrecisionFactor,normalized:r.normalized??!1}));this._attributeLayout={attributes:s,hash:e,stride:this.stride}}return this._attributeLayout}},os=class ee{static fromVertexSpec(e,s){const r=ns.fromVertexSpec(e,s);return new ee(r)}constructor(e){this._spec=e,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(e,s,r,i,n,o){for(let a=0;a<this._spec.packVertexCount;a++){const c=a*this._spec.stride;this._packPosition(r,i,c),this._packId(s,c);const l=this._spec.bitset;if(o){if(l.packTessellation){const u=l.packTessellation(o,n);this._pack(u,l,c)}for(const u of this._spec.standardAttributes)if(u.packTessellation!=null){const h=u.packTessellation(o,n);this._pack(h,u,c)}else if(u.packAlternating?.packTessellation){const h=u.packAlternating.packTessellation(o,n);for(let f=0;f<this._spec.packVertexCount;f++){const d=h[f];this._pack(d,u,f*this._spec.stride)}}}}e.vertexWriteRegion(this._packedU32View)}pack(e,s){for(const r of this._spec.standardAttributes)if(r.pack&&typeof r.pack!="string"){const i=r.pack(e,s);for(let n=0;n<this._spec.packVertexCount;n++)this._pack(i,r,n*this._spec.stride)}else if(r.packAlternating?.pack){const i=r.packAlternating.pack(e,s);for(let n=0;n<this._spec.packVertexCount;n++){const o=i[n];this._pack(o,r,n*this._spec.stride)}}}_packPosition(e,s,r){const{offset:i}=this._spec.position,n=this._spec.position.packPrecisionFactor??1,o=Ye(e*n,s*n);this._dataView.setUint32(r+i,o,!0)}_packId(e,s){const r=e*(this._spec.id.packPrecisionFactor??1),i=4278190080&this._dataView.getUint32(s+this._spec.id.offset,!0);this._dataView.setUint32(s+this._spec.id.offset,r|i,!0)}_pack(e,s,r){De(this._dataView,e,s,r)}};function as(t){if(!t)return!1;for(const e of t)switch(e.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectOffset":case"CIMGeometricEffectDonut":return!0}return!1}let B=class{constructor(t,e,s,r){this._instanceId=t,this._evaluator=e,this._enabledOptionalAttributes=s,this._viewParams=r,this._evaluator.evaluator=i=>this.vertexSpec.createComputedParams(i)}get _vertexPack(){if(!this._cachedVertexPack){const t=os.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){as(this._evaluator.inputMeshParams.effects?.effectInfos)&&await rs()}enqueueRequest(t,e,s){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,e,s)}write(t,e,s,r,i){this.ensurePacked(e,s,r);const n=this.evaluatedMeshParams.effects;if(!n||n.length===0)return void this._write(t,s,void 0,i);const o=s.readGeometryForDisplay()?.clone();if(!o)return;const a=v.fromOptimizedCIM(o,s.geometryType),c=ht();a.invertY();const l=t.id||"",u=Ot.executeEffects(n,a,l,c);let h;for(;h=u.next();)h.invertY(),this._write(t,s,h,i)}ensurePacked(t,e,s){if(!this._evaluator.hasDynamicProperties)return;const r=this._evaluator.evaluateMeshParams(t,e,s);this._vertexPack.pack(r,this._viewParams)}_writeVertex(t,e,s,r,i){const n=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,e,s,r,n,i)}};const cs=100,us=ne("featurelayer-fast-triangulation-enabled");let Ut=class extends B{async loadDependencies(){await Promise.all([super.loadDependencies(),Ie()])}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);i&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,i),t.recordEnd())}_clip(t){if(!t)return null;const e=this.hasEffects;return Lt(t,e?256:8)}_writeGeometry(t,e,s){const r=s.maxLength>cs,i=[],n=this.createTesselationParams(e);if(!r&&us&&$e(i,s))return void(i.length&&this._writeVertices(t,e,s.coords,n,i));const o=Ke(s);this._writeVertices(t,e,o,n)}_writeVertices(t,e,s,r,i){const n=e.getDisplayId(),o=t.vertexCount(),a=this.hasEffects;let c=0;if(i)for(const l of i){const u=s[2*l],h=s[2*l+1];a&&t.recordBounds(u,h,0,0),this._writeVertex(t,n,u,h,r),c++}else for(let l=0;l<s.length;l+=2){const u=Math.round(s[l]),h=Math.round(s[l+1]);a&&t.recordBounds(u,h,0,0),this._writeVertex(t,n,u,h,r),c++}t.indexEnsureSize(c);for(let l=0;l<c;l++)t.indexWrite(l+o)}};const ls={createComputedParams:t=>t,optionalAttributes:{},attributes:{id:{type:p.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:p.UNSIGNED_BYTE,count:1},pos:{type:p.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:p.FLOAT,count:1,packTessellation:({inverseArea:t})=>t}}};let ps=class extends Ut{constructor(){super(...arguments),this.vertexSpec=ls}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}};const hs=()=>ce.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),fs=0,ds=100;function z(t,e){return[!!t?.minScale&&e.scaleToZoom(t.minScale)||fs,!!t?.maxScale&&e.scaleToZoom(t.maxScale)||ds]}function H(t){return 1<<t}function X(t){let e=0;for(const[s,r]of t)r&&(e|=1<<s);return e}function g(t){let e;if(!t)return[0,0,0,0];if(typeof t=="string"){const o=oe.fromString(t);if(!o)return hs().errorOnce(new ae("mapview:mesh-processing","Unable to parse string into color",{color:t})),[0,0,0,0];e=o.toArray()}else e=t;const[s,r,i,n]=e;return[s*(n/255),r*(n/255),i*(n/255),n]}function xs(t){switch(t){case"butt":case it.Butt:return nt.BUTT;case"round":case it.Round:return nt.ROUND;case"square":case it.Square:return nt.SQUARE}}function ms(t){switch(t){case"bevel":case ot.Bevel:return at.BEVEL;case"miter":case ot.Miter:return at.MITER;case"round":case ot.Round:return at.ROUND}}function ft(t,e){return Math.round(Math.min(Math.sqrt(t*e),255))}function K(t,e){return Math.round(t*e)/e}const dt={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:p.SHORT,count:2,packPrecisionFactor:J,pack:({scaleInfo:t},{tileInfo:e})=>z(t,e)}},attributes:{id:{type:p.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:p.UNSIGNED_BYTE,count:1},pos:{type:p.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:p.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>g(t)}}};let xt=class extends Ut{constructor(){super(...arguments),this.vertexSpec=dt}createTesselationParams(t){return null}};const N={createComputedParams:t=>t,optionalAttributes:dt.optionalAttributes,attributes:{...dt.attributes,tlbr:{count:4,type:p.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+D,n=e.y+D;return[i,n,i+s,n+r]}},inverseRasterizationScale:{count:1,type:p.BYTE,packPrecisionFactor:16,pack:({sprite:t})=>1/t.rasterizationScale}}};let Ht=class extends xt{constructor(){super(...arguments),this.vertexSpec=N}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,i),t.recordEnd()}};function tt(t){const{sprite:e,aspectRatio:s,scaleProportionally:r}=t,i=m(t.height),n=i>0?i:e.height;let o=i*s;return o<=0?o=e.width:r&&(o*=e.width/e.height),{width:o,height:n}}function Xt(t){const{applyRandomOffset:e,sampleAlphaOnly:s}=t;return X([[fe,e],[Tt,s]])}const Vt={createComputedParams:t=>t,optionalAttributes:N.optionalAttributes,attributes:{...N.attributes,bitset:{count:1,type:p.UNSIGNED_BYTE,pack:Xt},width:{count:1,type:p.HALF_FLOAT,pack:t=>tt(t).width},height:{count:1,type:p.HALF_FLOAT,pack:t=>tt(t).height},offset:{count:2,type:p.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[m(t),-m(e)]},scale:{count:2,type:p.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:t,scaleY:e})=>[t,e]},angle:{count:1,type:p.UNSIGNED_BYTE,pack:({angle:t})=>Se(t)}}};let ys=class extends Ht{constructor(){super(...arguments),this.vertexSpec=Vt}},_s=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0}};const A={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:p.SHORT,count:2,packPrecisionFactor:J,pack:({scaleInfo:t},{tileInfo:e})=>z(t,e)}},attributes:{id:{type:p.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:p.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:p.UNSIGNED_BYTE,count:1},color:{type:p.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>g(t)},offset:{type:p.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[K(t,16),K(e,16)]},normal:{type:p.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[K(t,16),K(e,16)]},halfWidth:{type:p.HALF_FLOAT,count:1,pack:({width:t})=>m(.5*t)},referenceHalfWidth:{type:p.HALF_FLOAT,count:1,pack:({referenceWidth:t})=>m(.5*t)}}};let gs=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0}};const Zt=65535;let mt=class extends B{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=A,this._currentWrite=new gs,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:Zt,textured:!1},this._tessParams=new _s,this._initializeTessellator()}writeLineVertices(t,e,s){const r=this._getLines(e);r!=null&&this._writeVertices(t,s,r)}_initializeTessellator(){this._lineTessellator=new Ne(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,e,s){const r=s??v.fromFeatureSetReaderCIM(e);r&&this._writeGeometry(t,e,r)}_writeGeometry(t,e,s,r){t.recordStart(this.instanceId,this.attributeLayout,r),this.writeLineVertices(t,s,e),t.recordEnd()}_getLines(t){return es(t,At(this.evaluatedMeshParams))}_writeVertices(t,e,s){const{_currentWrite:r,_tessellationOptions:i,evaluatedMeshParams:n}=this,{width:o,capType:a,joinType:c,miterLimit:l,hasSizeVV:u}=n,h=m(.5*o);i.halfWidth=h,i.capType=xs(a),i.joinType=ms(c),i.miterLimit=l;const f=!u;r.out=t,r.id=e.getDisplayId(),r.vertexCount=0,r.indexCount=0,r.vertexFrom=t.vertexCount(),r.vertexBounds=f&&h<we?0:1;for(const{line:d,start:x}of s)i.initialDistance=x%Zt,this._lineTessellator.tessellate(d,i,f)}_writeTesselatedVertex(t,e,s,r,i,n,o,a,c,l,u){const{out:h,id:f,vertexBounds:d}=this._currentWrite;return this.hasEffects&&h.recordBounds(t,e,d,d),this._tessParams.extrusionOffsetX=o,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=l,this._tessParams.directionX=i,this._tessParams.directionY=n,this._tessParams.distance=u,this._writeVertex(h,f,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,s){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(t),r.indexWrite(e),r.indexWrite(s),this._currentWrite.indexCount+=3}};const qt={createComputedParams:t=>t,optionalAttributes:A.optionalAttributes,attributes:{...A.attributes,bitset:{type:p.UNSIGNED_BYTE,count:1,pack:t=>0},color:{type:p.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>g(t)}}},yt={createComputedParams:t=>t,optionalAttributes:A.optionalAttributes,attributes:{...A.attributes,bitset:{type:p.UNSIGNED_BYTE,count:1,pack:t=>X([[Et,!0]])},color:{type:p.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>g(t)}}};let _t=class extends mt{constructor(){super(...arguments),this.vertexSpec=yt}},gt=class extends xt{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=qt,this._lineMeshWriter=this._createOutlineWriter(t,e,s,r)}_createOutlineWriter(t,e,s,r){return new _t(t,e,s,r)}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);i&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,v.fromOptimizedCIM(i,"esriGeometryPolyline"),e),t.recordEnd())}_clip(t){return t?Lt(t,At(this.evaluatedMeshParams)):null}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const et=Vt,ks=yt,Ps={createComputedParams:t=>t,optionalAttributes:et.optionalAttributes,attributes:{...et.attributes,bitset:{type:p.UNSIGNED_BYTE,count:1,pack:t=>Xt(t)},aux1:{count:1,type:p.HALF_FLOAT,pack:t=>tt(t).width},aux2:{count:1,type:p.HALF_FLOAT,pack:t=>tt(t).height},aux3:{count:2,type:p.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[m(t),m(e)]},aux4:{count:2,type:p.UNSIGNED_BYTE,pack:({scaleX:t,scaleY:e})=>[t*Q,e*Q]}}},Ss={createComputedParams:t=>t,optionalAttributes:et.optionalAttributes,attributes:{...et.attributes,color:ks.attributes.color,bitset:{type:p.UNSIGNED_BYTE,count:1,pack:t=>X([[Et,!0]])},aux1:{count:1,type:p.HALF_FLOAT,pack:t=>m(.5*t.width)},aux2:{count:1,type:p.HALF_FLOAT,pack:t=>m(.5*t.referenceWidth)},aux3:{count:2,type:p.HALF_FLOAT,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[t,e]},aux4:{count:2,type:p.UNSIGNED_BYTE,packTessellation:({normalX:t,normalY:e})=>[t*Q+Mt,e*Q+Mt]}}};class ws extends _t{constructor(){super(...arguments),this.vertexSpec=Ss}}let bs=class extends gt{constructor(){super(...arguments),this.vertexSpec=Ps}_createOutlineWriter(t,e,s,r){return new ws(t,e,s,r)}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,v.fromOptimizedCIM(i,"esriGeometryPolyline"),e),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const vs={optionalAttributes:N.optionalAttributes,createComputedParams:t=>t,attributes:{...N.attributes,...qt.attributes}},Ts={optionalAttributes:N.optionalAttributes,createComputedParams:t=>t,attributes:{...N.attributes,...yt.attributes}};class Es extends _t{constructor(){super(...arguments),this.vertexSpec=Ts}}class Ms extends gt{constructor(){super(...arguments),this.vertexSpec=vs}_createOutlineWriter(e,s,r,i){return new Es(e,s,r,i)}_write(e,s,r){const i=r?.asOptimized()??s.readGeometryForDisplay(),n=this._clip(i);if(!n)return;const o=this.evaluatedMeshParams.sprite?.textureBinding;e.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(e,s,n),this._lineMeshWriter.writeLineVertices(e,v.fromOptimizedCIM(n,"esriGeometryPolyline"),s),e.recordEnd()}ensurePacked(e,s,r){super.ensurePacked(e,s,r),this._lineMeshWriter.ensurePacked(e,s,r)}enqueueRequest(e,s,r){super.enqueueRequest(e,s,r),this._lineMeshWriter.enqueueRequest(e,s,r)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const Is={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:p.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:p.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:p.UNSIGNED_BYTE,count:1},offset:{type:p.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};class Ns extends B{constructor(){super(...arguments),this.vertexSpec=Is}_write(e,s){e.recordStart(this.instanceId,this.attributeLayout);const r=s.getDisplayId();if(s.geometryType==="esriGeometryPoint"){const i=s.readXForDisplay(),n=s.readYForDisplay();this._writeQuad(e,r,i,n)}else s.geometryType==="esriGeometryMultipoint"&&s.readGeometryForDisplay()?.forEachVertex((i,n)=>{i>=0&&i<=512&&n>=0&&n<=512&&this._writeQuad(e,r,i,n)});e.recordEnd()}_writeQuad(e,s,r,i){const n=e.vertexCount();this._writeVertex(e,s,r,i),e.indexWrite(n+0),e.indexWrite(n+1),e.indexWrite(n+2),e.indexWrite(n+1),e.indexWrite(n+3),e.indexWrite(n+2)}}class Qt{static getPlacement(e,s,r,i,n,o){const a=de(r);return a?(s===-1&&e.invertY(),a.execute(e,r,i,n,o)):null}}const jt=96;let As=class{constructor(t){const{offsetX:e,offsetY:s,postAngle:r,fontSize:i,scaleFactor:n,transforms:o}=t;if(this.offsetX=e,this.offsetY=s,this.postAngle=r,this.fontSize=Math.min(i,jt),this.transforms=o,o&&o.infos.length>1){const a=Pt(i,r,!1,e,s,o);this.fontSize=Math.min(a.size,jt),this.postAngle=a.rotation,this.offsetX=a.offsetX,this.offsetY=a.offsetY}n&&(this.fontSize*=n,this.offsetX*=n,this.offsetY*=n)}};const Jt=28,E=[4,4],st=[16,4],Ds={topLeft:st,topRight:st,bottomLeft:st,bottomRight:st},rt=[4,2],S=[4,6],$t={topLeft:rt,topRight:rt,bottomLeft:S,bottomRight:S},Kt={topLeft:rt,topRight:S,bottomLeft:rt,bottomRight:S},Ys={topLeft:S,topRight:S,bottomLeft:E,bottomRight:E},Bs={topLeft:E,topRight:E,bottomLeft:S,bottomRight:S},zs={topLeft:S,topRight:E,bottomLeft:S,bottomRight:E},Fs={topLeft:E,topRight:S,bottomLeft:E,bottomRight:S},Rs={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:p.UNSIGNED_SHORT,count:2,packPrecisionFactor:J,packTessellation:({minZoom:t,maxZoom:e})=>[t||0,e||Jt]},clipAngle:{type:p.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:t})=>Ls(t||0)},referenceSymbol:{type:p.BYTE,count:4,packPrecisionFactor:1,packTessellation:(t,e)=>{if(!t.referenceBounds)return[0,0,0,0];const s=xe(e.horizontalAlignment),r=me(e.verticalAlignment),{offsetX:i,offsetY:n,size:o}=t.referenceBounds;return[m(i),-m(n),m(o),s+1<<2|r+1]}}},attributes:{pos:{type:p.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:p.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:p.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:t,mapAligned:e})=>X([[ye,t],[_e,!!e]])},offset:{type:p.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:r,topRight:i}=t;return[r,i,e,s]}}},textureUV:{type:p.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:r,topRight:i}=t;return[r,i,e,s]}}},color:{type:p.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:t})=>t},fontSize:{type:p.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t})=>m(t)},referenceSize:{type:p.UNSIGNED_BYTE,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t},{referenceSize:e})=>m(e??t)},haloColor:{type:p.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:t})=>g(t)},haloFontSize:{type:p.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,pack:({haloFontSize:t})=>m(t)}}};class Gs extends B{constructor(){super(...arguments),this.vertexSpec=Rs,this._textMeshParamsPropsInitialized=!1}ensurePacked(e,s,r){super.ensurePacked(e,s,r),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new As(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(e,s,r){const i=this._getShaping();if(!i)return;const n=s.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(e,s,i,r);if(r?.nextPath())return r.nextPoint(),this._writeGlyphs(e,n,r.x,r.y,i,0);if(s.geometryType==="esriGeometryPolygon"){const c=s.readCentroidForDisplay();if(!c)return;const[l,u]=c.coords;return this._writeGlyphs(e,n,l,u,i,0)}if(s.geometryType==="esriGeometryMultipoint")return void s.readGeometryForDisplay()?.forEachVertex((c,l)=>this._writeGlyphs(e,n,c,l,i,0));const o=s.readXForDisplay(),a=s.readYForDisplay();return this._writeGlyphs(e,n,o,a,i,0)}_writePlacedTextMarkers(e,s,r,i){const n=i??v.fromFeatureSetReaderCIM(s);if(!n)return;const o=-1,a=Qt.getPlacement(n,o,this.evaluatedMeshParams.placement,m(1),e.id,ht());if(!a)return;const c=s.getDisplayId();let l=a.next();for(;l!=null;){const u=l.tx,h=-l.ty,f=-l.getAngle();this._writeGlyphs(e,c,u,h,r,f),l=a.next()}}_getShaping(e){const s=this._textMeshTransformProps,r=this.evaluatedMeshParams;if(!r.glyphs?.glyphs.length)return null;const i=Math.round(m(s.fontSize)),n=m(s.offsetX),o=m(s.offsetY),a=St(m(r.lineWidth),ve,be),c=Te*St(r.lineHeightRatio,.25,4);return ge(r.glyphs,{scale:i/Ee,angle:s.postAngle,xOffset:n,yOffset:o,horizontalAlignment:r.horizontalAlignment,verticalAlignment:e||r.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:r.decoration,borderLineSizePx:m(r.boxBorderLineSize),hasBackground:!!r.boxBackgroundColor,useCIMAngleBehavior:r.useCIMAngleBehavior})}_writeGlyphs(e,s,r,i,n,o,a,c){const l=this.evaluatedMeshParams,u=this._textMeshTransformProps,h=u.fontSize,f=m(u.offsetX),d=m(u.offsetY),[x,y]=z(l.scaleInfo,this.getTileInfo());o!==0&&n.setRotation(o);const _=n.bounds,P=r+_.x+f,w=i+_.y-d,R=2*(l.minPixelBuffer?l.minPixelBuffer/h:1),b=Math.max(_.width,_.height)*R;n.textBox&&(e.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding),e.recordBounds(P,w,b,b),this._writeTextBox(e,s,r,i,n.textBox,a,c),e.recordEnd());for(const T of n.glyphs){e.recordStart(this.instanceId,this.attributeLayout,T.textureBinding),e.recordBounds(P,w,b,b);const{texcoords:G,offsets:V}=T;this._writeQuad(e,s,r,i,{texcoords:G,offsets:V,fontSize:h,color:g(l.color),isBackground:!1,referenceBounds:a,minZoom:x,maxZoom:y,...c}),e.recordEnd()}o!==0&&n.setRotation(-o)}_writeTextBox(e,s,r,i,n,o,a){const c=this.evaluatedMeshParams,{fontSize:l}=this._textMeshTransformProps,{boxBackgroundColor:u,boxBorderLineColor:h}=c,f={isBackground:!0,fontSize:l,referenceBounds:o,...a};u&&(this._writeQuad(e,s,r,i,{texcoords:Ds,offsets:n.main,color:g(u),...f}),h||(this._writeQuad(e,s,r,i,{texcoords:Ys,offsets:n.top,color:g(u),...f}),this._writeQuad(e,s,r,i,{texcoords:Bs,offsets:n.bot,color:g(u),...f}),this._writeQuad(e,s,r,i,{texcoords:zs,offsets:n.left,color:g(u),...f}),this._writeQuad(e,s,r,i,{texcoords:Fs,offsets:n.right,color:g(u),...f}))),h&&(this._writeQuad(e,s,r,i,{texcoords:$t,offsets:n.top,color:g(h),...f}),this._writeQuad(e,s,r,i,{texcoords:$t,offsets:n.bot,color:g(h),...f}),this._writeQuad(e,s,r,i,{texcoords:Kt,offsets:n.left,color:g(h),...f}),this._writeQuad(e,s,r,i,{texcoords:Kt,offsets:n.right,color:g(h),...f}))}_writeQuad(e,s,r,i,n){const o=e.vertexCount();this._writeVertex(e,s,r,i,n),e.indexWrite(o+0),e.indexWrite(o+1),e.indexWrite(o+2),e.indexWrite(o+1),e.indexWrite(o+3),e.indexWrite(o+2)}}const Ls=t=>Math.round(t*(254/360)),Os={createComputedParams:t=>t,optionalAttributes:A.optionalAttributes,attributes:{...A.attributes,bitset:{type:p.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:t,shouldScaleDash:e,isSDF:s})=>X([[Tt,t],[ke,e],[Pe,s]])},tlbr:{type:p.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+D,n=e.y+D;return[i,n,i+s,n+r]}},accumulatedDistance:{type:p.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},segmentDirection:{type:p.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]}}};class Cs extends mt{constructor(e,s,r,i){super(e,s,r,i),this.vertexSpec=Os,this._tessellationOptions.textured=!0}_write(e,s,r){const i=r??v.fromFeatureSetReaderCIM(s);if(!i)return;const{sprite:n}=this.evaluatedMeshParams;this._writeGeometry(e,s,i,n?.textureBinding)}}let Ws=class kt{static from(e){return"width"in e?this.fromSimpleMeshParams(e):this.fromComplexMeshParams(e)}static fromSimpleMeshParams(e){const s=new kt(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects),{type:r,width:i,height:n,angle:o,alignment:a,outlineSize:c,referenceSize:l,sprite:u,overrideOutlineColor:h}=e;s.rawWidth=m(i),s.rawHeight=m(n),s.angle=o,s.alignment=a,s.outlineSize=m(c),s.referenceSize=m(l),s.overrideOutlineColor=h,s.offsetX=m(e.offsetX),s.offsetY=m(e.offsetY),r!=="simple"||u.sdf||(s.rawWidth=u.width,s.rawHeight=u.height);const f=2;return s.sizeRatio=u.sdf?f:1,s._computeSize(e,!1),s}static fromComplexMeshParams(e){const s=new kt(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects);let{alignment:r,transforms:i,size:n,scaleX:o,anchorX:a,anchorY:c,angle:l,colorLocked:u,frameHeight:h,widthRatio:f,offsetX:d,offsetY:x,outlineSize:y,referenceSize:_,scaleFactor:P,sizeRatio:w,isAbsoluteAnchorPoint:R,rotateClockwise:b,scaleSymbolsProportionally:T,sprite:G}=e;if(i&&i.infos.length>0){const Z=Pt(n,l,b,d,x,i);n=Z.size,l=Z.rotation,d=Z.offsetX,x=Z.offsetY,b=!1}P&&(n*=P,d*=P,x*=P);const V=o*(G.width/G.height);s.alignment=r,s.rawHeight=m(n),s.rawWidth=s.rawHeight*V,s.referenceSize=m(_),s.sizeRatio=w,s.angle=l,s.rotateClockwise=b,s.anchorX=a,s.anchorY=c,s.offsetX=m(d),s.offsetY=m(x),R&&n&&(G.sdf?s.anchorX=a/(n*f):s.anchorX=a/(n*V),s.anchorY=c/n);const se=T&&h?n/h:1;return s.outlineSize=y===0||isNaN(y)?0:m(y)*se,s.scaleSymbolsProportionally=T,s.colorLocked=u,s._computeSize(e,!0),s}constructor(e,s,r,i,n,o,a){this.sprite=e,this.color=s,this.outlineColor=r,this.minPixelBuffer=i,this.placement=n,this.scaleInfo=o,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.alignment=Dt.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(e,s){const{sprite:r,hasSizeVV:i}=e,n=!!r.sdf,{rawWidth:o,rawHeight:a,sizeRatio:c,outlineSize:l}=this,u=o*c,h=a*c;if(n&&!i){const R=s&&o>a?u:o,b=a,T=l+2*1;this.computedWidth=Math.min(R+T,u),this.computedHeight=Math.min(b+T,h)}else this.computedWidth=u,this.computedHeight=h;const f=n?Math.max(r.width,r.height)/Math.max(u,h):1,d=.5*(u-this.computedWidth)*f,x=.5*(h-this.computedHeight)*f,y=r.rect.x+D+d,_=r.rect.y+D+x,P=y+r.width-2*d,w=_+r.height-2*x;this.texXmin=Math.floor(y),this.texYmin=Math.floor(_),this.texXmax=Math.ceil(P),this.texYmax=Math.ceil(w),this.computedWidth*=(this.texXmax-this.texXmin)/(P-y),this.computedHeight*=(this.texYmax-this.texYmin)/(w-_),this.anchorX*=u/this.computedWidth,this.anchorY*=h/this.computedHeight}};const Us=3.14159265359/180,Hs=128/Math.PI;function Xs(t,e){return t%=e,Math.abs(t>=0?t:t+e)}function Vs(t){return Xs(t*Hs,256)}function Zs(t,e,s,r,i=!1){const n=ue(),o=i?1:-1;return le(n),(e||s)&&pe(n,n,[e,-s]),r&&he(n,n,o*Us*-r),n}const qs={createComputedParams:t=>Ws.from(t),optionalAttributes:{zoomRange:{type:p.SHORT,count:2,packPrecisionFactor:J,pack:({scaleInfo:t},{tileInfo:e})=>z(t,e)}},attributes:{pos:{type:p.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:p.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:p.UNSIGNED_BYTE,count:1,pack:({sprite:t,alignment:e,scaleSymbolsProportionally:s,overrideOutlineColor:r,colorLocked:i})=>{let n=0;return t.sdf&&(n|=H(L.bitset.isSDF)),e===Dt.MAP&&(n|=H(L.bitset.isMapAligned)),s&&(n|=H(L.bitset.scaleSymbolsProportionally)),r&&(n|=H(L.bitset.overrideOutlineColor)),i&&(n|=H(L.bitset.colorLocked)),n}},offset:{type:p.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({angle:t,computedWidth:e,computedHeight:s,anchorX:r,anchorY:i,offsetX:n,offsetY:o,rotateClockwise:a})=>{const c=Zs(0,n,o,-t,a),l=-(.5+r)*e,u=-(.5-i)*s,h=[l,u],f=[l+e,u],d=[l,u+s],x=[l+e,u+s];return q(h,h,c),q(f,f,c),q(d,d,c),q(x,x,c),[h,f,d,x]}}},textureUV:{type:p.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:t,texXmin:e,texYmax:s,texYmin:r})=>[[e,r],[t,r],[e,s],[t,s]]}},color:{type:p.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>g(t)},outlineColor:{type:p.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>g(t)},sizing:{type:p.UNSIGNED_BYTE,count:4,pack:({rawWidth:t,rawHeight:e,outlineSize:s,referenceSize:r})=>{const i=Math.max(t,e);return[ft(i,128),ft(s,128),ft(r,128),0]}},placementAngle:{type:p.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:t})=>Vs(t)},sizeRatio:{type:p.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sizeRatio:t})=>t}}};class Qs extends B{constructor(){super(...arguments),this.vertexSpec=qs}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(e,s,r){const i=this.evaluatedMeshParams.sprite?.textureBinding,n=s.getDisplayId();e.recordStart(this.instanceId,this.attributeLayout,i);const o=this.evaluatedMeshParams.minPixelBuffer,a=Math.max(this.evaluatedMeshParams.computedWidth,o),c=Math.max(this.evaluatedMeshParams.computedHeight,o),l=this.evaluatedMeshParams.offsetX,u=-this.evaluatedMeshParams.offsetY;if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(e,s,r,a,c);else if(r?.nextPath()){r.nextPoint();const h=r.x,f=r.y;e.recordBounds(h+l,f+u,a,c),this._writeQuad(e,n,h,f)}else if(s.geometryType==="esriGeometryPolygon"){const h=s.readCentroidForDisplay();if(!h)return;const[f,d]=h.coords;e.recordBounds(f+l,d+u,a,c),this._writeQuad(e,n,f,d)}else if(s.geometryType==="esriGeometryPoint"){const h=s.readXForDisplay(),f=s.readYForDisplay();e.recordBounds(h+l,f+u,a,c),this._writeQuad(e,n,h,f)}else s.readGeometryForDisplay()?.forEachVertex((h,f)=>{e.recordBounds(h+l,f+u,a,c),Math.abs(h)>$||Math.abs(f)>$||this._writeQuad(e,n,h,f)});e.recordEnd()}_writePlacedMarkers(e,s,r,i,n){const o=r??v.fromFeatureSetReaderCIM(s)?.clone();if(!o)return;const a=-1,c=Qt.getPlacement(o,a,this.evaluatedMeshParams.placement,m(1),e.id,ht());if(!c)return;const l=s.getDisplayId();let u=c.next();const h=this.evaluatedMeshParams.offsetX,f=-this.evaluatedMeshParams.offsetY;for(;u!=null;){const d=u.tx,x=-u.ty;if(Math.abs(d)>$||Math.abs(x)>$){u=c.next();continue}const y=-u.getAngle();e.recordBounds(d+h,x+f,i,n),this._writeQuad(e,l,d,x,y),u=c.next()}}_writeQuad(e,s,r,i,n){const o=e.vertexCount(),a=n==null?null:{placementAngle:n};this._writeVertex(e,s,r,i,a),e.indexWrite(o+0),e.indexWrite(o+1),e.indexWrite(o+2),e.indexWrite(o+1),e.indexWrite(o+3),e.indexWrite(o+2)}}const js={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:p.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:p.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:p.UNSIGNED_BYTE,count:1,pack:t=>0},offset:{type:p.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:t})=>{const e=m(t),s=-e/2,r=-e/2;return[[s,r],[s+e,r],[s,r+e],[s+e,r+e]]}}},texCoords:{type:p.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:p.UNSIGNED_BYTE,count:2,pack:({size:t})=>[t,t]},referenceSize:{type:p.UNSIGNED_BYTE,count:1,pack:({size:t})=>m(t)},zoomRange:{type:p.UNSIGNED_BYTE,count:2,pack:({scaleInfo:t},{tileInfo:e})=>z(t,e)}}};class Js extends B{constructor(){super(...arguments),this.vertexSpec=js}_write(e,s){const r=s.getDisplayId(),i=this.evaluatedMeshParams.minPixelBuffer,n=Math.max(m(this.evaluatedMeshParams.size),i);let o,a;if(s.geometryType==="esriGeometryPoint")o=s.readXForDisplay(),a=s.readYForDisplay();else{const l=s.readCentroidForDisplay();if(!l)return;o=l?.coords[0],a=l?.coords[1]}e.recordStart(this.instanceId,this.attributeLayout),e.recordBounds(o,a,n,n);const c=e.vertexCount();this._writeVertex(e,r,o,a),e.indexWrite(c+0),e.indexWrite(c+1),e.indexWrite(c+2),e.indexWrite(c+1),e.indexWrite(c+3),e.indexWrite(c+2),e.recordEnd()}}export{Gs as N,Jt as S,mt as T,bs as _,Cs as a,ys as b,Ms as c,ps as d,xt as e,g,gt as h,Ns as i,Ot as l,z as m,Ht as o,Js as s,Qs as v};
