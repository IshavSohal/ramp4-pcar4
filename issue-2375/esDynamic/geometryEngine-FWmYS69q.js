import{G as t}from"./geometryEngineBase-DajyC32c.js";import{hydratedAdapter as r}from"./hydrated-CXqnfj6r.js";function i(n){return Array.isArray(n)?n[0].spatialReference:n&&n.spatialReference}function l(n){return t.extendedSpatialReferenceInfo(n)}function p(n,e){return t.clip(r,i(n),n,e)}function d(n,e){return t.cut(r,i(n),n,e)}function g(n,e){return t.contains(r,i(n),n,e)}function h(n,e){return t.crosses(r,i(n),n,e)}function m(n,e,a){return t.distance(r,i(n),n,e,a)}function w(n,e){return t.equals(r,i(n),n,e)}function R(n,e){return t.intersects(r,i(n),n,e)}function x(n,e){return t.touches(r,i(n),n,e)}function y(n,e){return t.within(r,i(n),n,e)}function S(n,e){return t.disjoint(r,i(n),n,e)}function A(n,e){return t.overlaps(r,i(n),n,e)}function D(n,e,a){return t.relate(r,i(n),n,e,a)}function L(n){return t.isSimple(r,i(n),n)}function T(n){return t.simplify(r,i(n),n)}function V(n,e=!1){return t.convexHull(r,i(n),n,e)}function v(n,e){return t.difference(r,i(n),n,e)}function z(n,e){return t.symmetricDifference(r,i(n),n,e)}function H(n,e){return t.intersect(r,i(n),n,e)}function I(n,e=null){return t.union(r,i(n),n,e)}function J(n,e,a,s,c,u){return t.offset(r,i(n),n,e,a,s,c,u)}function N(n,e,a,s=!1){return t.buffer(r,i(n),n,e,a,s)}function O(n,e,a,s,c,u){return t.geodesicBuffer(r,i(n),n,e,a,s,c,u)}function b(n,e,a=!0){return t.nearestCoordinate(r,i(n),n,e,a)}function j(n,e){return t.nearestVertex(r,i(n),n,e)}function q(n,e,a,s){return t.nearestVertices(r,i(n),n,e,a,s)}function f(n){return"xmin"in n?"center"in n?n.center:null:"x"in n?n:"extent"in n?n.extent?.center??null:null}function B(n,e,a){if(n==null)throw new o;const s=n.spatialReference;if((a=a??f(n))==null)throw new o;const c=n.constructor.fromJSON(t.rotate(n,e,a));return c.spatialReference=s,c}function C(n,e){if(n==null)throw new o;const a=n.spatialReference;if((e=e??f(n))==null)throw new o;const s=n.constructor.fromJSON(t.flipHorizontal(n,e));return s.spatialReference=a,s}function E(n,e){if(n==null)throw new o;const a=n.spatialReference;if((e=e??f(n))==null)throw new o;const s=n.constructor.fromJSON(t.flipVertical(n,e));return s.spatialReference=a,s}function P(n,e,a,s){return t.generalize(r,i(n),n,e,a,s)}function G(n,e,a){return t.densify(r,i(n),n,e,a)}function k(n,e,a,s=0){return t.geodesicDensify(r,i(n),n,e,a,s)}function F(n,e){return t.planarArea(r,i(n),n,e)}function K(n,e){return t.planarLength(r,i(n),n,e)}function M(n,e,a){return t.geodesicArea(r,i(n),n,e,a)}function Q(n,e,a){return t.geodesicLength(r,i(n),n,e,a)}function U(n,e){return t.intersectLinesToPoints(r,i(n),n,e)}function W(n,e){t.changeDefaultSpatialReferenceTolerance(n,e)}function X(n){t.clearDefaultSpatialReferenceTolerance(n)}class o extends Error{constructor(){super("Illegal Argument Exception")}}export{N as buffer,W as changeDefaultSpatialReferenceTolerance,X as clearDefaultSpatialReferenceTolerance,p as clip,g as contains,V as convexHull,h as crosses,d as cut,G as densify,v as difference,S as disjoint,m as distance,w as equals,l as extendedSpatialReferenceInfo,C as flipHorizontal,E as flipVertical,P as generalize,M as geodesicArea,O as geodesicBuffer,k as geodesicDensify,Q as geodesicLength,H as intersect,U as intersectLinesToPoints,R as intersects,L as isSimple,b as nearestCoordinate,j as nearestVertex,q as nearestVertices,J as offset,A as overlaps,F as planarArea,K as planarLength,D as relate,B as rotate,T as simplify,z as symmetricDifference,x as touches,I as union,y as within};
