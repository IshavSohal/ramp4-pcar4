import{ac as j,s as p,D as Z}from"./main-C02UbYD7.js";import{C as M,c as T,P as s,B as x,G as d,M as I,U as O,L as E,D as J,V as F}from"./enums-DDkmfb-t.js";const Q=()=>Z.getLogger("esri.views.webgl.checkWebGLError");function ee(t,e){switch(e){case t.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case t.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case t.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case t.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case t.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case t.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}const L=!!j("enable-feature:webgl-debug");function B(){return L}function te(){return L}function D(t){if(B()){const e=t.getError();if(e){const r=ee(t,e),n=new Error().stack;Q().error(new p("webgl-error","WebGL error occurred",{message:r,stack:n}))}}}var U;(function(t){t[t.Texture=0]="Texture",t[t.RenderBuffer=1]="RenderBuffer"})(U||(U={}));function y(t){switch(t){case M.BYTE:case M.UNSIGNED_BYTE:return 1;case M.SHORT:case M.UNSIGNED_SHORT:case M.HALF_FLOAT:return 2;case M.FLOAT:case M.INT:case M.UNSIGNED_INT:return 4}}function v(t){const e=t.gl;switch(e.getError()){case e.NO_ERROR:return null;case e.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case e.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case e.INVALID_OPERATION:return"The specified command is not allowed for the current state";case e.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case e.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case e.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function re(t,e,r,n,i=0){const o=t.gl;t.bindBuffer(r);for(const a of n){const h=e.get(a.name);if(h===void 0){console.warn(`There is no location for vertex attribute '${a.name}' defined.`);continue}const l=i*a.stride;if(a.count<=4)o.vertexAttribPointer(h,a.count,a.type,a.normalized,a.stride,a.offset+l),o.enableVertexAttribArray(h),a.divisor>0&&t.gl.vertexAttribDivisor(h,a.divisor);else if(a.count===9)for(let c=0;c<3;c++)o.vertexAttribPointer(h+c,3,a.type,a.normalized,a.stride,a.offset+12*c+l),o.enableVertexAttribArray(h+c),a.divisor>0&&t.gl.vertexAttribDivisor(h+c,a.divisor);else if(a.count===16)for(let c=0;c<4;c++)o.vertexAttribPointer(h+c,4,a.type,a.normalized,a.stride,a.offset+16*c+l),o.enableVertexAttribArray(h+c),a.divisor>0&&t.gl?.vertexAttribDivisor(h+c,a.divisor);else console.error("Unsupported vertex attribute element count: "+a.count);if(B()){const c=v(t),u=y(a.type),_=a.offset,m=Math.round(u/_)!==u/_?`. Offset not a multiple of stride. DataType requires ${u} bytes, but descriptor has an offset of ${_}`:"";c&&console.error(`Unable to bind vertex attribute "${a.name}" with baseInstanceOffset ${l}${m}:`,c,a)}}}function X(t){switch(t){case d.ALPHA:case d.LUMINANCE:case d.RED:case d.RED_INTEGER:case s.R8:case s.R8I:case s.R8UI:case s.R8_SNORM:case x.STENCIL_INDEX8:return 1;case d.LUMINANCE_ALPHA:case d.RG:case d.RG_INTEGER:case s.RGBA4:case s.R16F:case s.R16I:case s.R16UI:case s.RG8:case s.RG8I:case s.RG8UI:case s.RG8_SNORM:case s.RGB565:case s.RGB5_A1:case x.DEPTH_COMPONENT16:return 2;case d.DEPTH_COMPONENT:case d.RGB:case d.RGB_INTEGER:case s.RGB8:case s.RGB8I:case s.RGB8UI:case s.RGB8_SNORM:case s.SRGB8:case x.DEPTH_COMPONENT24:return 3;case d.DEPTH_STENCIL:case d.DEPTH24_STENCIL8:case d.RGBA:case d.RGBA_INTEGER:case s.RGBA8:case s.R32F:case s.R11F_G11F_B10F:case s.RG16F:case s.R32I:case s.R32UI:case s.RG16I:case s.RG16UI:case s.RGBA8I:case s.RGBA8UI:case s.RGBA8_SNORM:case s.SRGB8_ALPHA8:case s.RGB9_E5:case s.RGB10_A2UI:case s.RGB10_A2:case x.DEPTH_STENCIL:case x.DEPTH_COMPONENT32F:case x.DEPTH24_STENCIL8:return 4;case x.DEPTH32F_STENCIL8:return 5;case s.RGB16F:case s.RGB16I:case s.RGB16UI:return 6;case s.RG32F:case s.RG32I:case s.RG32UI:case s.RGBA16F:case s.RGBA16I:case s.RGBA16UI:return 8;case s.RGB32F:case s.RGB32I:case s.RGB32UI:return 12;case s.RGBA32F:case s.RGBA32I:case s.RGBA32UI:return 16;case T.COMPRESSED_RGB_S3TC_DXT1_EXT:case T.COMPRESSED_RGBA_S3TC_DXT1_EXT:return .5;case T.COMPRESSED_RGBA_S3TC_DXT3_EXT:case T.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case T.COMPRESSED_R11_EAC:case T.COMPRESSED_SIGNED_R11_EAC:case T.COMPRESSED_RGB8_ETC2:case T.COMPRESSED_SRGB8_ETC2:case T.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case T.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return .5;case T.COMPRESSED_RG11_EAC:case T.COMPRESSED_SIGNED_RG11_EAC:case T.COMPRESSED_RGBA8_ETC2_EAC:case T.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}class H{constructor(e=0,r=e){this.width=e,this.height=r,this.target=I.TEXTURE_2D,this.pixelFormat=d.RGBA,this.dataType=O.UNSIGNED_BYTE,this.samplingMode=E.LINEAR,this.wrapMode=J.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.depth=1,this.isImmutable=!1}}function ie(t){return t.width<=0||t.height<=0?0:Math.round(t.width*t.height*(t.hasMipmap?4/3:1)*(t.internalFormat==null?4:X(t.internalFormat)))}class C extends H{constructor(e,r){switch(super(),this.context=e,Object.assign(this,r),this.internalFormat){case s.R16F:case s.R16I:case s.R16UI:case s.R32F:case s.R32I:case s.R32UI:case s.R8_SNORM:case s.R8:case s.R8I:case s.R8UI:this.pixelFormat=d.RED}}static validate(e,r){return new C(e,r)}}const V=4;let W=class g{constructor(e,r=null,n=null){if(this.type=U.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,n=r;else{const i=C.validate(e,r);if(!i)throw new p("Texture descriptor invalid");this._descriptor=i}this._descriptor.target===I.TEXTURE_CUBE_MAP?this._setDataCubeMap(n):this.setData(n)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return ie(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._glName&&this._descriptor.context.instanceCounter.decrement(F.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,r){const n=this._descriptor;if(n.width!==e||n.height!==r){if(this._wasImmutablyAllocated)throw new p("Immutable textures can't be resized!");n.width=e,n.height=r,this._descriptor.target===I.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(e=null){for(let r=I.TEXTURE_CUBE_MAP_POSITIVE_X;r<=I.TEXTURE_CUBE_MAP_NEGATIVE_Z;r++)this._setData(e,r)}setData(e){this._setData(e)}_setData(e,r){if(!this._descriptor.context?.gl)return;const n=this._descriptor.context.gl;D(n),this._glName||(this._glName=n.createTexture(),this._glName&&this._descriptor.context.instanceCounter.increment(F.Texture,this)),e===void 0&&(e=null);const i=this._descriptor,o=r??i.target,a=S(o);e===null&&(i.width=i.width||V,i.height=i.height||V,a&&(i.depth=i.depth??1));const h=this._descriptor.context.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(g.TEXTURE_UNIT_FOR_UPDATES),b(i),this._configurePixelStorage(),D(n);const l=this._deriveInternalFormat();if(k(e)){let c="width"in e?e.width:e.codedWidth,u="height"in e?e.height:e.codedHeight;const _=1;e instanceof HTMLVideoElement&&(c=e.videoWidth,u=e.videoHeight),i.width&&i.height,a&&i.depth,i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(o,l,i.hasMipmap,c,u,_),this._texImage(o,0,l,c,u,_,e),D(n),i.hasMipmap&&this.generateMipmap(),i.width||(i.width=c),i.height||(i.height=u),a&&!i.depth&&(i.depth=_)}else{const{width:c,height:u,depth:_}=i;if(c==null||u==null)throw new p("Width and height must be specified!");if(a&&_==null)throw new p("Depth must be specified!");if(i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(o,l,i.hasMipmap,c,u,_),w(e)){const m=e.levels,R=K(o,c,u,_),N=Math.min(R-1,m.length-1);n.texParameteri(i.target,this._descriptor.context.gl.TEXTURE_MAX_LEVEL,N);const f=l;if(!ne(f))throw new p("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel((A,P,G,$)=>{const q=m[Math.min(A,m.length-1)];this._compressedTexImage(o,A,f,P,G,$,q)},N)}else this._texImage(o,0,l,c,u,_,e),D(n),i.hasMipmap&&this.generateMipmap()}z(n,this._descriptor),Y(n,this._descriptor),se(this._descriptor.context,this._descriptor),D(n),this._descriptor.context.bindTexture(h,g.TEXTURE_UNIT_FOR_UPDATES)}updateData(e,r,n,i,o,a,h=0){a||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const l=this._descriptor,c=this._deriveInternalFormat(),{context:u,pixelFormat:_,dataType:m,target:R,isImmutable:N}=l;if(N&&!this._wasImmutablyAllocated)throw new p("Cannot update immutable texture before allocation!");const f=u.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES,!0);(r<0||n<0||r+i>l.width||n+o>l.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:A}=u;h&&A.pixelStorei(A.UNPACK_SKIP_ROWS,h),k(a)?A.texSubImage2D(R,e,r,n,i,o,_,m,a):w(a)?A.compressedTexSubImage2D(R,e,r,n,i,o,c,a.levels[e]):A.texSubImage2D(R,e,r,n,i,o,_,m,a),h&&A.pixelStorei(A.UNPACK_SKIP_ROWS,0),u.bindTexture(f,g.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,r,n,i,o,a,h,l){l||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const c=this._descriptor,u=this._deriveInternalFormat(),{context:_,pixelFormat:m,dataType:R,isImmutable:N,target:f}=c;if(N&&!this._wasImmutablyAllocated)throw new p("Cannot update immutable texture before allocation!");S(f)||console.warn("Attempting to set 3D texture data on a non-3D texture");const A=_.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);_.setActiveTexture(g.TEXTURE_UNIT_FOR_UPDATES),(r<0||n<0||i<0||r+o>c.width||n+a>c.height||i+h>c.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:P}=_;if(w(l))l=l.levels[e],P.compressedTexSubImage3D(f,e,r,n,i,o,a,h,u,l);else{const G=l;P.texSubImage3D(f,e,r,n,i,o,a,h,m,R,G)}_.bindTexture(A,g.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const e=this._descriptor;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new p("Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,b(e)}e.samplingMode===E.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=E.LINEAR_MIPMAP_NEAREST):e.samplingMode===E.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=E.NEAREST_MIPMAP_NEAREST);const r=this._descriptor.context.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(g.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(r,g.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){const e=this._descriptor;if(e.hasMipmap){if(this._wasImmutablyAllocated)throw new p("Cannot delete mipmaps to immutable texture after allocation");e.hasMipmap=!1,this._samplingModeDirty=!0,b(e)}e.samplingMode===E.LINEAR_MIPMAP_NEAREST?(this._samplingModeDirty=!0,e.samplingMode=E.LINEAR):e.samplingMode===E.NEAREST_MIPMAP_NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=E.NEAREST)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,b(this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const e=this._descriptor,r=e.context.gl;this._samplingModeDirty&&(z(r,e),this._samplingModeDirty=!1),this._wrapModeDirty&&(Y(r,e),this._wrapModeDirty=!1)}_deriveInternalFormat(){if(this._descriptor.internalFormat!=null)return this._descriptor.internalFormat===d.DEPTH_STENCIL&&(this._descriptor.internalFormat=d.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case O.FLOAT:switch(this._descriptor.pixelFormat){case d.RGBA:return this._descriptor.internalFormat=s.RGBA32F;case d.RGB:return this._descriptor.internalFormat=s.RGB32F;default:throw new p("Unable to derive format")}case O.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case d.RGBA:return this._descriptor.internalFormat=s.RGBA8;case d.RGB:return this._descriptor.internalFormat=s.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===d.DEPTH_STENCIL?d.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:r,flipped:n,preMultiplyAlpha:i}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,r),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,n?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i?1:0)}_texStorage(e,r,n,i,o,a){const{gl:h}=this._descriptor.context;if(!ae(r))throw new p("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const l=n?K(e,i,o,a):1;if(S(e)){if(a==null)throw new p("Missing depth dimension for 3D texture upload");h.texStorage3D(e,l,r,i,o,a)}else h.texStorage2D(e,l,r,i,o);this._wasImmutablyAllocated=!0}_texImage(e,r,n,i,o,a,h){const l=this._descriptor.context.gl,c=S(e),{isImmutable:u,pixelFormat:_,dataType:m}=this._descriptor;if(u){if(h!=null){const R=h;if(c){if(a==null)throw new p("Missing depth dimension for 3D texture upload");l.texSubImage3D(e,r,0,0,0,i,o,a,_,m,R)}else l.texSubImage2D(e,r,0,0,i,o,_,m,R)}}else{const R=h;if(c){if(a==null)throw new p("Missing depth dimension for 3D texture upload");l.texImage3D(e,r,n,i,o,a,0,_,m,R)}else l.texImage2D(e,r,n,i,o,0,_,m,R)}}_compressedTexImage(e,r,n,i,o,a,h){const l=this._descriptor.context.gl,c=S(e);if(this._descriptor.isImmutable){if(h!=null)if(c){if(a==null)throw new p("Missing depth dimension for 3D texture upload");l.compressedTexSubImage3D(e,r,0,0,0,i,o,a,n,h)}else l.compressedTexSubImage2D(e,r,0,0,i,o,n,h)}else if(c){if(a==null)throw new p("Missing depth dimension for 3D texture upload");l.compressedTexImage3D(e,r,n,i,o,a,0,h)}else l.compressedTexImage2D(e,r,n,i,o,0,h)}_forEachMipmapLevel(e,r=1/0){let{width:n,height:i,depth:o,hasMipmap:a,target:h}=this._descriptor;const l=h===I.TEXTURE_3D;if(n==null||i==null||l&&o==null)throw new p("Missing texture dimensions for mipmap calculation");for(let c=0;e(c,n,i,o),a&&(n!==1||i!==1||l&&o!==1)&&!(c>=r);++c)n=Math.max(1,n>>1),i=Math.max(1,i>>1),l&&(o=Math.max(1,o>>1))}};function b(t){(t.width!=null&&t.width<0||t.height!=null&&t.height<0||t.depth!=null&&t.depth<0)&&console.error("Negative dimension parameters are not allowed!")}function z(t,e){let r=e.samplingMode,n=e.samplingMode;r===E.LINEAR_MIPMAP_NEAREST||r===E.LINEAR_MIPMAP_LINEAR?(r=E.LINEAR,e.hasMipmap||(n=E.LINEAR)):r!==E.NEAREST_MIPMAP_NEAREST&&r!==E.NEAREST_MIPMAP_LINEAR||(r=E.NEAREST,e.hasMipmap||(n=E.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,r),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,n)}function Y(t,e){typeof e.wrapMode=="number"?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}function se(t,e){const r=t.capabilities.textureFilterAnisotropic;r&&t.gl.texParameterf(e.target,r.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}function ae(t){return t in s}function ne(t){return t in T}function w(t){return t!=null&&"type"in t&&t.type==="compressed"}function oe(t){return t!=null&&"byteLength"in t}function k(t){return t!=null&&!w(t)&&!oe(t)}function S(t){return t===I.TEXTURE_3D||t===I.TEXTURE_2D_ARRAY}function K(t,e,r,n=1){let i=Math.max(e,r);return t===I.TEXTURE_3D&&(i=Math.max(i,n)),Math.round(Math.log(i)/Math.LN2)+1}W.TEXTURE_UNIT_FOR_UPDATES=0;export{re as E,X as a,U as b,W as c,B as d,H as e,te as f,v as o,y as s,D as u};
