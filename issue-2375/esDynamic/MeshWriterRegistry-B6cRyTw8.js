import{a as ae,c as ne,f as E,e as P}from"./UpdateTracking2D-Dbow3jYu.js";import{N,m as oe,S as T,g as he,i as le,a as ce,T as ue,s as de,v as me,_ as fe,c as pe,h as _e,o as ge,b as xe,d as ye,e as ve}from"./PieChartMeshWriter-DHDfWlls.js";import{jh as Me,c_ as $,ji as Pe,jj as j,cN as O,bL as X,jk as Y,fk as I,jl as H,jm as V,jn as we,jo as Q,jp as be,d5 as Z,fg as S,$ as B,ad as Ie,s as Se,D as Le}from"./main-C02UbYD7.js";import{r as A,i as ke,o as ze}from"./LabelMetric-BYq7UFJE.js";import{t as D}from"./constants-DVpDF9P6.js";import{o as Ee}from"./grouping-CANWASHK.js";import{s as Be}from"./AttributeStore-DjaXxfNc.js";function J(h,e,s){return h[0]=e[0]-s[0],h[1]=e[1]-s[1],h}function K(h,e){return Math.sqrt(h*h+e*e)}function U(h){const e=K(h[0],h[1]);h[0]/=e,h[1]/=e}function Ae(h,e){return K(h[0]-e[0],h[1]-e[1])}function De(h,e){return h[e+1]}function ee(h){return h.length-1}function Re(h){let e=0;for(let s=0;s<ee(h);s++)e+=Fe(h,s);return e}function Fe(h,e,s=1){let[t,i]=De(h,e);return[t,i]=[Math.round(t),Math.round(i)],Math.sqrt(t*t+i*i)*s}class G{constructor(e,s,t,i,r){this._segments=e,this._index=s,this._distance=t,this._xStart=i,this._yStart=r,this._done=!1}static create(e){return new G(e,0,0,e[0][0],e[0][1])}clone(){return new G(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(e){return this._index===e._index||e._index===this._index-1&&(this._distance===0||e._distance===1)||e._index===this._index+1&&(this._distance===1||e._distance===0)}leq(e){return this._index<e._index||this._index===e._index&&this._distance<=e._distance}geq(e){return this._index>e._index||this._index===e._index&&this._distance>=e._distance}get _segment(){return this._segments[this._index+1]}get angle(){const e=this.dy,s=(0*e+-1*-this.dx)/(1*this.length);let t=Math.acos(s);return e>0&&(t=2*Math.PI-t),t}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:e,dy:s}=this;return Math.sqrt(e*e+s*s)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<ee(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(e,s){const t=this.backwardLength;if(e<=t)return this._distance=(t-e)/this.length,this;let i=this.backwardLength;for(;this.prev();){if(i+this.length>e)return this._seekBackwards(e-i);i+=this.length}return this._distance=0,s?this:null}seek(e,s=!1){if(e<0)return this._seekBackwards(Math.abs(e),s);if(e<=this.remainingLength)return this._distance=(this.backwardLength+e)/this.length,this;let t=this.remainingLength;for(;this.next();){if(t+this.length>e)return this.seek(e-t,s);t+=this.length}return this._distance=1,s?this:null}}function W(h,e,s,t=!0){const i=Re(h),r=G.create(h),n=i/2;if(!t)return r.seek(n),void(Math.abs(r.x)<D&&Math.abs(r.y)<D&&s(r.clone(),0,n+0*e,i));const l=Math.max((i-e)/2,0),o=Math.floor(l/e),d=n-o*e;r.seek(d);for(let a=-o;a<=o;a++)Math.abs(r.x)<D&&Math.abs(r.y)<D&&s(r.clone(),a,n+a*e,i),r.seek(e)}function C(h,e){const s=e;for(let t=0;t<h.length;t++){let i=h[t];Ge(i,s);const r=[];r.push(i[0]);for(let n=1;n<i.length;n++){const[l,o]=i[n-1],[d,a]=i[n],c=d-l,u=a-o;r.push([c,u])}h[t]=r,i=r}return h}function Ge(h,e){if(e<=0)return;const s=h.length;if(s<3)return;const t=[];let i=0;t.push(0);for(let a=1;a<s;a++)i+=Ae(h[a],h[a-1]),t.push(i);e=Math.min(e,.2*i);const r=[];r.push(h[0][0]),r.push(h[0][1]);const n=h[s-1][0],l=h[s-1][1],o=J([0,0],h[0],h[1]);U(o),h[0][0]+=e*o[0],h[0][1]+=e*o[1],J(o,h[s-1],h[s-2]),U(o),h[s-1][0]+=e*o[0],h[s-1][1]+=e*o[1];for(let a=1;a<s;a++)t[a]+=e;t[s-1]+=e;const d=.5*e;for(let a=1;a<s-1;a++){let c=0,u=0,_=0;for(let m=a-1;m>=0&&!(t[m+1]<t[a]-d);m--){const p=d+t[m+1]-t[a],f=t[m+1]-t[m],g=t[a]-t[m]<d?1:p/f;if(Math.abs(g)<1e-6)break;const x=g*g,M=g*p-.5*x*f,w=g*f/e,y=h[m+1],b=h[m][0]-y[0],v=h[m][1]-y[1];c+=w/M*(y[0]*g*p+.5*x*(p*b-f*y[0])-x*g*f*b/3),u+=w/M*(y[1]*g*p+.5*x*(p*v-f*y[1])-x*g*f*v/3),_+=w}for(let m=a+1;m<s&&!(t[m-1]>t[a]+d);m++){const p=d-t[m-1]+t[a],f=t[m]-t[m-1],g=t[m]-t[a]<d?1:p/f;if(Math.abs(g)<1e-6)break;const x=g*g,M=g*p-.5*x*f,w=g*f/e,y=h[m-1],b=h[m][0]-y[0],v=h[m][1]-y[1];c+=w/M*(y[0]*g*p+.5*x*(p*b-f*y[0])-x*g*f*b/3),u+=w/M*(y[1]*g*p+.5*x*(p*v-f*y[1])-x*g*f*v/3),_+=w}r.push(c/_),r.push(u/_)}r.push(n),r.push(l);for(let a=0,c=0;a<s;a++)h[a][0]=r[c++],h[a][1]=r[c++]}const R=1,L=0,Te=128,je=be(h=>{let e=0;if(h===0)return 1/0;for(;!(h%2);)e++,h/=2;return e});class Oe extends N{constructor(){super(...arguments),this._zoomLevel=0}_write(e,s,t,i){if(this._zoomLevel=i||0,t!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(s.geometryType){case"esriGeometryPoint":{const r=s.readXForDisplay(),n=s.readYForDisplay();return this._writePoint(e,r,n,s)}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const r=s.readCentroidForDisplay();if(!r)return;const[n,l]=r.coords;return this._writePoint(e,n,l,s)}case"esriGeometryPolyline":this._writeLines(e,s)}}_writePoint(e,s,t,i){const r=this._getShaping();if(!r)return;let n=this._getPointReferenceBounds();n||(n={offsetX:0,offsetY:0,size:0});const l=r.boundsT,o=ae(this.evaluatedMeshParams.horizontalAlignment),d=ne(this.evaluatedMeshParams.verticalAlignment),a=this.evaluatedMeshParams.scaleInfo?.maxScale??0,c=this.evaluatedMeshParams.scaleInfo?.minScale??0,u=E(i.getDisplayId());e.metricStart(new A(u,s,t,o,d,a,c,n)),e.metricBoxWrite(l),this._writeGlyphs(e,i.getDisplayId(),s,t,r,0,n),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const s=e.getBoundsInfo();if(s)return s}return null}_writeLines(e,s){const{scaleInfo:t,verticalAlignment:i}=this.evaluatedMeshParams,r=this.evaluatedMeshParams.repeatLabelDistance||128,n=this._getShaping("middle");if(!n)return;const l=(d,a,c,u)=>this._placeSubdivGlyphs(d,a,c,u),o=(n.bounds.width+r)/(1<<R);this._current={out:e,id:s.getDisplayId(),shaping:n,zoomRange:oe(t,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null},this._verticalPlacement=i==="bottom"?"above":i==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(s,l,o):this._writeCenterAlong(s,l,o)}_writeAboveAndBelowAlong(e,s,t){const{repeatLabel:i,fontSize:r}=this.evaluatedMeshParams,{shaping:n}=this._current,l=O(r),o=e.readGeometryForDisplay();if(!o)return;const d=new Z;Me(d,o,!1,!1,"esriGeometryPolyline",1);const a=te(new Z,d,l),c=te(new Z,d,-l),u=$(c,"esriGeometryPolyline",!1,!1),_=$(a,"esriGeometryPolyline",!1,!1),m=C(_.paths,n.bounds.width),p=C(u.paths,n.bounds.width);this._current.offsetDirection="above";for(const f of m)W(f,t,s,!!i);this._current.offsetDirection="below";for(const f of p)W(f,t,s,!!i)}_writeCenterAlong(e,s,t){const{repeatLabel:i}=this.evaluatedMeshParams,{shaping:r}=this._current,n=C(e.readLegacyGeometryForDisplay().paths,r.bounds.width);for(const l of n)W(l,t,s,!!i)}_placeSubdivGlyphs(e,s,t,i){const{allowOverrun:r,labelPosition:n,repeatLabelDistance:l}=this.evaluatedMeshParams,o=this._current.zoomRange[0],d=je(s),a=this._current.shaping.bounds.width/(1<<R),c=Math.sqrt(l||Te)/(1<<R),u=Math.min(t,i-t),_=this._current.shaping.isMultiline?T:Math.log2(u/(c+a/2)),m=s===0?_:Math.min(d,_),p=Math.max(o,this._zoomLevel+R-m),f=this._zoomLevel-p,g=this._current.shaping.bounds.width/2*2**f;this._current.shaping.isMultiline?s===0&&this._placeStraight(e,p):r&&f<0?this._placeStraightAlong(e,o):n==="parallel"?this._placeStraightAlong(e,p):n==="curved"&&this._placeCurved(e,p,g)}_placeStraight(e,s){const{out:t,id:i,shaping:r,referenceBounds:n}=this._current,{x:l,y:o}=e,d=E(i),a=this.evaluatedMeshParams.scaleInfo?.maxScale??0,c=this.evaluatedMeshParams.scaleInfo?.minScale??0;t.metricStart(new A(d,e.x,e.y,0,0,a,c,null)),t.metricBoxWrite(r.boundsT);const u=e.angle*(180/Math.PI)%360,_=(e.angle*(180/Math.PI)+180)%360;this._writeGlyphs(t,i,l,o,r,0,n,{clipAngle:u,mapAligned:!0,isLineLabel:!0,minZoom:s}),this._writeGlyphs(t,i,l,o,r,0,n,{clipAngle:_,mapAligned:!0,isLineLabel:!0,minZoom:s}),t.metricEnd()}_placeCurved(e,s,t){const{out:i,id:r}=this._current,n=e.clone(),l=e.angle*(180/Math.PI)%360,o=(e.angle*(180/Math.PI)+180)%360,d=E(r),a=this.evaluatedMeshParams.scaleInfo?.maxScale??0,c=this.evaluatedMeshParams.scaleInfo?.minScale??0;i.metricStart(new A(d,e.x,e.y,0,0,a,c,null)),this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(n,s,1,l),this._placeBack(e,n,s,t,1,l),this._placeForward(e,n,s,t,1,l)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(n,s,0,o),this._placeBack(e,n,s,t,0,o),this._placeForward(e,n,s,t,0,o)),i.metricEnd()}_placeStraightAlong(e,s){const{out:t,id:i,shaping:r,zoomRange:n,referenceBounds:l}=this._current,{boxBorderLineColor:o,boxBackgroundColor:d}=this.evaluatedMeshParams,a=e.clone(),c=e.angle*(180/Math.PI)%360,u=(e.angle*(180/Math.PI)+180)%360;if(r.glyphs.length>0&&!(!o&&!d)){const f=Math.max(s,n[0],0),g=Math.min(T,n[1]),x=Pe(j(),-e.angle),M={minZoom:f,maxZoom:g,clipAngle:c,mapAligned:!0,isLineLabel:!0},w=O(this.evaluatedMeshParams.offsetX),y=O(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const b=X(w,-1*y),[v,k]=r.shapeBackground(Y(j(),x,b));t.recordStart(this.instanceId,this.attributeLayout,r.glyphs[0].textureBinding);const z=2*Math.max(v.width,v.height);t.recordBounds(e.x+v.x,e.y+v.y,z,z),this._writeTextBox(t,i,e.x,e.y,k,l,M),t.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const b=X(w,y),[v,k]=r.shapeBackground(Y(j(),x,b));M.clipAngle=u,t.recordStart(this.instanceId,this.attributeLayout,r.glyphs[0].textureBinding);const z=2*Math.max(v.width,v.height);t.recordBounds(e.x+v.x,e.y+v.y,z,z),this._writeTextBox(t,i,e.x,e.y,k,l,M),t.recordEnd()}}const _=E(i),m=this.evaluatedMeshParams.scaleInfo?.maxScale??0,p=this.evaluatedMeshParams.scaleInfo?.minScale??0;t.metricStart(new A(_,e.x,e.y,0,0,m,p,null)),this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(a,s,1,c,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(a,s,0,u,!0),t.metricEnd()}_placeBack(e,s,t,i,r,n){const l=e.clone();let o=e.backwardLength+L;for(;l.prev()&&!(o>=i);)this._placeOnSegment(l,s,o,t,-1,r,n),o+=l.length+L}_placeForward(e,s,t,i,r,n){const l=e.clone();let o=e.remainingLength+L;for(;l.next()&&!(o>=i);)this._placeOnSegment(l,s,o,t,1,r,n),o+=l.length+L}_placeFirst(e,s,t,i,r=!1){const{out:n,id:l,shaping:o,zoomRange:d,referenceBounds:a}=this._current,c=o.glyphs;for(const u of c){const _=u.x>o.bounds.x?t:1-t,m=_*e.remainingLength+(1-_)*e.backwardLength,p=Math.abs(u.x+u.width/2-o.bounds.x),f=Math.max(0,this._zoomLevel+Math.log2(p/(m+L))),g=Math.max(s,r?0:f);u.maxZoom=Math.min(d[1],T),u.angle=e.angle+(1-t)*Math.PI,u.minZoom=Math.max(d[0],g),this._writeLineGlyph(n,l,e.x,e.y,o.bounds,u,i,a,!0),t&&this._isVisible(u.minZoom,u.maxZoom)&&n.metricBoxWrite(u.bounds)}}_placeOnSegment(e,s,t,i,r,n,l){const{out:o,id:d,shaping:a,referenceBounds:c}=this._current,u=a.glyphs,_=e.dx/e.length,m=e.dy/e.length,p={x:e.x+t*-r*_,y:e.y+t*-r*m};for(const f of u){const g=f.x>a.bounds.x?n:1-n;if(!(g&&r===1||!g&&r===-1))continue;const x=Math.abs(f.x+f.width/2-a.bounds.x),M=Math.max(0,this._zoomLevel+Math.log2(x/t)-.1),w=Math.max(i,this._zoomLevel+Math.log2(x/(t+e.length+L)));if(M!==0&&(f.angle=e.angle+(1-n)*Math.PI,f.minZoom=w,f.maxZoom=M,this._writeLineGlyph(o,d,p.x,p.y,a.bounds,f,l,c,!0),n&&this._isVisible(f.minZoom,f.maxZoom))){const y=f.bounds,b=e.x-s.x,v=e.y-s.y,k=new ke(y.center[0]+b,y.center[1]+v,y.width,y.height);o.metricBoxWrite(k)}}}_writeLineGlyph(e,s,t,i,r,n,l,o,d){const a=t+r.x,c=i+r.y,u=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),_=Math.max(r.width,r.height)*u;e.recordStart(this.instanceId,this.attributeLayout,n.textureBinding),e.recordBounds(a,c,_,_);const{texcoords:m,offsets:p}=n,f=this._textMeshTransformProps.fontSize;this._writeQuad(e,s,t,i,{texcoords:m,offsets:p,fontSize:f,color:he(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:o,minZoom:Math.max(this._current.zoomRange[0],n.minZoom),maxZoom:Math.min(this._current.zoomRange[1],n.maxZoom),clipAngle:l,mapAligned:d,isLineLabel:!0}),e.recordEnd()}_isVisible(e,s){const t=this._zoomLevel;return e<=t&&t<=s}}function te(h,e,s){const{coords:t,lengths:i}=e,r=S(),n=S(),l=S(),o=S(),d=S(),a=S(),c=2;let u=0;for(let _=0;_<i.length;_++){const m=i[_];for(let p=0;p<m;p++){const f=c*(p+u-1),g=c*(p+u),x=c*(p+u+1);p>0?I(r,t[f],t[f+1]):I(r,0,0),I(n,t[g],t[g+1]),p<m-1?I(l,t[x],t[x+1]):I(l,0,0),p===0?I(o,0,0):(H(o,n,r),V(o,o),I(o,o[1],-o[0])),p===m-1?I(d,0,0):(H(d,l,n),V(d,d),I(d,d[1],-d[0])),we(a,o,d),V(a,a);const M=a[0]*d[0]+a[1]*d[1];M!==0&&Q(a,a,M),Q(a,a,s),h.coords.push(n[0]+a[0],n[1]+a[1])}h.lengths.push(m),u+=m}return h}class se extends Be{constructor(e){super(),this._value=e}resize(e){}read(e,s){return this._value}readWithDefault(e,s,t){return this._value}referencesScale(){return!1}referencesGeometry(){return!1}}const Ve=()=>Le.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function F(h,e,s=!1){const{defaultValue:t,valueExpressionInfo:i,value:r}=e;if(i){const{expression:n}=i,l=await h.createComputedField({expression:n},s);return l?{...e,computed:l,defaultValue:t}:null}return{...e,computed:new se(r),defaultValue:t}}async function ie(h,e){const{defaultValue:s,valueExpressionInfo:t}=e,{expression:i}=t,r=await h.createComputedField({expression:i});return r?{...e,computed:r,defaultValue:s}:null}const re=h=>typeof h!="boolean"&&typeof h!="number"&&"valueExpressionInfo"in h,Ze=h=>h.some(e=>{for(const s in e){const t=e[s];if(re(t))return!0}return!1});class q{static async create(e,s,t){const i={},r=new Map,n=new Map,l=new Map,o=new Map,d=new Map;for(const a in t){const c=t[a];if(c!=null&&typeof c=="object")if(Array.isArray(c)){if(typeof c[0]=="object")throw new Error(`InternalError: Cannot handle ${a}. Nested array params are not supported`);i[a]=c}else if("valueExpressionInfo"in c){if(c.value){i[a]=c.value;continue}const u=await ie(e,c);if(!u){i[a]=c.defaultValue;continue}r.set(a,u),i[a]=null}else switch(c.type){case"cim-effect-infos":if(c.effectInfos.some(u=>u.overrides.length)){n.set(a,{effects:await Promise.all(c.effectInfos.map(async u=>{const _=u.overrides.map(m=>F(e,m));return{effect:u.effect,compiledOverrides:(await Promise.all(_)).filter(B)}}))});break}i[a]=c.effectInfos.map(u=>u.effect);break;case"cim-marker-placement-param":c.overrides.length&&l.set(a,{placementInfo:c,compiledOverrides:(await Promise.all(c.overrides.map(u=>F(e,u)))).filter(B)}),i[a]=c.placement;break;case"text-rasterization-param":{if(c.overrides.length){const _=c.overrides.map(m=>F(e,m,c.useLegacyLabelEvaluationRules));o.set(a,{compiledOverrides:(await Promise.all(_)).filter(B),rasterizationParam:c,objectIdToResourceId:new Map});continue}const u={type:"cim-rasterization-info",resource:c.resource};i[a]=await s.fetchResourceImmediate(u)??null;break}case"sprite-rasterization-param":{if(c.overrides.length){const _=c.overrides.map(m=>F(e,m));o.set(a,{compiledOverrides:(await Promise.all(_)).filter(B),rasterizationParam:c,objectIdToResourceId:new Map});continue}if(c.resource.type==="animated"){o.set(a,{compiledOverrides:[],rasterizationParam:c,objectIdToResourceId:new Map});continue}const u={type:"cim-rasterization-info",resource:c.resource};i[a]=await s.fetchResourceImmediate(u)??null;break}case"cim-marker-transform-param":{const{params:u}=c;if(Ze(u)){const _={compiledMarkerInfos:[]};await Promise.all(u.map(async m=>{const p={props:{}};for(const f in m)if(re(m[f])){const g=await ie(e,m[f]);p.compiledExpressionMap||(p.compiledExpressionMap=new Map);const x=p.compiledExpressionMap;g&&x.set(f,g)}else p.props[f]=m[f];_.compiledMarkerInfos.push(p)})),d.set(a,_)}else i[a]={type:"cim-marker-transform-info",infos:u};break}default:i[a]=c}else i[a]=c}return new q(t,i,r,n,l,o,d)}constructor(e,s,t,i,r,n,l){this.inputMeshParams=e,this._resolvedMeshParams=s,this._dynamicProperties=t,this._dynamicEffectProperties=i,this._dynamicPlacementProperties=r,this._dynamicAsyncProperties=n,this._dynamicTransformProperties=l,this.evaluator=o=>o}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,s,t){for(const i of this._dynamicAsyncProperties.values()){const r=Ie(i.rasterizationParam.resource);i.rasterizationParam.resource.type==="animated"&&i.rasterizationParam.resource.randomizeStartTime&&(r.primitiveName="__RESERVED__PRIMITIVE__NAME__",r.startGroup=Ee(s.getObjectId()||0));for(const{primitiveName:l,propertyName:o,computed:d,defaultValue:a,valueExpressionInfo:c}of i.compiledOverrides)try{const u=i.rasterizationParam.resource.type==="animated"?r.primitiveName:l;ze(r,u,o,d,s,t,a)}catch(u){Ve().errorOnce(new Se("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${c?.expression}' (primitive: '${l}', property: '${o}')`,u))}const n=e.enqueueRequest({type:"cim-rasterization-info",resource:r});i.objectIdToResourceId.set(s.getObjectId(),n)}}evaluateMeshParams(e,s,t){for(const[i,r]of this._dynamicProperties.entries())this._resolvedMeshParams[i]=r.computed.readWithDefault(s,t,r.defaultValue);for(const[i,r]of this._dynamicPlacementProperties.entries())for(const{computed:n,defaultValue:l,propertyName:o}of r.compiledOverrides){const d=n.readWithDefault(s,t,l);r.placementInfo.placement[o]=d,this._resolvedMeshParams[i]=r.placementInfo.placement}for(const[i,r]of this._dynamicEffectProperties.entries())for(const n of r.effects){for(const{computed:l,defaultValue:o,propertyName:d}of n.compiledOverrides){const a=l.readWithDefault(s,t,o);n.effect[d]=a}this._resolvedMeshParams[i]=r.effects.map(l=>l.effect)}for(const[i,r]of this._dynamicTransformProperties.entries()){const n={type:"cim-marker-transform-info",infos:[]};for(const l of r.compiledMarkerInfos){const o={...l.props};if(l.compiledExpressionMap)for(const[d,a]of l.compiledExpressionMap){const c=a.computed.readWithDefault(s,t,a.defaultValue);o[d]=typeof c=="number"||typeof c=="boolean"?c:a.defaultValue}n.infos.push(o)}this._resolvedMeshParams[i]=n}for(const[i,r]of this._dynamicAsyncProperties.entries()){const n=r.objectIdToResourceId.get(s.getObjectId());if(n==null)continue;const l=e.getResource(n);this._resolvedMeshParams[i]=l}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}}class We{async createMeshWriter(e,s,t,i){const r=this._getMeshWriter(i.techniqueType),n=await q.create(e,s,i.inputParams),l=new r(i.id,n,i.optionalAttributes,t);return await l.loadDependencies(),l}_getMeshWriter(e){switch(e){case P.Fill:return ve;case P.DotDensity:return ye;case P.ComplexFill:return xe;case P.PatternFill:return ge;case P.OutlineFill:return _e;case P.PatternOutlineFill:return pe;case P.ComplexOutlineFill:return fe;case P.Marker:return me;case P.PieChart:return de;case P.Text:return N;case P.Line:return ue;case P.TexturedLine:return ce;case P.Heatmap:return le;case P.Label:return Oe;case P.Test:throw new Error("Internal Error: Found invalid mesh writer")}}}export{We as W,se as r};
