import{e as At}from"./deduplicate-DVkwP1R7.js";import{H as b}from"./InterleavedLayout-D31rDeer.js";import{e as l}from"./VertexAttribute-CAkzp1tV.js";import{C as V}from"./enums-DDkmfb-t.js";import{t as Tt}from"./VertexElementDescriptor-BAy1DPb3.js";import{aI as T,bQ as G,j9 as wt,fo as $,dh as rt,aE as K,j7 as Mt,kY as vt,aF as at,di as it,aH as ct,ge as lt,aP as Rt,dl as Pt,kZ as yt}from"./main-C02UbYD7.js";function Y(t,n=0){const o=t.stride;return Array.from(t.fields.keys()).map(r=>{const s=t.fields.get(r),c=s.constructor.ElementCount,h=Dt(s.constructor.ElementType),g=s.offset,N=s.optional?.glNormalized??!1;return new Tt(r,c,h,g,o,N,n)})}function Dt(t){const n=Vt[t];if(n)return n;throw new Error("BufferType not supported in WebGL")}const Vt={u8:V.UNSIGNED_BYTE,u16:V.UNSIGNED_SHORT,u32:V.UNSIGNED_INT,i8:V.BYTE,i16:V.SHORT,i32:V.INT,f32:V.FLOAT},ut=b().vec3f(l.POSITION).u16(l.COMPONENTINDEX).freeze(),Ct=b().vec2u8(l.SIDENESS).freeze();Y(Ct);const j=b().vec3f(l.POSITION0).vec3f(l.POSITION1).vec2i16(l.NORMALCOMPRESSED).u16(l.COMPONENTINDEX).u8(l.VARIANTOFFSET,{glNormalized:!0}).u8(l.VARIANTSTROKE).u8(l.VARIANTEXTENSION,{glNormalized:!0}).freeze(),q=b().vec3f(l.POSITION0).vec3f(l.POSITION1).vec2i16(l.NORMALCOMPRESSED).vec2i16(l.NORMAL2COMPRESSED).u16(l.COMPONENTINDEX).u8(l.VARIANTOFFSET,{glNormalized:!0}).u8(l.VARIANTSTROKE).u8(l.VARIANTEXTENSION,{glNormalized:!0}).freeze();l.POSITION0,l.POSITION1,l.COMPONENTINDEX,l.VARIANTOFFSET,l.VARIANTSTROKE,l.VARIANTEXTENSION,l.NORMALCOMPRESSED,l.NORMAL2COMPRESSED,l.SIDENESS;let Lt=class{constructor(){this.position0=T(),this.position1=T(),this.faceNormal0=T(),this.faceNormal1=T(),this.componentIndex=0,this.cosAngle=0}};const U=-1;function ft(t,n,o){const r=t.vertices.position,s=t.vertices.componentIndex,c=S.position0,h=S.position1,g=S.faceNormal0,N=S.faceNormal1,{edges:i,normals:d}=Bt(t),m=i.length/4,E=n.allocate(m);let D=0;const _=m,w=o?.allocate(_);let z=0,e=0,a=0;X.length=0;for(let p=0;p<m;++p){const v=4*p;r.getVec(i.data[v],c),r.getVec(i.data[v+1],h);const L=X.pushNew();L.index=4*p,L.length=wt(c,h)}X.sort((p,v)=>v.length-p.length);const f=new Array,u=new Array;X.forAll(({length:p,index:v})=>{const L=i.data[v],Et=i.data[v+1],nt=i.data[v+2],ot=i.data[v+3],st=ot===U;if(r.getVec(L,c),r.getVec(Et,h),st){const A=3*nt;$(g,d.data[A],d.data[A+1],d.data[A+2]),rt(N,g),S.componentIndex=s.get(L),S.cosAngle=K(g,N)}else{let A=3*nt;if($(g,d.data[A],d.data[A+1],d.data[A+2]),A=3*ot,$(N,d.data[A],d.data[A+1],d.data[A+2]),S.componentIndex=s.get(L),S.cosAngle=K(g,N),Ft(S,Ut))return;S.cosAngle<-.9999&&rt(N,g)}e+=p,a++,st||bt(S,Wt)?(n.write(E,D++,S),f.push(p)):xt(S,ht)&&(w&&o&&o.write(w,z++,S),u.push(p))});const O=new Float32Array(f.reverse()),M=new Float32Array(u.reverse()),R=w&&o?{instancesData:w.slice(0,z),lodInfo:{lengths:M}}:void 0;return{regular:{instancesData:E.slice(0,D),lodInfo:{lengths:O}},silhouette:R,averageEdgeLength:e/a}}function bt(t,n){return t.cosAngle<n}function Ft(t,n){return t.cosAngle>n}function xt(t,n){const o=Mt(t.cosAngle);return vt(dt,t.position1,t.position0),o*(K(at(zt,t.faceNormal0,t.faceNormal1),dt)>0?-1:1)>n}function Bt(t){const n=t.faces.length/3,o=t.faces,r=t.neighbors,s=t.vertices.position;I.length=Q.length=0;for(let c=0;c<n;c++){const h=3*c,g=r[h],N=r[h+1],i=r[h+2],d=o[h],m=o[h+1],E=o[h+2];s.getVec(d,C),s.getVec(m,W),s.getVec(E,H),it(W,W,C),it(H,H,C),at(C,W,H),ct(C,C),Q.pushArray(C),(g===U||d<m)&&(I.push(d),I.push(m),I.push(c),I.push(g)),(N===U||m<E)&&(I.push(m),I.push(E),I.push(c),I.push(N)),(i===U||E<d)&&(I.push(E),I.push(d),I.push(c),I.push(i))}return{edges:I,normals:Q}}class _t{constructor(){this.index=0,this.length=0}}const X=new G({allocator:t=>t||new _t,deallocator:null}),I=new G({deallocator:null}),Q=new G({deallocator:null}),S=new Lt,zt=T(),dt=T(),C=T(),W=T(),H=T(),ht=lt(4),Ut=Math.cos(ht),Xt=lt(35),Wt=Math.cos(Xt);function pt(t,n,o){const r=n/3,s=new Uint32Array(o+1),c=new Uint32Array(o+1),h=(e,a)=>{e<a?s[e+1]++:c[a+1]++};for(let e=0;e<r;e++){const a=t[3*e],f=t[3*e+1],u=t[3*e+2];h(a,f),h(f,u),h(u,a)}let g=0,N=0;for(let e=0;e<o;e++){const a=s[e+1],f=c[e+1];s[e+1]=g,c[e+1]=N,g+=a,N+=f}const i=new Uint32Array(6*r),d=s[o],m=(e,a,f)=>{if(e<a){const u=s[e+1]++;i[2*u]=a,i[2*u+1]=f}else{const u=c[a+1]++;i[2*d+2*u]=e,i[2*d+2*u+1]=f}};for(let e=0;e<r;e++){const a=t[3*e],f=t[3*e+1],u=t[3*e+2];m(a,f,e),m(f,u,e),m(u,a,e)}const E=(e,a)=>{const f=2*e,u=a-e;for(let O=1;O<u;O++){const M=i[f+2*O],R=i[f+2*O+1];let p=O-1;for(;p>=0&&i[f+2*p]>M;p--)i[f+2*p+2]=i[f+2*p],i[f+2*p+3]=i[f+2*p+1];i[f+2*p+2]=M,i[f+2*p+3]=R}};for(let e=0;e<o;e++)E(s[e],s[e+1]),E(d+c[e],d+c[e+1]);const D=new Int32Array(3*r),_=(e,a)=>e===t[3*a]?0:e===t[3*a+1]?1:e===t[3*a+2]?2:-1,w=(e,a)=>{const f=_(e,a);D[3*a+f]=-1},z=(e,a,f,u)=>{const O=_(e,a);D[3*a+O]=u;const M=_(f,u);D[3*u+M]=a};for(let e=0;e<o;e++){let a=s[e];const f=s[e+1];let u=c[e];const O=c[e+1];for(;a<f&&u<O;){const M=i[2*a],R=i[2*d+2*u];M===R?(z(e,i[2*a+1],R,i[2*d+2*u+1]),a++,u++):M<R?(w(e,i[2*a+1]),a++):(w(R,i[2*d+2*u+1]),u++)}for(;a<f;)w(e,i[2*a+1]),a++;for(;u<O;)w(i[2*d+2*u],i[2*d+2*u+1]),u++}return D}function Z(t,n,o,r,s,c=2){const h=1/(Math.abs(o)+Math.abs(r)+Math.abs(s)),g=o*h,N=r*h,i=s<=0?(g>=0?1:-1)*(1-Math.abs(N)):g,d=s<=0?(N>=0?1:-1)*(1-Math.abs(g)):N,m=n*c;t[m]=gt(i),t[m+1]=gt(d)}function gt(t){return Rt(Math.round(32767*t),-32767,32767)}const J=.7;let Nt=class{updateSettings(t){this.settings=t,this._edgeHashFunction=t.reducedPrecision?kt:Ht}write(t,n,o){k.seed=this._edgeHashFunction(o);const r=k.getIntRange(0,255),s=k.getIntRange(0,this.settings.variants-1),c=k.getFloat(),h=255*(.5*Gt(-(1-Math.min(c/J,1))+Math.max(0,c-J)/(1-J),1.2)+.5);t.position0.setVec(n,o.position0),t.position1.setVec(n,o.position1),t.componentIndex.set(n,o.componentIndex),t.variantOffset.set(n,r),t.variantStroke.set(n,s),t.variantExtension.set(n,h)}};const P=new Float32Array(6),y=new Uint32Array(P.buffer),F=new Uint32Array(1);function Ht(t){return P[0]=t.position0[0],P[1]=t.position0[1],P[2]=t.position0[2],P[3]=t.position1[0],P[4]=t.position1[1],P[5]=t.position1[2],F[0]=31*(31*(31*(31*(31*(166811+y[0])+y[1])+y[2])+y[3])+y[4])+y[5],F[0]}function kt(t){const n=P;n[0]=x(t.position0[0]),n[1]=x(t.position0[1]),n[2]=x(t.position0[2]),n[3]=x(t.position1[0]),n[4]=x(t.position1[1]),n[5]=x(t.position1[2]),F[0]=5381;for(let o=0;o<y.length;o++)F[0]=31*F[0]+y[o];return F[0]}const mt=1e4;function x(t){return Math.round(t*mt)/mt}function Gt(t,n){return Math.abs(t)**n*Math.sign(t)}class tt{constructor(){this._commonWriter=new Nt}updateSettings(n){this._commonWriter.updateSettings(n)}allocate(n){return j.createBuffer(n)}write(n,o,r){this._commonWriter.write(n,o,r),Pt(B,r.faceNormal0,r.faceNormal1),ct(B,B);const{typedBuffer:s,typedBufferStride:c}=n.normalCompressed;Z(s,o,B[0],B[1],B[2],c)}}tt.Layout=j,tt.glLayout=Y(j,1);class et{constructor(){this._commonWriter=new Nt}updateSettings(n){this._commonWriter.updateSettings(n)}allocate(n){return q.createBuffer(n)}write(n,o,r){this._commonWriter.write(n,o,r);{const{typedBuffer:s,typedBufferStride:c}=n.normalCompressed;Z(s,o,r.faceNormal0[0],r.faceNormal0[1],r.faceNormal0[2],c)}{const{typedBuffer:s,typedBufferStride:c}=n.normal2Compressed;Z(s,o,r.faceNormal1[0],r.faceNormal1[1],r.faceNormal1[2],c)}}}et.Layout=q,et.glLayout=Y(q,1);const B=T(),k=new yt;function $t(t){const n=It(t.data,t.skipDeduplicate,t.indices,t.indicesLength);return St.updateSettings(t.writerSettings),Ot.updateSettings(t.writerSettings),ft(n,St,Ot)}function It(t,n,o,r){if(n){const h=pt(o,r,t.count);return new Kt(o,r,h,t)}const s=At(t.buffer,t.stride/4,{originalIndices:o,originalIndicesLength:r}),c=pt(s.indices,r,s.uniqueCount);return{faces:s.indices,facesLength:s.indices.length,neighbors:c,vertices:ut.createView(s.buffer)}}class Kt{constructor(n,o,r,s){this.faces=n,this.facesLength=o,this.neighbors=r,this.vertices=s}}const St=new tt,Ot=new et,Yt=b().vec3f(l.POSITION0).vec3f(l.POSITION1),jt=b().vec3f(l.POSITION0).vec3f(l.POSITION1).u16(l.COMPONENTINDEX);export{ut as E,Yt as d,$t as f,jt as m,ft as p,It as u};
