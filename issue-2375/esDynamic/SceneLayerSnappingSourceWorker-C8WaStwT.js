import{jv as Rt,bQ as z,dh as $,je as At,aI as S,dk as q,dl as B,jd as tt,aJ as T,h_ as et,j9 as k,O as Et,Q as St,dm as Ft,dg as H}from"./main-C02UbYD7.js";import{v as Nt,h as xt,M as jt}from"./lineSegment-CWL1AOd3.js";import{s as nt,m as it,T as C,l as st,N as V,H as ot,V as _,_ as N,a as rt}from"./sphere-CS6x3lRQ.js";import"./plane-mQj89Y5q.js";import{i as at}from"./Util-CDnNRgJq.js";import{m as Mt}from"./edgeProcessing-BLVqwgr3.js";function ht(i){return i?{ray:it(i.ray),c0:i.c0,c1:i.c1}:{ray:it(),c0:0,c1:Number.MAX_VALUE}}new nt(()=>ht());function v(i,t){for(let e=0;e<Bt;e++){const n=i[e];if(n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]>=t[3])return!1}return!0}var dt,c;(function(i){i[i.LEFT=0]="LEFT",i[i.RIGHT=1]="RIGHT",i[i.BOTTOM=2]="BOTTOM",i[i.TOP=3]="TOP",i[i.NEAR=4]="NEAR",i[i.FAR=5]="FAR"})(dt||(dt={})),function(i){i[i.NEAR_BOTTOM_LEFT=0]="NEAR_BOTTOM_LEFT",i[i.NEAR_BOTTOM_RIGHT=1]="NEAR_BOTTOM_RIGHT",i[i.NEAR_TOP_RIGHT=2]="NEAR_TOP_RIGHT",i[i.NEAR_TOP_LEFT=3]="NEAR_TOP_LEFT",i[i.FAR_BOTTOM_LEFT=4]="FAR_BOTTOM_LEFT",i[i.FAR_BOTTOM_RIGHT=5]="FAR_BOTTOM_RIGHT",i[i.FAR_TOP_RIGHT=6]="FAR_TOP_RIGHT",i[i.FAR_TOP_LEFT=7]="FAR_TOP_LEFT"}(c||(c={})),c.FAR_BOTTOM_RIGHT,c.NEAR_BOTTOM_RIGHT,c.NEAR_BOTTOM_LEFT,c.FAR_BOTTOM_LEFT,c.NEAR_BOTTOM_LEFT,c.NEAR_BOTTOM_RIGHT,c.NEAR_TOP_RIGHT,c.NEAR_TOP_LEFT,c.FAR_BOTTOM_RIGHT,c.FAR_BOTTOM_LEFT,c.FAR_TOP_LEFT,c.FAR_TOP_RIGHT,c.NEAR_BOTTOM_RIGHT,c.FAR_BOTTOM_RIGHT,c.FAR_TOP_RIGHT,c.NEAR_TOP_RIGHT,c.FAR_BOTTOM_LEFT,c.NEAR_BOTTOM_LEFT,c.NEAR_TOP_LEFT,c.FAR_TOP_LEFT,c.FAR_TOP_LEFT,c.NEAR_TOP_LEFT,c.NEAR_TOP_RIGHT,c.FAR_TOP_RIGHT;const Bt=6;new nt(ht);let w=class Y{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(t,e){this.objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new u,this._objectCount=0,e&&(e.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),e.maximumDepth!==void 0&&(this._maximumDepth=e.maximumDepth))}destroy(){this._degenerateObjects.clear(),u.clearPool(),K[0]=null,j.prune(),M.prune()}add(t,e=t.length){this._objectCount+=e,this._grow(t,e);const n=u.acquire();for(let s=0;s<e;s++){const o=t[s];this._isDegenerate(o)?this._degenerateObjects.add(o):(n.init(this._root),this._add(o,n))}u.release(n)}remove(t,e=null){this._objectCount-=t.length;const n=u.acquire();for(const s of t){const o=e??C(this.objectToBoundingSphere(s),Dt);I(o[3])?(n.init(this._root),Pt(s,o,n)):this._degenerateObjects.delete(s)}u.release(n),this._shrink()}update(t,e){if(!I(e[3])&&this._isDegenerate(t))return;const n=wt(t);this.remove(n,e),this.add(n)}forEachAlongRay(t,e,n){const s=st(t,e);x(this._root,o=>{if(!zt(s,o))return!1;const a=o.node;return a.terminals.forAll(h=>{this._intersectsObject(s,h)&&n(h)}),a.residents!==null&&a.residents.forAll(h=>{this._intersectsObject(s,h)&&n(h)}),!0})}forEachAlongRayWithVerticalOffset(t,e,n,s){const o=st(t,e);x(this._root,a=>{if(!It(o,a,s))return!1;const h=a.node;return h.terminals.forAll(r=>{this._intersectsObjectWithOffset(o,r,s)&&n(r)}),h.residents!==null&&h.residents.forAll(r=>{this._intersectsObjectWithOffset(o,r,s)&&n(r)}),!0})}forEach(t){x(this._root,e=>{const n=e.node;return n.terminals.forAll(t),n.residents!==null&&n.residents.forAll(t),!0}),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,n,s=()=>!0,o=1/0){let a=1/0,h=1/0,r=null;const d=J(t,e),f=l=>{if(--o,!s(l))return;const p=this.objectToBoundingSphere(l);if(!v(n,p))return;const R=F(t,e,_(p)),P=R-p[3],m=R+p[3];P<a&&(a=P,h=m,r=l)};return ct(this._root,l=>{if(o<=0||!v(n,l.bounds)||(q(g,d,l.halfSize),B(g,g,_(l.bounds)),F(t,e,g)>h))return!1;const p=l.node;return p.terminals.forAll(R=>f(R)),p.residents!==null&&p.residents.forAll(R=>f(R)),!0},t,e),r}forEachInDepthRange(t,e,n,s,o,a,h){let r=-1/0,d=1/0;const f={setRange:m=>{n===Y.DepthOrder.FRONT_TO_BACK?(r=Math.max(r,m.near),d=Math.min(d,m.far)):(r=Math.max(r,-m.far),d=Math.min(d,-m.near))}};f.setRange(s);const l=F(e,n,t),p=J(e,n),R=J(e,-n),P=m=>{if(!h(m))return;const E=this.objectToBoundingSphere(m),L=_(E),Z=F(e,n,L)-l,bt=Z-E[3],gt=Z+E[3];bt>d||gt<r||!v(a,E)||o(m,f)};ct(this._root,m=>{if(!v(a,m.bounds)||(q(g,p,m.halfSize),B(g,g,_(m.bounds)),F(e,n,g)-l>d)||(q(g,R,m.halfSize),B(g,g,_(m.bounds)),F(e,n,g)-l<r))return!1;const E=m.node;return E.terminals.forAll(L=>P(L)),E.residents!==null&&E.residents.forAll(L=>P(L)),!0},e,n)}forEachNode(t){x(this._root,e=>t(e.node,e.bounds,e.halfSize,e.depth))}forEachNeighbor(t,e){const n=V(e),s=_(e),o=r=>{const d=this.objectToBoundingSphere(r),f=V(d),l=n+f;return!(tt(_(d),s)-l*l<=0)||t(r)};let a=!0;const h=r=>{a&&(a=o(r))};x(this._root,r=>{const d=V(r.bounds),f=n+d;if(tt(_(r.bounds),s)-f*f>0)return!1;const l=r.node;return l.terminals.forAll(h),a&&l.residents!==null&&l.residents.forAll(h),a}),a&&this.forEachDegenerateObject(h)}_intersectsObject(t,e){const n=this.objectToBoundingSphere(e);return!(n[3]>0)||ot(n,t)}_intersectsObjectWithOffset(t,e,n){const s=this.objectToBoundingSphere(e);return!(s[3]>0)||ot(n.applyToBoundingSphere(s),t)}_add(t,e){e.advanceTo(this.objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let n=0;n<e.length;n++){const s=u.acquire().init(t);this._add(e.at(n),s),u.release(s)}}_grow(t,e){if(e!==0&&(lt(t,e,n=>this.objectToBoundingSphere(n),A),I(A[3])&&!this._fitsInsideTree(A)))if(ut(this._root.node))C(A,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const n=this._rootBoundsForRootAsSubNode(A);this._placingRootViolatesMaxDepth(n)?this._rebuildTree(A,n):this._growRootAsSubNode(n),u.release(n)}}_rebuildTree(t,e){$(_(Q),_(e.bounds)),Q[3]=e.halfSize,lt([t,Q],2,s=>s,U);const n=u.acquire().init(this._root);this._root.initFrom(null,U,U[3]),this._root.increaseHalfSize(1.25),x(n,s=>(this.add(s.node.terminals.data,s.node.terminals.length),s.node.residents!==null&&this.add(s.node.residents.data,s.node.residents.length),!0)),u.release(n)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return x(this._root,s=>(n=Math.max(n,s.depth),n+e<=this._maximumDepth)),n+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t[3],n=t;let s=-1/0;const o=this._root.bounds,a=this._root.halfSize;for(let r=0;r<3;r++){const d=o[r]-a-(n[r]-e),f=n[r]+e-(o[r]+a),l=Math.max(0,Math.ceil(d/(2*a))),p=Math.max(0,Math.ceil(f/(2*a)))+1,R=2**Math.ceil(Math.log(l+p)*Math.LOG2E);s=Math.max(s,R),G[r].min=l,G[r].max=p}for(let r=0;r<3;r++){let d=G[r].min,f=G[r].max;const l=(s-(d+f))/2;d+=Math.ceil(l),f+=Math.floor(l);const p=o[r]-a-d*a*2;W[r]=p+(f+d)*a}const h=s*a;return W[3]=h*mt,u.acquire().initFrom(null,W,h,0)}_growRootAsSubNode(t){const e=this._root.node;$(_(A),_(this._root.bounds)),A[3]=this._root.halfSize,this._root.init(t),t.advanceTo(A,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(t===-1)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let n=0,s=0;for(;s<e.length&&t==null;)n=s++,t=e[n];for(;s<e.length;)if(e[s++])return-1;return n}_isDegenerate(t){return!I(this.objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const e=this._root.bounds,n=this._root.halfSize;return t[3]<=n&&t[0]>=e[0]-n&&t[0]<=e[0]+n&&t[1]>=e[1]-n&&t[1]<=e[1]+n&&t[2]>=e[2]-n&&t[2]<=e[2]+n}toJSON(){const{maximumDepth:t,maximumObjectsPerNode:e,_objectCount:n}=this,s=this._nodeToJSON(this._root.node);return{maximumDepth:t,maximumObjectsPerNode:e,objectCount:n,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:s}}}_nodeToJSON(t){const e=t.children.map(o=>o?this._nodeToJSON(o):null),n=t.residents?.map(o=>this.objectToBoundingSphere(o)),s=t.terminals?.map(o=>this.objectToBoundingSphere(o));return{children:e,residents:n,terminals:s}}static fromJSON(t){const e=new Y(n=>n,{maximumDepth:t.maximumDepth,maximumObjectsPerNode:t.maximumObjectsPerNode});return e._objectCount=t.objectCount,e._root.initFrom(t.root.node,t.root.bounds,t.root.halfSize,t.root.depth),e}};class u{constructor(){this.bounds=N(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,e,n,s=this.depth){return this.node=t??u.createEmptyNode(),e&&C(e,this.bounds),this.halfSize=n,this.depth=s,this}increaseHalfSize(t){this.halfSize*=t,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*mt}advance(t){let e=this.node.children[t];e||(e=u.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const n=_t[t];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(t,e,n=!1){for(;;){if(this.isTerminalFor(t))return e&&e(this,-1),!0;if(this.isLeaf()){if(!n)return e&&e(this,-1),!1;this.node.residents=null}const s=this._childIndex(t);e&&e(this,s),this.advance(s)}}isLeaf(){return this.node.residents!=null}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const e=this.bounds;return(e[0]<t[0]?1:0)+(e[1]<t[1]?2:0)+(e[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new z({shrink:!0}),residents:new z({shrink:!0})}}static acquire(){return u._pool.acquire()}static release(t){u._pool.release(t)}static clearPool(){u._pool.prune()}}function x(i,t){let e=u.acquire().init(i);const n=[e];for(;n.length!==0;){if(e=n.pop(),t(e)&&!e.isLeaf())for(let s=0;s<e.node.children.length;s++)e.node.children[s]&&n.push(u.acquire().init(e).advance(s));u.release(e)}}function ct(i,t,e,n=w.DepthOrder.FRONT_TO_BACK){let s=u.acquire().init(i);const o=[s];for(vt(e,n,Tt);o.length!==0;){if(s=o.pop(),t(s)&&!s.isLeaf())for(let a=7;a>=0;--a){const h=Tt[a];s.node.children[h]&&o.push(u.acquire().init(s).advance(h))}u.release(s)}}function Pt(i,t,e){j.clear();const n=e.advanceTo(t,(s,o)=>{j.push(s.node),j.push(o)})?e.node.terminals:e.node.residents;if(n.removeUnordered(i),n.length===0)for(let s=j.length-2;s>=0&&Lt(j.data[s],j.data[s+1]);s-=2);}function Lt(i,t){return t>=0&&(i.children[t]=null),!!ut(i)&&(i.residents===null&&(i.residents=new z({shrink:!0})),!0)}function zt(i,t){return D(_(t.bounds),2*-t.halfSize,O),D(_(t.bounds),2*t.halfSize,b),at(i.origin,i.direction,O,b)}function It(i,t,e){return D(_(t.bounds),2*-t.halfSize,O),D(_(t.bounds),2*t.halfSize,b),e.applyToMinMax(O,b),at(i.origin,i.direction,O,b)}function ut(i){if(i.terminals.length!==0)return!1;if(i.residents!==null)return i.residents.length===0;for(let t=0;t<i.children.length;t++)if(i.children[t])return!1;return!0}function Ht(i,t){i[0]=Math.min(i[0],t[0]-t[3]),i[1]=Math.min(i[1],t[1]-t[3]),i[2]=Math.min(i[2],t[2]-t[3])}function Ct(i,t){i[0]=Math.max(i[0],t[0]+t[3]),i[1]=Math.max(i[1],t[1]+t[3]),i[2]=Math.max(i[2],t[2]+t[3])}function D(i,t,e){e[0]=i[0]+t,e[1]=i[1]+t,e[2]=i[2]+t}function lt(i,t,e,n){if(t===1){const s=e(i[0]);C(s,n)}else{O[0]=1/0,O[1]=1/0,O[2]=1/0,b[0]=-1/0,b[1]=-1/0,b[2]=-1/0;for(let s=0;s<t;s++){const o=e(i[s]);I(o[3])&&(Ht(O,o),Ct(b,o))}At(_(n),O,b,.5),n[3]=Math.max(b[0]-O[0],b[1]-O[1],b[2]-O[2])/2}}function vt(i,t,e){if(!M.length)for(let n=0;n<8;++n)M.push({index:0,distance:0});for(let n=0;n<8;++n){const s=_t[n];M.data[n].index=n,M.data[n].distance=F(i,t,s)}M.sort((n,s)=>n.distance-s.distance);for(let n=0;n<8;++n)e[n]=M.data[n].index}function J(i,t){let e,n=1/0;for(let s=0;s<8;++s){const o=F(i,t,ft[s]);o<n&&(n=o,e=ft[s])}return e}function F(i,t,e){return t*(i[0]*e[0]+i[1]*e[1]+i[2]*e[2])}function I(i){return!isNaN(i)&&i!==-1/0&&i!==1/0&&i>0}u._pool=new Rt(u),function(i){var t;(t=i.DepthOrder||(i.DepthOrder={}))[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(w||(w={}));const _t=[T(-1,-1,-1),T(1,-1,-1),T(-1,1,-1),T(1,1,-1),T(-1,-1,1),T(1,-1,1),T(-1,1,1),T(1,1,1)],ft=[T(-1,-1,-1),T(-1,-1,1),T(-1,1,-1),T(-1,1,1),T(1,-1,-1),T(1,-1,1),T(1,1,-1),T(1,1,1)],mt=Math.sqrt(3),K=[null];function wt(i){return K[0]=i,K}const W=N(),g=S(),O=S(),b=S(),j=new z,Dt=N(),A=N(),Q=N(),U=N(),G=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],M=new z,Tt=[0,0,0,0,0,0,0,0],pt=w,Gt=1e3;function yt(i,t,e){const n=N(),s=_(n);return et(s,s,i,.5),et(s,s,t,.5),n[3]=k(s,i),B(s,s,e),n}let X=class{constructor(){this._idToComponent=new Map,this._components=new pt(i=>i.bounds),this._edges=new pt(i=>i.bounds),this._tmpLineSegment=Nt(),this._tmpP1=S(),this._tmpP2=S(),this._tmpP3=S(),this.remoteClient=null}async fetchCandidates(i,t){await Promise.resolve(),Ft(t),await this._ensureEdgeLocations(i,t);const e=[];return this._edges.forEachNeighbor(n=>(this._addCandidates(i,n,e),e.length<Gt),i.bounds),{result:{candidates:e}}}async _ensureEdgeLocations(i,t){const e=[];if(this._components.forEachNeighbor(o=>{if(o.info==null){const{id:a,uid:h}=o;e.push({id:a,uid:h})}return!0},i.bounds),!e.length)return;const n={components:e},s=await this.remoteClient.invoke("fetchAllEdgeLocations",n,t??{});for(const o of s.components)this._setFetchEdgeLocations(o)}async add(i){const t=new y(i.id,i.bounds);return this._idToComponent.set(t.id,t),this._components.add([t]),{result:{}}}async remove(i){const t=this._idToComponent.get(i.id);if(t){const e=[];this._edges.forEachNeighbor(n=>(n.component===t&&e.push(n),!0),t.bounds),this._edges.remove(e),this._components.remove([t]),this._idToComponent.delete(t.id)}return{result:{}}}_setFetchEdgeLocations(i){const t=this._idToComponent.get(i.id);if(t==null||i.uid!==t.uid)return;const e=Mt.createView(i.locations),n=new Array(e.count),s=S(),o=S();for(let r=0;r<e.count;r++){e.position0.getVec(r,s),e.position1.getVec(r,o);const d=yt(s,o,i.origin),f=new kt(t,r,d);n[r]=f}this._edges.add(n);const{objectIds:a,origin:h}=i;t.info={locations:e,objectIds:a,origin:h}}_addCandidates(i,t,e){const{info:n}=t.component,{origin:s,objectIds:o}=n,a=n.locations,h=a.position0.getVec(t.index,this._tmpP1),r=a.position1.getVec(t.index,this._tmpP2);B(h,h,s),B(r,r,s);const d=o[a.componentIndex.get(t.index)];this._addEdgeCandidate(i,d,h,r,e),Ot(i,d,h,e),Ot(i,d,r,e)}_addEdgeCandidate(i,t,e,n,s){if(!i.returnEdge)return;const o=_(i.bounds),a=xt(e,n,this._tmpLineSegment),h=jt(a,o,this._tmpP3);rt(i.bounds,h)&&s.push({type:"edge",objectId:t,target:H(h),distance:k(o,h),start:H(e),end:H(n)})}};X=Et([St("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],X);const qt=X;function Ot(i,t,e,n){if(!i.returnVertex||!rt(i.bounds,e))return;const s=_(i.bounds);n.push({type:"vertex",objectId:t,target:H(e),distance:k(s,e)})}class y{constructor(t,e){this.id=t,this.bounds=e,this.info=null,this.uid=++y.uid}}y.uid=0;class kt{constructor(t,e,n){this.component=t,this.index=e,this.bounds=n}}export{qt as default};
