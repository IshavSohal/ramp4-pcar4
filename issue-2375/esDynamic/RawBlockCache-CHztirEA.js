import{a6 as E}from"./main-C02UbYD7.js";import{J as L,C as q,r as F}from"./rasterProjectionHelper-CaAVYIwT.js";class G{constructor(n=15e3,t=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=n,this._interval=Math.min(n,t)}decreaseRefCount(n,t){const e=n+"/"+t,l=this._cachedBlocks;if(l.has(e)){const r=l.get(e);return r.refCount--,r.refCount<=0&&(l.delete(e),r.controller&&r.controller.abort()),r.refCount}return 0}getBlock(n,t){const e=n+"/"+t,l=this._cachedBlocks;if(l.has(e)){const r=l.get(e);return r.ts=Date.now(),r.refCount++,l.delete(e),l.set(e,r),r.block}return null}putBlock(n,t,e,l){const r=this._cachedBlocks,s=n+"/"+t;if(r.has(s)){const c=r.get(s);c.ts=Date.now(),c.refCount++}else r.set(s,{block:e,ts:Date.now(),refCount:1,controller:l});this._trim(),this._updateTimer()}deleteBlock(n,t){const e=this._cachedBlocks,l=n+"/"+t;e.has(l)&&e.delete(l)}updateMaxSize(n){this._size=n,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(this._timer!=null)return;const n=this._cachedBlocks;this._timer=setInterval(()=>{const t=Array.from(n),e=Date.now();for(let l=0;l<t.length&&t[l][1].ts<=e-this._duration;l++)n.delete(t[l][0]);n.size===0&&this._clearTimer()},this._interval)}_trim(){const n=this._cachedBlocks;if(this._size===-1||this._size>=n.size)return;const t=Array.from(n);for(let e=0;e<t.length-this._size;e++)n.delete(t[e][0])}_clearTimer(){this._timer!=null&&(clearInterval(this._timer),this._timer=null)}}const u=new Map,h=new G;function J(o,n){return n==null?o:`${o}?sliceId=${n}`}function O(o,n){const t={extent:null,rasterInfo:n,cache:new Map},e=u.get(o);return e?(e.push(t),e.length-1):(u.set(o,[t]),0)}function P(o,n){const t=u.get(o);t&&(t[n]=null,t.some(e=>e!=null)||u.delete(o))}function Q(o,n,t){const e=u.get(o);if(!e)return n==null?h.decreaseRefCount(o,t):0;if(n==null||e[n]==null)return h.decreaseRefCount(o,t);const l=e[n]?.cache,r=l?.get(t);if(l&&r){if(r.refCount--,r.refCount===0){l.delete(t);for(let s=0;s<e.length;s++)e[s]?.cache.delete(t);r.controller&&r.controller.abort()}return r.refCount}return 0}function U(o,n,t){const e=u.get(o);if(!e)return n==null?h.getBlock(o,t):null;if(n==null||e[n]==null){for(let r=0;r<e.length;r++){const s=e[r]?.cache.get(t);if(s)return s.refCount++,s.block}return h.getBlock(o,t)}const l=e[n]?.cache.get(t);if(l)return l.refCount++,l.block;for(let r=0;r<e.length;r++){if(r===n||!e[r])continue;const s=e[r]?.cache,c=s?.get(t);if(s&&c)return c.refCount++,s.set(t,c),c.block}return null}function V(o,n,t,e,l=null){const r=u.get(o);if(!r)return void(n==null&&h.putBlock(o,t,e,l));if(n==null||r[n]==null)return void h.putBlock(o,t,e,l);const s={refCount:1,block:e,isResolved:!1,isRejected:!1,controller:l};e.then(()=>s.isResolved=!0).catch(()=>s.isRejected=!0),r[n]?.cache.set(t,s)}function X(o,n,t){const e=u.get(o);e?n!=null&&e[n]!=null?e[n]?.cache.delete(t):h.deleteBlock(o,t):n==null&&h.deleteBlock(o,t)}function Y(o,n){const t=u.get(o);return t?t[n]??null:null}function Z(o,n,t,e,l,r,s=null){const c=Y(o,n);if(!c)return;const f=c.extent,{cache:k,rasterInfo:y}=c;if(f&&f.xmin===t.xmin&&f.xmax===t.xmax&&f.ymin===t.ymin&&f.ymax===t.ymax)return;e=e??0;const M=t.clone().normalize(),{spatialReference:R,transform:v}=y,z=new Set;for(let d=0;d<M.length;d++){const a=M[d];if(a.xmax-a.xmin<=e||a.ymax-a.ymin<=e)continue;let i=L(a,R,s);v!=null&&(i=v.inverseTransform(i));const T=new E({x:e,y:e,spatialReference:a.spatialReference});if(l==null&&!(l=q(T,R,a,s)))return;const{pyramidLevel:p,pyramidResolution:x,excessiveReading:$}=F(l,y,r||"closest");if($)return;const{storageInfo:m}=y,{origin:b}=m,g={x:Math.max(0,Math.floor((i.xmin-b.x)/x.x)),y:Math.max(0,Math.floor((b.y-i.ymax)/x.y))},D=Math.ceil((i.xmax-i.xmin)/x.x-.1),j=Math.ceil((i.ymax-i.ymin)/x.y-.1),w=p>0?m.pyramidBlockWidth:m.blockWidth,I=p>0?m.pyramidBlockHeight:m.blockHeight,_=1,S=Math.max(0,Math.floor(g.x/w)-_),A=Math.max(0,Math.floor(g.y/I)-_),H=Math.floor((g.x+D-1)/w)+_,W=Math.floor((g.y+j-1)/I)+_;for(let B=A;B<=W;B++)for(let C=S;C<=H;C++)z.add(`${p}/${B}/${C}`)}k.forEach((d,a)=>{if(!z.has(a)){const i=k.get(a);(i==null||i.isResolved||i.isRejected)&&k.delete(a)}}),c.extent={xmin:t.xmin,ymin:t.ymin,xmax:t.xmax,ymax:t.ymax}}export{P as a,Z as g,X as h,J as i,U as m,Q as s,O as u,V as x};
