import{cm as w,O as q,a4 as D,b_ as J,bx as T,aP as U,b2 as B,I as E,d8 as H,bG as F,gu as W,bF as z,N as K,n as Q,s as V}from"./main-C1jnFJXF.js";import{f as Y}from"./utils-BMNpR1Gg.js";import{r as Z,o as ee}from"./utils-DFsgVUQE.js";const A={102100:{maxX:20037508342788905e-9,minX:-20037508342788905e-9,plus180Line:new w({paths:[[[20037508342788905e-9,-20037508342788905e-9],[20037508342788905e-9,20037508342788905e-9]]],spatialReference:q.WebMercator}),minus180Line:new w({paths:[[[-20037508342788905e-9,-20037508342788905e-9],[-20037508342788905e-9,20037508342788905e-9]]],spatialReference:q.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new w({paths:[[[180,-180],[180,180]]],spatialReference:q.WGS84}),minus180Line:new w({paths:[[[-180,-180],[-180,180]]],spatialReference:q.WGS84})}};function R(e,n){return Math.ceil((e-n)/(2*n))}function C(e,n){const i=v(e);for(const s of i)for(const t of s)t[0]+=n;return e}function v(e){return D(e)?e.rings:e.paths}async function te(e,n,i,s){const t=Y(e),a=n[0].spatialReference,r={...s,responseType:"json",query:{...t.query,f:"json",sr:J(a),target:JSON.stringify({geometryType:T(n[0]),geometries:n}),cutter:JSON.stringify(i)}},o=await U(t.path+"/cut",r),{cutIndexes:c,geometries:f=[]}=o.data;return{cutIndexes:c,geometries:f.map(u=>{const m=B(u);return m.spatialReference=a,m})}}async function ne(e,n,i){const s=typeof e=="string"?E(e):e,t=n[0].spatialReference,a=T(n[0]),r={...i,query:{...s.query,f:"json",sr:J(t),geometries:JSON.stringify(Z(n))}},{data:o}=await U(s.path+"/simplify",r);return ee(o.geometries,a,t)}const _=()=>Q.getLogger("esri.geometry.support.normalizeUtils");function se(e){return e.type==="polygon"}function oe(e){return e[0].type==="polygon"}function re(e){return e[0].type==="polyline"}function O(e){const n=[];let i=0,s=0;for(let t=0;t<e.length;t++){const a=e[t];let r=null;for(let o=0;o<a.length;o++)r=a[o],n.push(r),o===0?(i=r[0],s=i):(i=Math.min(i,r[0]),s=Math.max(s,r[0]));r&&n.push([(i+s)/2,0])}return n}function ie(e,n){if(!(e instanceof w||e instanceof z)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw _().error(t),new V(t)}const i=v(e),s=[];for(const t of i){const a=[];s.push(a),a.push([t[0][0],t[0][1]]);for(let r=0;r<t.length-1;r++){const o=t[r][0],c=t[r][1],f=t[r+1][0],u=t[r+1][1],m=Math.sqrt((f-o)*(f-o)+(u-c)*(u-c)),p=(u-c)/m,d=(f-o)/m,g=m/n;if(g>1){for(let L=1;L<=g-1;L++){const P=L*n,l=d*P+o,h=p*P+c;a.push([l,h])}const $=(m+Math.floor(g-1)*n)/2,N=d*$+o,I=p*$+c;a.push([N,I])}a.push([f,u])}}return se(e)?new z({rings:s,spatialReference:e.spatialReference}):new w({paths:s,spatialReference:e.spatialReference})}function k(e,n,i){if(n){const s=ie(e,1e6);e=K(s,!0)}return i&&(e=C(e,i)),e}function G(e,n,i){if(Array.isArray(e)){const s=e[0];if(s>n){const t=R(s,n);e[0]=s+t*(-2*n)}else if(s<i){const t=R(s,i);e[0]=s+t*(-2*i)}}else{const s=e.x;if(s>n){const t=R(s,n);e=e.clone().offset(t*(-2*n),0)}else if(s<i){const t=R(s,i);e=e.clone().offset(t*(-2*i),0)}}return e}function ae(e,n){let i=-1;for(let s=0;s<n.cutIndexes.length;s++){const t=n.cutIndexes[s],a=n.geometries[s],r=v(a);for(let o=0;o<r.length;o++){const c=r[o];c.some(f=>{if(f[0]<180)return!0;{let u=0;for(let p=0;p<c.length;p++){const d=c[p][0];u=d>u?d:u}u=Number(u.toFixed(9));const m=-360*R(u,180);for(let p=0;p<c.length;p++){const d=a.getPoint(o,p);a.setPoint(o,p,d.clone().offset(m,0))}return!0}})}if(t===i){if(oe(e))for(const o of v(a))e[t]=e[t].addRing(o);else if(re(e))for(const o of v(a))e[t]=e[t].addPath(o)}else i=t,e[t]=a}return e}async function ce(e,n,i){if(!Array.isArray(e))return ce([e],n);n&&typeof n!="string"&&_().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const s=typeof n=="string"?n:n?.url??H.geometryServiceUrl;let t,a,r,o,c,f,u,m,p=0;const d=[],g=[];for(const l of e)if(l!=null)if(t||(t=l.spatialReference,a=F(t),r=t.isWebMercator,f=r?102100:4326,o=A[f].maxX,c=A[f].minX,u=A[f].plus180Line,m=A[f].minus180Line),a)if(l.type==="mesh")g.push(l);else if(l.type==="point")g.push(G(l.clone(),o,c));else if(l.type==="multipoint"){const h=l.clone();h.points=h.points.map(x=>G(x,o,c)),g.push(h)}else if(l.type==="extent"){const h=l.clone()._normalize(!1,!1,a);g.push(h.rings?new z(h):h)}else if(l.extent){const h=l.extent,x=R(h.xmin,c)*(2*o);let M=x===0?l.clone():C(l.clone(),x);h.offset(x,0);let{xmin:b,xmax:y}=h;b=Number(b.toFixed(9)),y=Number(y.toFixed(9)),h.intersects(u)&&y!==o?(p=y>p?y:p,M=k(M,r),d.push(M),g.push("cut")):h.intersects(m)&&b!==c?(p=y*(2*o)>p?y*(2*o):p,M=k(M,r,360),d.push(M),g.push("cut")):g.push(M)}else g.push(l.clone());else g.push(l);else g.push(l);let $=R(p,o),N=-90;const I=$,L=new w;for(;$>0;){const l=360*$-180;L.addPath([[l,N],[l,-1*N]]),N*=-1,$--}if(d.length>0&&I>0){const l=ae(d,await te(s,d,L,i)),h=[],x=[];for(let y=0;y<g.length;y++){const S=g[y];if(S!=="cut")x.push(S);else{const X=l.shift(),j=e[y];j!=null&&j.type==="polygon"&&j.rings&&j.rings.length>1&&X.rings.length>=j.rings.length?(h.push(X),x.push("simplify")):x.push(r?W(X):X)}}if(!h.length)return x;const M=await ne(s,h,i),b=[];for(let y=0;y<x.length;y++){const S=x[y];S!=="simplify"?b.push(S):b.push(r?W(M.shift()):M.shift())}return b}const P=[];for(let l=0;l<g.length;l++){const h=g[l];if(h!=="cut")P.push(h);else{const x=d.shift();P.push(r===!0?W(x):x)}}return P}function pe(e){if(!e)return null;const n=e.extent;if(!n)return null;const i=e.spatialReference&&F(e.spatialReference);if(!i)return n;const[s,t]=i.valid,a=2*t,{width:r}=n;let o,{xmin:c,xmax:f}=n;if([c,f]=[f,c],e.type==="extent"||r===0||r<=t||r>a||c<s||f>t)return n;switch(e.type){case"polygon":if(!(e.rings.length>1))return n;o=O(e.rings);break;case"polyline":if(!(e.paths.length>1))return n;o=O(e.paths);break;case"multipoint":o=e.points}const u=n.clone();for(let m=0;m<o.length;m++){let p=o[m][0];p<0?(p+=t,f=Math.max(p,f)):(p-=t,c=Math.min(p,c))}return u.xmin=c,u.xmax=f,u.width<r?(u.xmin-=t,u.xmax-=t,u):n}function he(e,n,i){const s=F(i);if(s==null)return e;const[t,a]=s.valid,r=2*a;let o=0,c=0;n>a?o=Math.ceil(Math.abs(n-a)/r):n<t&&(o=-Math.ceil(Math.abs(n-t)/r)),e>a?c=Math.ceil(Math.abs(e-a)/r):e<t&&(c=-Math.ceil(Math.abs(e-t)/r));let f=e+(o-c)*r;const u=f-n;return u>a?f-=r:u<t&&(f+=r),f}function ge(e,n){const i=F(n);if(i){const[s,t]=i.valid,a=t-s;if(e<s)for(;e<s;)e+=a;if(e>t)for(;e>t;)e-=a}return e}export{ge as L,ie as M,he as P,ce as R,R as i,A as r,C as s,pe as v};
