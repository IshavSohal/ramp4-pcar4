import{s as m,n as A}from"./main-BfV_Ya13.js";import{U as u,C as o}from"./enums-DBi1-Mm2.js";import{s as $}from"./getDataTypeBytes-HSdrWtlL.js";import{t as P}from"./VertexElementDescriptor-BAy1DPb3.js";import{t as Y,n as L}from"./vec2f32-CVhmN3Me.js";const y=()=>A.getLogger("esri.views.2d.engine.webgl.Utils");function B(r){switch(r){case u.UNSIGNED_BYTE:return 1;case u.UNSIGNED_SHORT_4_4_4_4:return 2;case u.FLOAT:return 4;default:return void y().error(new m("webgl-utils",`Unable to handle type ${r}`))}}function R(r){switch(r){case u.UNSIGNED_BYTE:return Uint8Array;case u.UNSIGNED_SHORT_4_4_4_4:return Uint16Array;case u.FLOAT:return Float32Array;default:return void y().error(new m("webgl-utils",`Unable to handle type ${r}`))}}function b(r){const t=new Map;for(const e in r){const s=r[e];let i=0;t.set(e,s.map(n=>{const a=new P(n.name,n.count,n.type,i,0,n.normalized||!1);return i+=n.count*$(n.type),a})),t.get(e).forEach(n=>n.stride=i)}return t}const O=r=>{const t=new Map;for(const e in r)for(const s of r[e])t.set(s.name,s.location);return t},z=r=>{const t={};return r.forEach((e,s)=>t[s]=e?.length?e[0].stride:0),t},d=new Map,C=(r,t)=>{if(!d.has(r)){const e=b(t),s={strides:z(e),bufferLayouts:e,attributes:O(t)};d.set(r,s)}return d.get(r)},k=r=>r.includes("data:image/svg+xml");function H(r){const t=[];for(let e=0;e<r.length;e++)t.push(r.charCodeAt(e));return t}function v(r){if(r==null)return"";const{type:t}=r;switch(t){case"CIMMarkerPlacementAlongLineRandomSize":return`${t}-${r.seed}-${r.randomization}`;case"CIMMarkerPlacementAlongLineVariableSize":return`${t}-${r.maxRandomOffset}-${r.numberOfSizes}-${r.seed}-${r.variationMethod}`;case"CIMMarkerPlacementAtExtremities":return`${t}-${r.extremityPlacement}-${r.offsetAlongLine}`;case"CIMMarkerPlacementAtRatioPositions":return`${t}-${r.beginPosition}-${r.endPosition}-${r.flipFirst}-${JSON.stringify(r.positionArray)}`;case"CIMMarkerPlacementAtMeasuredUnits":return`${t}-${r.interval}-${r.skipMarkerRate}-${r.placeAtExtremities}`;case"CIMMarkerPlacementInsidePolygon":return`${t}-${r.stepX}-${r.stepY}-${r.randomness}-${r.gridType}-${r.seed}-${r.shiftOddRows}`;case"CIMMarkerPlacementOnLine":return`${t}-${r.relativeTo}-${r.startPointOffset}`;case"CIMMarkerPlacementOnVertices":return`${t}-${r.placeOnControlPoints}-${r.placeOnEndPoints}-${r.placeOnRegularVertices}`;case"CIMMarkerPlacementPolygonCenter":return`${t}-${r.method}`;default:return`${t}`}}let l=class g{constructor(t,e,s,i,n,a,c){this.instanceId=t,this.textureKey=e,this.indexStart=s,this.indexCount=i,this.vertexStart=n,this.vertexCount=a,this.overlaps=c}updateBaseOffsets(t){this.vertexStart+=t.vertexFrom,this.indexStart+=t.indexFrom}clone(){return new g(this.instanceId,this.textureKey,this.indexStart,this.indexCount,this.vertexStart,this.vertexCount,this.overlaps)}static write(t,e,s,i,n,a,c,h){t.push(e),t.push(s),t.push(i),t.push(n),t.push(a),t.push(c),t.push(h)}serialize(t){return t.push(this.instanceId),t.push(this.textureKey),t.push(this.indexStart),t.push(this.indexCount),t.push(this.vertexStart),t.push(this.vertexCount),t.push(this.overlaps),t}static deserialize(t){const e=t.readInt32(),s=t.readInt32(),i=t.readInt32(),n=t.readInt32(),a=t.readInt32(),c=t.readInt32(),h=t.readInt32();return new g(e,s,i,n,a,c,h)}};l.byteSizeHint=7*Uint32Array.BYTES_PER_ELEMENT;function I(r,t){if(t!==null){r.push(t.length);for(const e of t)e.serialize(r);return r}r.push(0)}function T(r,t,e){const s=r.readInt32(),i=new Array(s);for(let n=0;n<i.length;n++)i[n]=t.deserialize(r,e);return i}let S=class F{constructor(t,e){this.id=t,this.sortKey=e,this.records=[]}serialize(t){return t.push(this.id),t.writeF32(this.sortKey),I(t,this.records),t}static deserialize(t){const e=t.readInt32(),s=t.readF32(),i=new F(e,s);return i.records=T(t,l)??[],i}};S.byteSizeHint=2*Uint32Array.BYTES_PER_ELEMENT+l.byteSizeHint;class f{constructor(t,e,s,i){this.transformedX=0,this.transformedY=0,this.center=Y(t,e),this.centerT=L(),this.halfWidth=s/2,this.halfHeight=i/2,this.width=s,this.height=i}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(t){this.center[0]=t}set y(t){this.center[1]=t}clone(){return new f(this.x,this.y,this.width,this.height)}serialize(t){return t.writeF32(this.center[0]),t.writeF32(this.center[1]),t.push(this.width),t.push(this.height),t}findCollisionDelta(t,e=4){const s=Math.abs(t.centerT[0]-this.centerT[0]),i=Math.abs(t.centerT[1]-this.centerT[1]),n=(t.halfWidth+this.halfWidth+e)/s,a=(t.halfHeight+this.halfHeight+e)/i,c=Math.min(n,a);return Math.log2(c)}extend(t){const e=Math.min(this.xmin,t.xmin),s=Math.min(this.ymin,t.ymin),i=Math.max(this.xmax,t.xmax)-e,n=Math.max(this.ymax,t.ymax)-s,a=e+i/2,c=s+n/2;this.width=i,this.height=n,this.halfWidth=i/2,this.halfHeight=n/2,this.x=a,this.y=c}static deserialize(t){const e=t.readF32(),s=t.readF32(),i=t.readInt32(),n=t.readInt32();return new f(e,s,i,n)}}class p{constructor(t,e,s,i,n,a,c,h,E=[]){this.entityTexel=t,this.anchorX=e,this.anchorY=s,this.directionX=i,this.directionY=n,this.maxScale=a,this.minScale=c,this.referenceBounds=h,this.bounds=E}serialize(t){t.push(this.entityTexel),t.writeF32(this.anchorX),t.writeF32(this.anchorY),t.writeF32(this.directionX),t.writeF32(this.directionY),t.writeF32(this.maxScale),t.writeF32(this.minScale),this.referenceBounds===null?(t.writeF32(0),t.writeF32(0),t.writeF32(0)):(t.writeF32(this.referenceBounds.size),t.writeF32(this.referenceBounds.offsetX),t.writeF32(this.referenceBounds.offsetY)),I(t,this.bounds)}static deserialize(t){const e=t.readInt32(),s=t.readF32(),i=t.readF32(),n=t.readF32(),a=t.readF32(),c=t.readF32(),h=t.readF32(),E=t.readF32(),w=t.readF32(),U=t.readF32(),N=T(t,f)??[];return new p(e,s,i,n,a,c,h,{size:E,offsetX:w,offsetY:U},N)}}const M=new Float32Array(1),D=new Uint32Array(M.buffer);function X(r){return M[0]=r,D[0]}function G(r,t){return 65535&r|t<<16}function _(r){const t=X(r),e=t>>>31;let s=t>>>23&255,i=8388607&t;return s-=127,s>15?e<<15|31744:s<-25?0:(s<-14&&(i+=8388608,i/=2**(-14-s),s=-15),s+=15,i/=8192,i=W(i,1023),e<<15|s<<10|i)}function W(r,t){const e=Math.floor(r),s=r-e;return e<t&&(s>.5||s===.5&&e%2==1)?e+1:e}function x(r){let t=r>>>15,e=r>>10&31,s=1023&r;return t=t?-1:1,e-=15,s/=1024,e>-15?s+=1:e=-14,t*2**e*s}function K(r,t,e,s){const i=e.packPrecisionFactor??1;switch(e.type){case o.BYTE:if(e.count===1)r.setInt8(s+e.offset,t*i);else for(let n=0;n<e.count;n++){const a=n*Int8Array.BYTES_PER_ELEMENT;r.setInt8(s+e.offset+a,t[n]*i)}break;case o.UNSIGNED_BYTE:if(e.count===1)r.setUint8(s+e.offset,t*i);else for(let n=0;n<e.count;n++){const a=n*Uint8Array.BYTES_PER_ELEMENT;r.setUint8(s+e.offset+a,t[n]*i)}break;case o.SHORT:if(e.count===1)r.setInt16(s+e.offset,t*i,!0);else for(let n=0;n<e.count;n++){const a=n*Int16Array.BYTES_PER_ELEMENT;r.setInt16(s+e.offset+a,t[n]*i,!0)}break;case o.UNSIGNED_SHORT:if(e.count===1)r.setUint16(s+e.offset,t*i,!0);else for(let n=0;n<e.count;n++){const a=n*Uint16Array.BYTES_PER_ELEMENT;r.setUint16(s+e.offset+a,t[n]*i,!0)}break;case o.INT:if(e.count===1)r.setInt32(s+e.offset,t*i,!0);else for(let n=0;n<e.count;n++){const a=n*Int32Array.BYTES_PER_ELEMENT;r.setInt32(s+e.offset+a,t[n]*i,!0)}break;case o.UNSIGNED_INT:if(e.count===1)r.setUint32(s+e.offset,t*i,!0);else for(let n=0;n<e.count;n++){const a=n*Uint32Array.BYTES_PER_ELEMENT;r.setUint32(s+e.offset+a,t[n]*i,!0)}break;case o.FLOAT:if(e.count===1)r.setFloat32(s+e.offset,t*i,!0);else for(let n=0;n<e.count;n++){const a=n*Float32Array.BYTES_PER_ELEMENT;r.setFloat32(s+e.offset+a,t[n]*i,!0)}break;case o.HALF_FLOAT:if(e.count===1)r.setUint16(s+e.offset,_(t*i),!0);else for(let n=0;n<e.count;n++){const a=n*Uint16Array.BYTES_PER_ELEMENT;r.setUint16(s+e.offset+a,_(t[n]*i),!0)}}}function V(r,t,e){switch(t.type){case o.BYTE:{if(t.count===1)return r.getInt8(e+t.offset);const s=[];for(let i=0;i<t.count;i++){const n=i*Int8Array.BYTES_PER_ELEMENT;s.push(r.getInt8(e+t.offset+n))}return s}case o.UNSIGNED_BYTE:{if(t.count===1)return r.getUint8(e+t.offset);const s=[];for(let i=0;i<t.count;i++){const n=i*Uint8Array.BYTES_PER_ELEMENT;s.push(r.getUint8(e+t.offset+n))}return s}case o.SHORT:{if(t.count===1)return r.getInt16(e+t.offset,!0);const s=[];for(let i=0;i<t.count;i++){const n=i*Int16Array.BYTES_PER_ELEMENT;s.push(r.getInt16(e+t.offset+n,!0))}return s}case o.UNSIGNED_SHORT:{if(t.count===1)return r.getUint16(e+t.offset,!0);const s=[];for(let i=0;i<t.count;i++){const n=i*Uint16Array.BYTES_PER_ELEMENT;s.push(r.getUint16(e+t.offset+n,!0))}return s}case o.INT:{if(t.count===1)return r.getInt32(e+t.offset,!0);const s=[];for(let i=0;i<t.count;i++){const n=i*Int32Array.BYTES_PER_ELEMENT;s.push(r.getInt32(e+t.offset+n,!0))}return s}case o.UNSIGNED_INT:{if(t.count===1)return r.getUint32(e+t.offset,!0);const s=[];for(let i=0;i<t.count;i++){const n=i*Uint32Array.BYTES_PER_ELEMENT;s.push(r.getUint32(e+t.offset+n,!0))}return s}case o.FLOAT:{if(t.count===1)return r.getFloat32(e+t.offset,!0);const s=[];for(let i=0;i<t.count;i++){const n=i*Float32Array.BYTES_PER_ELEMENT;s.push(r.getFloat32(e+t.offset+n,!0))}return s}case o.HALF_FLOAT:{if(t.count===1)return x(r.getUint16(e+t.offset,!0));const s=[];for(let i=0;i<t.count;i++){const n=i*Uint16Array.BYTES_PER_ELEMENT;s.push(x(r.getUint16(e+t.offset+n,!0)))}return s}}}export{C as $,f as a,K as b,G as c,V as d,H as e,k as f,R as i,T as n,B as o,v as p,p as r,S as s,l as t};
