import{i as Y,e as q}from"./memoryEstimations-wlVxEmgG.js";function M(n,e){return n?e?4:3:e?3:2}function S(n,e,t,r){if(!e?.lengths.length)return null;n.lengths.length&&(n.lengths.length=0),n.coords.length&&(n.coords.length=0);const s=n.coords,o=[],i=t?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],{lengths:h,coords:c}=e,d=M(t,r);let m=0;for(const l of h){const u=j(i,c,m,l,t,r);u&&o.push(u),m+=l*d}if(o.sort((l,u)=>{let f=l[2]-u[2];return f===0&&t&&(f=l[4]-u[4]),f}),o.length){let l=6*o[0][2];s[0]=o[0][0]/l,s[1]=o[0][1]/l,t&&(l=6*o[0][4],s[2]=l!==0?o[0][3]/l:0),(s[0]<i[0]||s[0]>i[1]||s[1]<i[2]||s[1]>i[3]||t&&(s[2]<i[4]||s[2]>i[5]))&&(s.length=0)}if(!s.length){const l=e.lengths[0]?x(c,0,h[0],t,r):null;if(!l)return null;s[0]=l[0],s[1]=l[1],t&&l.length>2&&(s[2]=l[2])}return n}function j(n,e,t,r,s,o){const i=M(s,o);let h=t,c=t+i,d=0,m=0,l=0,u=0,f=0;for(let b=0,G=r-1;b<G;b++,h+=i,c+=i){const a=e[h],g=e[h+1],N=e[h+2],I=e[c],y=e[c+1],P=e[c+2];let p=a*y-I*g;u+=p,d+=(a+I)*p,m+=(g+y)*p,s&&(p=a*P-I*N,l+=(N+P)*p,f+=p),a<n[0]&&(n[0]=a),a>n[1]&&(n[1]=a),g<n[2]&&(n[2]=g),g>n[3]&&(n[3]=g),s&&(N<n[4]&&(n[4]=N),N>n[5]&&(n[5]=N))}if(u>0&&(u*=-1),f>0&&(f*=-1),!u)return null;const T=[d,m,.5*u];return s&&(T[3]=l,T[4]=.5*f),T}function x(n,e,t,r,s){const o=M(r,s);let i=e,h=e+o,c=0,d=0,m=0,l=0;for(let u=0,f=t-1;u<f;u++,i+=o,h+=o){const T=n[i],b=n[i+1],G=n[i+2],a=n[h],g=n[h+1],N=n[h+2],I=r?J(T,b,G,a,g,N):A(T,b,a,g);if(I)if(c+=I,r){const y=Z(T,b,G,a,g,N);d+=I*y[0],m+=I*y[1],l+=I*y[2]}else{const y=L(T,b,a,g);d+=I*y[0],m+=I*y[1]}}return c>0?r?[d/c,m/c,l/c]:[d/c,m/c]:t>0?r?[n[e],n[e+1],n[e+2]]:[n[e],n[e+1]]:null}function A(n,e,t,r){const s=t-n,o=r-e;return Math.sqrt(s*s+o*o)}function J(n,e,t,r,s,o){const i=r-n,h=s-e,c=o-t;return Math.sqrt(i*i+h*h+c*c)}function L(n,e,t,r){return[n+.5*(t-n),e+.5*(r-e)]}function Z(n,e,t,r,s,o){return[n+.5*(r-n),e+.5*(s-e),t+.5*(o-t)]}const F=2;let V=class E{constructor(e=[],t=[]){this.lengths=e??[],this.coords=t??[]}static fromJSON(e){return new E(e.lengths,e.coords)}static fromRect(e){const[t,r,s,o]=e,i=s-t,h=o-r;return new E([5],[t,r,i,0,0,h,-i,0,0,-h])}get isPoint(){return this.lengths.length===0&&this.coords.length>=2}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce((e,t)=>e+t)}get usedMemory(){return 64+Y(this.lengths,this.coords)}area(){let e=0,t=0;if(!this.lengths.length)return 0;for(let r=0;r<this.lengths.length;r++){const s=this.lengths[r];if(s<3)continue;let o=this.coords[F*t],i=this.coords[F*t+1];for(let h=1;h<s;h+=1){const c=this.coords[F*(h+t)],d=this.coords[F*(h+t)+1];e+=-.5*(c-o)*(d+i),o=c,i=d}t+=s}return e}forEachVertex(e){let t=0;this.lengths.length||e(this.coords[0],this.coords[1]);for(let r=0;r<this.lengths.length;r++){const s=this.lengths[r];for(let o=0;o<s;o++)e(this.coords[F*(o+t)],this.coords[F*(o+t)+1]);t+=s}}deltaDecode(){const e=this.clone(),{coords:t,lengths:r}=e;let s=0;for(const o of r){for(let i=1;i<o;i++)t[2*(s+i)]+=t[2*(s+i)-2],t[2*(s+i)+1]+=t[2*(s+i)-1];s+=o}return e}clone(e){if(this.lengths.length===0)return new E([],[this.coords[0],this.coords[1]]);const t=(this.lengths.length===0?1:this.lengths.reduce((s,o)=>s+o))*F,r=this.coords.slice(0,t);return e?(e.set(r),new E(this.lengths,e)):new E(Array.from(this.lengths),Array.from(r))}};class w{constructor(e=null,t={},r,s,o=0){this.geometry=e,this.attributes=t,this.centroid=r,this.objectId=s,this.displayId=o}static fromJSON(e){const t=e.geometry?V.fromJSON(e.geometry):null,r=e.centroid?V.fromJSON(e.centroid):null,s=e.objectId;return new w(t,e.attributes,r,s)}weakClone(){const e=new w(this.geometry,this.attributes,this.centroid,this.objectId);return e.displayId=this.displayId,e}clone(){const e=this.geometry?.clone(),t=new w(e,{...this.attributes},this.centroid?.clone(),this.objectId);return t.displayId=this.displayId,t}ensureCentroid(e){return this.centroid??=S(new V,this.geometry,e.hasZ,e.hasM),this.centroid}get usedMemory(){return 128+q(this.attributes)+(this.geometry?.usedMemory??0)}}function R(n){return!!n.geometry?.coords?.length}class O{constructor(){this.objectIdFieldName=null,this.globalIdFieldName=null,this.geohashFieldName=null,this.geometryProperties=null,this.geometryType=null,this.spatialReference=null,this.hasZ=!1,this.hasM=!1,this.features=[],this.fields=[],this.transform=null,this.exceededTransferLimit=!1,this.uniqueIdField=null,this.queryGeometryType=null,this.queryGeometry=null}weakClone(){const e=new O;return e.objectIdFieldName=this.objectIdFieldName,e.globalIdFieldName=this.globalIdFieldName,e.geohashFieldName=this.geohashFieldName,e.geometryProperties=this.geometryProperties,e.geometryType=this.geometryType,e.spatialReference=this.spatialReference,e.hasZ=this.hasZ,e.hasM=this.hasM,e.features=this.features,e.fields=this.fields,e.transform=this.transform,e.exceededTransferLimit=this.exceededTransferLimit,e.uniqueIdField=this.uniqueIdField,e.queryGeometry=this.queryGeometry,e.queryGeometryType=this.queryGeometryType,e}}export{O as a,V as e,S as n,R as o,w as s};
