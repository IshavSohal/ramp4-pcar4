import{ck as L,M as j,a2 as _,bY as O,bv as T,aN as D,b0 as $,I as B,d5 as H,bE as A,gr as z,bD as F,K as Q,n as V,s as Z}from"./main-BfV_Ya13.js";import{f as tt}from"./utils-6Q51K23J.js";import{r as et,o as st}from"./utils-1YaY58v_.js";const X={102100:{maxX:20037508342788905e-9,minX:-20037508342788905e-9,plus180Line:new L({paths:[[[20037508342788905e-9,-20037508342788905e-9],[20037508342788905e-9,20037508342788905e-9]]],spatialReference:j.WebMercator}),minus180Line:new L({paths:[[[-20037508342788905e-9,-20037508342788905e-9],[-20037508342788905e-9,20037508342788905e-9]]],spatialReference:j.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new L({paths:[[[180,-180],[180,180]]],spatialReference:j.WGS84}),minus180Line:new L({paths:[[[-180,-180],[-180,180]]],spatialReference:j.WGS84})}};function b(t,s){return Math.ceil((t-s)/(2*s))}function J(t,s){const i=q(t);for(const n of i)for(const e of n)e[0]+=s;return t}function q(t){return _(t)?t.rings:t.paths}async function nt(t,s,i,n){const e=tt(t),a=s[0].spatialReference,o={...n,responseType:"json",query:{...e.query,f:"json",sr:O(a),target:JSON.stringify({geometryType:T(s[0]),geometries:s}),cutter:JSON.stringify(i)}},r=await D(e.path+"/cut",o),{cutIndexes:c,geometries:f=[]}=r.data;return{cutIndexes:c,geometries:f.map(u=>{const m=$(u);return m.spatialReference=a,m})}}async function rt(t,s,i){const n=typeof t=="string"?B(t):t,e=s[0].spatialReference,a=T(s[0]),o={...i,query:{...n.query,f:"json",sr:O(e),geometries:JSON.stringify(et(s))}},{data:r}=await D(n.path+"/simplify",o);return st(r.geometries,a,e)}const G=()=>V.getLogger("esri.geometry.support.normalizeUtils");function ot(t){return t.type==="polygon"}function it(t){return t[0].type==="polygon"}function at(t){return t[0].type==="polyline"}function U(t){const s=[];let i=0,n=0;for(let e=0;e<t.length;e++){const a=t[e];let o=null;for(let r=0;r<a.length;r++)o=a[r],s.push(o),r===0?(i=o[0],n=i):(i=Math.min(i,o[0]),n=Math.max(n,o[0]));o&&s.push([(i+n)/2,0])}return s}function C(t,s){if(!(t instanceof L||t instanceof F)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw G().error(e),new Z(e)}const i=q(t),n=[];for(const e of i){const a=[];n.push(a),a.push([e[0][0],e[0][1]]);for(let o=0;o<e.length-1;o++){const r=e[o][0],c=e[o][1],f=e[o+1][0],u=e[o+1][1],m=Math.sqrt((f-r)*(f-r)+(u-c)*(u-c)),p=(u-c)/m,d=(f-r)/m,g=m/s;if(g>1){for(let N=1;N<=g-1;N++){const v=N*s,l=d*v+r,h=p*v+c;a.push([l,h])}const w=(m+Math.floor(g-1)*s)/2,P=d*w+r,k=p*w+c;a.push([P,k])}a.push([f,u])}}return ot(t)?new F({rings:n,spatialReference:t.spatialReference}):new L({paths:n,spatialReference:t.spatialReference})}function E(t,s,i){if(s){const n=C(t,1e6);t=Q(n,!0)}return i&&(t=J(t,i)),t}function K(t,s,i){if(Array.isArray(t)){const n=t[0];if(n>s){const e=b(n,s);t[0]=n+e*(-2*s)}else if(n<i){const e=b(n,i);t[0]=n+e*(-2*i)}}else{const n=t.x;if(n>s){const e=b(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<i){const e=b(n,i);t=t.clone().offset(e*(-2*i),0)}}return t}function ct(t,s){let i=-1;for(let n=0;n<s.cutIndexes.length;n++){const e=s.cutIndexes[n],a=s.geometries[n],o=q(a);for(let r=0;r<o.length;r++){const c=o[r];c.some(f=>{if(f[0]<180)return!0;{let u=0;for(let p=0;p<c.length;p++){const d=c[p][0];u=d>u?d:u}u=Number(u.toFixed(9));const m=-360*b(u,180);for(let p=0;p<c.length;p++){const d=a.getPoint(r,p);a.setPoint(r,p,d.clone().offset(m,0))}return!0}})}if(e===i){if(it(t))for(const r of q(a))t[e]=t[e].addRing(r);else if(at(t))for(const r of q(a))t[e]=t[e].addPath(r)}else i=e,t[e]=a}return t}async function Y(t,s,i){if(!Array.isArray(t))return Y([t],s);s&&typeof s!="string"&&G().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:s?.url??H.geometryServiceUrl;let e,a,o,r,c,f,u,m,p=0;const d=[],g=[];for(const l of t)if(l!=null)if(e||(e=l.spatialReference,a=A(e),o=e.isWebMercator,f=o?102100:4326,r=X[f].maxX,c=X[f].minX,u=X[f].plus180Line,m=X[f].minus180Line),a)if(l.type==="mesh")g.push(l);else if(l.type==="point")g.push(K(l.clone(),r,c));else if(l.type==="multipoint"){const h=l.clone();h.points=h.points.map(x=>K(x,r,c)),g.push(h)}else if(l.type==="extent"){const h=l.clone()._normalize(!1,!1,a);g.push(h.rings?new F(h):h)}else if(l.extent){const h=l.extent,x=b(h.xmin,c)*(2*r);let M=x===0?l.clone():J(l.clone(),x);h.offset(x,0);let{xmin:R,xmax:y}=h;R=Number(R.toFixed(9)),y=Number(y.toFixed(9)),h.intersects(u)&&y!==r?(p=y>p?y:p,M=E(M,o),d.push(M),g.push("cut")):h.intersects(m)&&R!==c?(p=y*(2*r)>p?y*(2*r):p,M=E(M,o,360),d.push(M),g.push("cut")):g.push(M)}else g.push(l.clone());else g.push(l);else g.push(l);let w=b(p,r),P=-90;const k=w,N=new L;for(;w>0;){const l=360*w-180;N.addPath([[l,P],[l,-1*P]]),P*=-1,w--}if(d.length>0&&k>0){const l=ct(d,await nt(n,d,N,i)),h=[],x=[];for(let y=0;y<g.length;y++){const S=g[y];if(S!=="cut")x.push(S);else{const I=l.shift(),W=t[y];W!=null&&W.type==="polygon"&&W.rings&&W.rings.length>1&&I.rings.length>=W.rings.length?(h.push(I),x.push("simplify")):x.push(o?z(I):I)}}if(!h.length)return x;const M=await rt(n,h,i),R=[];for(let y=0;y<x.length;y++){const S=x[y];S!=="simplify"?R.push(S):R.push(o?z(M.shift()):M.shift())}return R}const v=[];for(let l=0;l<g.length;l++){const h=g[l];if(h!=="cut")v.push(h);else{const x=d.shift();v.push(o===!0?z(x):x)}}return v}function lt(t){if(!t)return null;const s=t.extent;if(!s)return null;const i=t.spatialReference&&A(t.spatialReference);if(!i)return s;const[n,e]=i.valid,a=2*e,{width:o}=s;let r,{xmin:c,xmax:f}=s;if([c,f]=[f,c],t.type==="extent"||o===0||o<=e||o>a||c<n||f>e)return s;switch(t.type){case"polygon":if(!(t.rings.length>1))return s;r=U(t.rings);break;case"polyline":if(!(t.paths.length>1))return s;r=U(t.paths);break;case"multipoint":r=t.points}const u=s.clone();for(let m=0;m<r.length;m++){let p=r[m][0];p<0?(p+=e,f=Math.max(p,f)):(p-=e,c=Math.min(p,c))}return u.xmin=c,u.xmax=f,u.width<o?(u.xmin-=e,u.xmax-=e,u):s}function ft(t,s,i){const n=A(i);if(n==null)return t;const[e,a]=n.valid,o=2*a;let r=0,c=0;s>a?r=Math.ceil(Math.abs(s-a)/o):s<e&&(r=-Math.ceil(Math.abs(s-e)/o)),t>a?c=Math.ceil(Math.abs(t-a)/o):t<e&&(c=-Math.ceil(Math.abs(t-e)/o));let f=t+(r-c)*o;const u=f-s;return u>a?f-=o:u<e&&(f+=o),f}function ut(t,s){const i=A(s);if(i){const[n,e]=i.valid,a=e-n;if(t<n)for(;t<n;)t+=a;if(t>e)for(;t>e;)t-=a}return t}export{ut as L,C as M,ft as P,Y as R,b as i,X as r,J as s,lt as v};
