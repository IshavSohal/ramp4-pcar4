{"version":3,"file":"index-CJVOJNws.js","sources":["../../src/fixtures/export-northarrow/index.ts"],"sourcesContent":["import { fabric } from 'fabric';\r\nimport merge from 'deepmerge';\r\n\r\nimport { FixtureInstance } from '@/api/internal';\r\nimport type { ExportAPI, ExportSubFixture } from '@/fixtures/export/api/export';\r\nimport type { ExportConfig } from '../export/store';\r\nimport { Point, SpatialReference } from '@/geo/api';\r\n\r\nclass ExportNorthArrowFixture extends FixtureInstance implements ExportSubFixture {\r\n    get config(): any {\r\n        const fixtureConfig: ExportConfig | undefined = this.$iApi.fixture.get<ExportAPI>('export').config;\r\n        return fixtureConfig?.mapElements;\r\n    }\r\n\r\n    async make(options?: any): Promise<fabric.Object> {\r\n        /**\r\n         * This is a placeholder function that always returns 0 (for the case of mercator projection). Actual implementation is further down.\r\n         * @param normalizedPositionX The X position of the north arrow, normalized to a value between 0 and 100 with 0 being leftmost and 100 being rightmost.\r\n         * @returns 0\r\n         * @memberof ExportNorthArrowFixture\r\n         **/\r\n        let calculateNorthArrowAngle = (normalizedPositionX: number) => {\r\n            return 0;\r\n        };\r\n        let normalizedPositionX = 0;\r\n\r\n        const arrowSVG =\r\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 61.06 96.62\"><g transform=\"translate(-1.438 30.744)\"><g fill=\"none\" stroke=\"#000\"><path d=\"m61 35c0 16.02-12.984 29-29 29-16.02 0-29-12.984-29-29 0-16.02 12.984-29 29-29 16.02 0 29 12.984 29 29z\" stroke-width=\"3\"/><path d=\"m55 35c0 12.979-10.521 23.5-23.5 23.5-12.979 0-23.5-10.521-23.5-23.5 0-12.979 10.521-23.5 23.5-23.5 12.979 0 23.5 10.521 23.5 23.5z\" transform=\"matrix(1.01148 0 0 .99988-.089.004)\" stroke-width=\".497\"/><path d=\"m32 35v-32\" stroke-width=\".25\"/></g><path d=\"m32-9.453l28.938 73.826-29-29-29 29z\" fill=\"#fff\" stroke=\"#fff\" stroke-width=\"3\"/><path d=\"m32-9.453l29 73.45-29-29-29 29z\" fill=\"none\" stroke=\"#000\" stroke-linecap=\"square\"/><text x=\"22.71\" y=\"-10.854\" font-family=\"OPEN SANS\" word-spacing=\"0\" line-height=\"125%\" letter-spacing=\"0\" font-size=\"40\"><tspan x=\"22.71\" y=\"-10.854\" font-family=\"Adobe Heiti Std R\" font-size=\"26\">N</tspan></text></g><g transform=\"translate(0-3.829)\" fill=\"none\" stroke=\"#000\" stroke-width=\".25\"><path d=\"m4 92.82l6.74-3.891\"/><path d=\"m4.603 90.7l10.397-6\"/><path d=\"m3 95.17l4-2.309\"/><path d=\"m5.442 88.45l13.856-8\"/><path d=\"m12 72.26l18.686-10.812\"/><path d=\"m14.593 65.45l16.09-9.291\"/><path d=\"m15.343 63.24l15.343-8.858\"/><path d=\"m16.877 60.58l13.809-7.972\"/><path d=\"m17.511 58.45l13.174-7.606\"/><path d=\"m18.412 56.15l12.274-7.087\"/><path d=\"m19 54.04l11.427-6.597\"/><path d=\"m20 51.757l10.822-6.311\"/><path d=\"m20.826 49.45l9.86-5.693\"/><path d=\"m21.48 47.3l9.206-5.315\"/><path d=\"m23 44.647l7.686-4.437\"/><path d=\"m23.744 42.45l6.928-4\"/><path d=\"m24.549 40.21l6.137-3.543\"/><path d=\"m25 38.18l5.686-3.283\"/><path d=\"m26.663 35.446l4.02-2.323\"/><path d=\"m27.617 33.12l3.069-1.772\"/><path d=\"m28 31.13l2.686-1.551\"/><path d=\"m29.15 28.694l1.534-.886\"/><path d=\"m13 69.909l17.686-10.211\"/><path d=\"m9.206 79.19l21.48-12.402\"/><path d=\"m8.36 81.45l22.326-12.89\"/><path d=\"m7.671 83.62l19.946-11.516\"/><path d=\"m6.137 86.27l17.02-9.827\"/><path d=\"m10 76.956l20.686-11.943\"/><path d=\"m11.279 74.45l19.407-11.205\"/><path d=\"m14 67.56l16.686-9.634\"/><path d=\"m30.562 65.744v-43.566\" transform=\"translate(0 3.829)\"/></g></svg>';\r\n\r\n        // below angle calculation code duplicated from north arrow fixture\r\n        const innerShell = this.$vApp.$el.querySelector('.inner-shell')!;\r\n        const sr: SpatialReference = this.$iApi.geo.map.getSR();\r\n        let angle = 0;\r\n\r\n        if (sr.isWebMercator()) {\r\n            // the north arrow will always point up in mercator projection\r\n            angle = 0;\r\n        } else {\r\n            const arrowWidth = 50;\r\n            // north value (set longitude to be half of Canada extent (141° W, 52° W))\r\n            const pole: Point = new Point('pole', { x: -96, y: 90 });\r\n            const projPole = (await this.$iApi.geo.proj.projectGeometry(sr, pole)) as Point;\r\n            const poleScreenPos = this.$iApi.geo.map.mapPointToScreenPoint(projPole);\r\n            // get angle from bottom centre\r\n            const bcScreenPos = {\r\n                screenX: innerShell.clientWidth / 2,\r\n                screenY: innerShell.clientHeight\r\n            };\r\n            // calculate angle\r\n            angle =\r\n                (Math.atan(\r\n                    (poleScreenPos.screenX - bcScreenPos.screenX) / (bcScreenPos.screenY - poleScreenPos.screenY)\r\n                ) *\r\n                    180) /\r\n                Math.PI;\r\n\r\n            const arrowLeft =\r\n                innerShell.clientWidth / 2 +\r\n                innerShell.clientHeight * Math.tan((angle * Math.PI) / 180) -\r\n                arrowWidth / 2;\r\n\r\n            // Normalize the position to a scale of 0 to 100\r\n            const positionX = Math.round((arrowLeft / innerShell.clientWidth) * 100);\r\n\r\n            // Ensure positionX is clamped between 0 and 100\r\n            normalizedPositionX = Math.min(Math.max(positionX, 0), 100);\r\n\r\n            /**\r\n             * Calculate the angle of the north arrow based on its provided position on the screen.\r\n             * @param normalizedPositionX The X position of the north arrow, normalized to a value between 0 and 100 with 0 being leftmost and 100 being rightmost.\r\n             * @returns The angle the north arrow needs to be rotated by in order to be pointing due north from its position.\r\n             * @memberof ExportNorthArrowFixture\r\n             **/\r\n            calculateNorthArrowAngle = (normalizedPositionX: number) => {\r\n                if (normalizedPositionX < 0 || normalizedPositionX > 100) {\r\n                    throw new Error('Normalized position must be between 0 and 100');\r\n                }\r\n                const screenPosX = (innerShell.clientWidth * normalizedPositionX) / 100;\r\n                // We use half of arrowWidth as the X position because we assume the north arrow is always at the top of the screen and\r\n                // its center point is half the height.\r\n                return (\r\n                    Math.atan((poleScreenPos.screenX - screenPosX) / (arrowWidth / 2 - poleScreenPos.screenY)) *\r\n                    (180 / Math.PI)\r\n                );\r\n            };\r\n        }\r\n\r\n        const fbImgConfig: any = {\r\n            top: 0,\r\n            left: 0,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            angle: angle\r\n        };\r\n\r\n        // load the svg string into a fabric group\r\n        const group: Array<fabric.Object> = [];\r\n        interface CustomGroup extends fabric.Group {\r\n            positionX: number;\r\n            getAngleFromPosition: (normalizedPositionX: number) => number;\r\n        }\r\n\r\n        let loadedObjects = new fabric.Group();\r\n        fabric.loadSVGFromString(\r\n            arrowSVG,\r\n            () => {\r\n                // the fabric group is loaded here\r\n                loadedObjects = new fabric.Group(group);\r\n                // Add custom properties to the group including the north arrow X position and the angle calculation function\r\n                (loadedObjects as CustomGroup).positionX = normalizedPositionX;\r\n                (loadedObjects as CustomGroup).getAngleFromPosition = calculateNorthArrowAngle;\r\n            },\r\n            (_: any, object: any) => {\r\n                // the group is constructed here\r\n                group.push(object);\r\n            }\r\n        );\r\n\r\n        // apply the options\r\n        loadedObjects.set(merge(fbImgConfig, options || {}));\r\n        return Promise.resolve(loadedObjects);\r\n    }\r\n}\r\n\r\nexport default ExportNorthArrowFixture;\r\n"],"names":["ExportNorthArrowFixture","FixtureInstance","options","calculateNorthArrowAngle","normalizedPositionX","arrowSVG","innerShell","sr","angle","pole","Point","projPole","poleScreenPos","bcScreenPos","arrowLeft","positionX","screenPosX","fbImgConfig","group","loadedObjects","fabric","_","object","merge"],"mappings":";;AAQA,MAAMA,UAAgCC,EAA4C;AAAA,EAC9E,IAAI,SAAc;AAEd,WADgD,KAAK,MAAM,QAAQ,IAAe,QAAQ,EAAE,QACtE;AAAA,EAAA;AAAA,EAG1B,MAAM,KAAKC,GAAuC;AAO1C,QAAAC,IAA2B,CAACC,MACrB,GAEPA,IAAsB;AAE1B,UAAMC,IACF,+lEAGEC,IAAa,KAAK,MAAM,IAAI,cAAc,cAAc,GACxDC,IAAuB,KAAK,MAAM,IAAI,IAAI,MAAM;AACtD,QAAIC,IAAQ;AAER,QAAAD,EAAG;AAEK,MAAAC,IAAA;AAAA,SACL;AAGG,YAAAC,IAAc,IAAIC,EAAM,QAAQ,EAAE,GAAG,KAAK,GAAG,IAAI,GACjDC,IAAY,MAAM,KAAK,MAAM,IAAI,KAAK,gBAAgBJ,GAAIE,CAAI,GAC9DG,IAAgB,KAAK,MAAM,IAAI,IAAI,sBAAsBD,CAAQ,GAEjEE,IAAc;AAAA,QAChB,SAASP,EAAW,cAAc;AAAA,QAClC,SAASA,EAAW;AAAA,MACxB;AAEA,MAAAE,IACK,KAAK;AAAA,SACDI,EAAc,UAAUC,EAAY,YAAYA,EAAY,UAAUD,EAAc;AAAA,MAAA,IAErF,MACJ,KAAK;AAET,YAAME,IACFR,EAAW,cAAc,IACzBA,EAAW,eAAe,KAAK,IAAKE,IAAQ,KAAK,KAAM,GAAG,IAC1D,KAAa,GAGXO,IAAY,KAAK,MAAOD,IAAYR,EAAW,cAAe,GAAG;AAGvE,MAAAF,IAAsB,KAAK,IAAI,KAAK,IAAIW,GAAW,CAAC,GAAG,GAAG,GAQ1DZ,IAA2B,CAACC,MAAgC;AACpDA,YAAAA,IAAsB,KAAKA,IAAsB;AAC3C,gBAAA,IAAI,MAAM,+CAA+C;AAE7D,cAAAY,IAAcV,EAAW,cAAcF,IAAuB;AAIhE,eAAA,KAAK,MAAMQ,EAAc,UAAUI,MAAe,KAAa,IAAIJ,EAAc,QAAQ,KACxF,MAAM,KAAK;AAAA,MAEpB;AAAA,IAAA;AAGJ,UAAMK,IAAmB;AAAA,MACrB,KAAK;AAAA,MACL,MAAM;AAAA,MACN,SAAS;AAAA,MACT,SAAS;AAAA,MACT,OAAAT;AAAA,IACJ,GAGMU,IAA8B,CAAC;AAMjC,QAAAC,IAAgB,IAAIC,EAAA,OAAO,MAAM;AAC9BA,WAAAA,EAAAA,OAAA;AAAA,MACHf;AAAA,MACA,MAAM;AAEc,QAAAc,IAAA,IAAIC,EAAAA,OAAO,MAAMF,CAAK,GAErCC,EAA8B,YAAYf,GAC1Ce,EAA8B,uBAAuBhB;AAAA,MAC1D;AAAA,MACA,CAACkB,GAAQC,MAAgB;AAErB,QAAAJ,EAAM,KAAKI,CAAM;AAAA,MAAA;AAAA,IAEzB,GAGAH,EAAc,IAAII,EAAMN,GAAaf,KAAW,CAAE,CAAA,CAAC,GAC5C,QAAQ,QAAQiB,CAAa;AAAA,EAAA;AAE5C;"}