{"version":3,"file":"index-DYbkZZtZ.js","sources":["../../src/fixtures/hilight/api/hilight-mode/base-hilight-mode.ts","../../src/fixtures/hilight/api/hilight-mode/lift-hilight-mode.ts","../../src/fixtures/hilight/api/hilight-mode/fog-hilight-mode.ts","../../src/fixtures/hilight/api/hilight-mode/glow-hilight-mode.ts","../../src/fixtures/hilight/api/hilight.ts","../../src/fixtures/hilight/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\nimport { APIScope, CommonGraphicLayer, InstanceAPI, LayerInstance } from '@/api';\r\nimport { HilightMode, HILIGHT_LAYER_NAME } from '../hilight-defs';\r\nimport type { Graphic } from '@/geo/api';\r\n\r\n/**\r\n * Base mode for hilighter modes. On its own, this mode will not hilight anything.\r\n */\r\nexport class BaseHilightMode extends APIScope {\r\n    config: any = {};\r\n    mode: HilightMode = HilightMode.NONE;\r\n\r\n    constructor(config: any, iApi: InstanceAPI) {\r\n        super(iApi);\r\n        this.config = config;\r\n        this.mode = config.mode;\r\n    }\r\n\r\n    /**\r\n     * Adds the given graphics to the hilighter.\r\n     *\r\n     * @param {Graphic | Array<Graphic>} graphics one or more RAMP Graphics to hilight\r\n     * @returns {Promise} resolves when graphics have been added\r\n     */\r\n    async add(graphics: Array<Graphic> | Graphic): Promise<void> {\r\n        this.notImplementedError('addGraphics');\r\n    }\r\n\r\n    /**\r\n     * Removes the given graphics from the hilighter. No parmeter removes all graphics.\r\n     *\r\n     * @param {Graphic | Array<Graphic> | undefined} graphics one or more RAMP Graphics to remove\r\n     * @returns {Promise} resolves when graphics have been added\r\n     */\r\n    async remove(graphics: Array<Graphic> | Graphic | undefined): Promise<void> {\r\n        this.notImplementedError('removeGraphics');\r\n    }\r\n\r\n    /**\r\n     * Reload the provided graphics that are currently highlighted.\r\n     *\r\n     * @param {Graphic | Array<Graphic>} graphics one or more RAMP Graphics to reload\r\n     * @returns {Promise} resolves when graphics have been reloaded\r\n     */\r\n    async reloadHilight(graphics: Array<Graphic> | Graphic): Promise<void> {\r\n        this.notImplementedError('reloadHilight');\r\n    }\r\n\r\n    /**\r\n     * Returns the Hilight layer, if it exists.\r\n     *\r\n     * @returns {Promise<CommonGraphicLayer | undefined>}\r\n     */\r\n    async getHilightLayer(): Promise<CommonGraphicLayer | undefined> {\r\n        const hilightLayer = await this.layerFetcher();\r\n        if (hilightLayer) {\r\n            if (hilightLayer.isLoaded && hilightLayer instanceof CommonGraphicLayer) {\r\n                return hilightLayer;\r\n            } else {\r\n                console.warn('Hilight layer exists but is in bad form.');\r\n                return undefined;\r\n            }\r\n        } else {\r\n            console.warn('Hilight layer could not be fetched.');\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    private notImplementedError(method: string) {\r\n        console.warn(`Hilight mode method ${method} was not implemented by subclass.`);\r\n    }\r\n\r\n    /**\r\n     * Provides a short grace period to avoid scenarios where the layer is still getting created.\r\n     * Not overly long, as the highlight layer is a local graphics layer so no server lag involved.\r\n     *\r\n     * @returns Promise resolving in the LayerInstace, or undefined if we could not locate the layer.\r\n     */\r\n    private layerFetcher(): Promise<LayerInstance | undefined> {\r\n        // code duplication, but lets us avoid a 125ms delay on the initial check. Once layer\r\n        // is loaded that's wasted time.\r\n        const precheckLayer = this.$iApi.geo.layer.getLayer(HILIGHT_LAYER_NAME);\r\n        if (precheckLayer) {\r\n            return Promise.resolve(precheckLayer);\r\n        } else {\r\n            return new Promise(resolve => {\r\n                let timeElapsed = 0;\r\n\r\n                const layerWatcher = setInterval(() => {\r\n                    const layer = this.$iApi.geo.layer.getLayer(HILIGHT_LAYER_NAME);\r\n                    if (layer) {\r\n                        clearInterval(layerWatcher);\r\n                        resolve(layer);\r\n                    } else {\r\n                        // layer was not found, take a nap\r\n                        timeElapsed += 125;\r\n                        if (timeElapsed >= 1125) {\r\n                            // to long, game over\r\n                            clearInterval(layerWatcher);\r\n                            resolve(undefined);\r\n                            return;\r\n                        }\r\n                    }\r\n                }, 125);\r\n            });\r\n        }\r\n    }\r\n}\r\n","import type { Graphic } from '@/geo/api';\r\nimport { BaseHilightMode } from './base-hilight-mode';\r\n\r\n/**\r\n * Hilight mode that places graphics in a top-most layer, essentially \"lifting\" them\r\n * above other map elements.\r\n */\r\nexport class LiftHilightMode extends BaseHilightMode {\r\n    async add(graphics: Array<Graphic> | Graphic) {\r\n        const hilightLayer = await this.getHilightLayer();\r\n        if (!hilightLayer) {\r\n            return;\r\n        }\r\n        await hilightLayer.addGraphic(graphics);\r\n    }\r\n\r\n    async remove(graphics: Array<Graphic> | Graphic | undefined) {\r\n        const hilightLayer = await this.getHilightLayer();\r\n        if (!hilightLayer) {\r\n            return;\r\n        }\r\n        hilightLayer.removeGraphic(graphics);\r\n    }\r\n\r\n    async reloadHilight(graphics: Array<Graphic> | Graphic) {\r\n        await this.remove(graphics);\r\n        await this.add(graphics);\r\n    }\r\n}\r\n","import { GlobalEvents, type InstanceAPI, TileLayer } from '@/api';\r\nimport { type Graphic, LayerType, type RampBasemapConfig } from '@/geo/api';\r\nimport { useConfigStore } from '@/stores/config';\r\nimport { FOG_HILIGHT_LAYER_NAME } from '../hilight-defs';\r\nimport { LiftHilightMode } from './lift-hilight-mode';\r\n\r\n/**\r\n * Hilight mode that places a translucent tile beneath a graphics to make them\r\n * stand out from the rest of the map.\r\n */\r\nexport class FogHilightMode extends LiftHilightMode {\r\n    handlers: Array<string> = [];\r\n    // TODO: make these configurable later\r\n    // See https://github.com/ramp4-pcar4/ramp4-pcar4/issues/1353\r\n    onOpacity: number;\r\n    offOpacity: number;\r\n\r\n    private lastAdd: number = 0;\r\n\r\n    constructor(config: any, iApi: InstanceAPI) {\r\n        super(config, iApi);\r\n        this.onOpacity = config.options?.onOpacity ?? 0.75;\r\n        this.offOpacity = config.options?.offOpacity > 0.02 ? config.options.offOpacity : 0.02;\r\n\r\n        if (this.$iApi.geo.map.created) {\r\n            this.hilightSetup();\r\n        } else {\r\n            this.handlers.push(\r\n                this.$iApi.event.on(GlobalEvents.MAP_CREATED, () => {\r\n                    this.hilightSetup();\r\n                })\r\n            );\r\n        }\r\n\r\n        this.handlers.push(\r\n            this.$iApi.event.on(GlobalEvents.MAP_BASEMAPCHANGE, () => {\r\n                this.getHilightLayer().then(hilightLayer => {\r\n                    if (hilightLayer && hilightLayer.graphics.length === 0) {\r\n                        // if the highlighter is currently \"off\", update the basemap\r\n                        // if the highlighter is \"on\", then details (or whatever is using the hilighter) will handle this event\r\n                        this.updateFogLayer();\r\n                    }\r\n                });\r\n            })\r\n        );\r\n    }\r\n\r\n    private async hilightSetup() {\r\n        const mapConfig: RampBasemapConfig = useConfigStore(this.$vApp.$pinia).activeBasemapConfig as RampBasemapConfig;\r\n        try {\r\n            const fogLayer = this.$iApi.geo.layer.createLayer({\r\n                id: FOG_HILIGHT_LAYER_NAME,\r\n                layerType: LayerType.TILE,\r\n                cosmetic: true,\r\n                // TODO: what if there's more than 1 URL provided?\r\n                // See https://github.com/ramp4-pcar4/ramp4-pcar4/discussions/1352\r\n                url: mapConfig.layers[0].url\r\n            });\r\n\r\n            await this.$iApi.geo.map.addLayer(fogLayer);\r\n            // off\r\n            fogLayer.opacity = this.offOpacity;\r\n\r\n            await this.reorderFogLayer();\r\n        } catch {\r\n            console.error('Something went wrong while setting up the hilighter.');\r\n        }\r\n    }\r\n\r\n    private async updateFogLayer() {\r\n        this.$iApi.geo.map.removeLayer(FOG_HILIGHT_LAYER_NAME);\r\n        await this.hilightSetup();\r\n    }\r\n\r\n    private async reorderFogLayer() {\r\n        const fogLayer = this.getFogLayer();\r\n        const hilightLayer = await this.getHilightLayer();\r\n        if (!hilightLayer || !fogLayer) {\r\n            return;\r\n        }\r\n\r\n        const layerOrder = this.$iApi.geo.layer.layerOrderIds();\r\n        const fogIdx = layerOrder.indexOf(fogLayer.id);\r\n        const hilightIdx = layerOrder.indexOf(hilightLayer.id);\r\n\r\n        if (hilightIdx < fogIdx && hilightIdx > -1 && fogIdx > -1) {\r\n            // No +1. Since highlight is below, fog will get pushed down\r\n            // as things shift.\r\n            this.$iApi.geo.map.reorder(hilightLayer, fogIdx, false);\r\n        }\r\n    }\r\n\r\n    async add(graphics: Array<Graphic> | Graphic) {\r\n        this.lastAdd = Date.now();\r\n\r\n        // turn the fog \"on\"\r\n        const fogLayer = this.getFogLayer();\r\n        if (!fogLayer) {\r\n            return;\r\n        }\r\n        fogLayer.opacity = this.onOpacity;\r\n\r\n        // add the given graphics to the layer\r\n        await super.add(graphics);\r\n    }\r\n\r\n    async remove(graphics?: Array<Graphic> | Graphic | undefined) {\r\n        // remove the given graphics from the layer\r\n        await super.remove(graphics);\r\n\r\n        // NOTE: because details calls remove and add each time it does a hilight, there can be a flicker\r\n        // when switching between items on the details panel (because the fog gets turned off then on again each time)\r\n        // See https://github.com/ramp4-pcar4/ramp4-pcar4/issues/1350\r\n\r\n        // turn the fog \"off\"\r\n        const fogLayer = this.getFogLayer();\r\n        if (!fogLayer) {\r\n            return;\r\n        }\r\n\r\n        // When we quickly go from highlighting one item to another, if it's the first time\r\n        // highlighting we can have a delay if RAMP needs to fetch feature attribute data\r\n        // from a map server. This can cause a \"flicker\" on the screen as the fog layer turns\r\n        // off then turns back on again.\r\n        // This timeout will give a small time buffer to give a new highlight a chance\r\n        // to be requested. If we see that one was, we will not turn off and\r\n        // simply wait for next add to finish.\r\n        const lastRemove = Date.now();\r\n        const hilightLayer = await this.getHilightLayer();\r\n        if (!hilightLayer) {\r\n            return;\r\n        }\r\n        setTimeout(() => {\r\n            if (this.lastAdd < lastRemove && !hilightLayer.getGraphicCount()) {\r\n                // nothing was added during the timeout AND there is nothing\r\n                // currently hilighted, so we turn off the fog\r\n                fogLayer.opacity = this.offOpacity;\r\n            }\r\n        }, 300);\r\n    }\r\n\r\n    async reloadHilight(graphics: Array<Graphic> | Graphic) {\r\n        await this.updateFogLayer();\r\n        await super.reloadHilight(graphics);\r\n    }\r\n\r\n    /**\r\n     * Returns the \"fog\" tile layer.\r\n     */\r\n    private getFogLayer(): TileLayer | undefined {\r\n        const hilightLayer = this.$iApi.geo.layer.getLayer(FOG_HILIGHT_LAYER_NAME);\r\n        if (hilightLayer && hilightLayer instanceof TileLayer) {\r\n            return hilightLayer;\r\n        } else {\r\n            console.warn('Hilight fog layer could not be fetched.');\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\n","import { InstanceAPI, GraphicLayer, GlobalEvents } from '@/api';\r\nimport type { Graphic } from '@/geo/api';\r\nimport { HILIGHT_LAYER_NAME } from '../hilight-defs';\r\nimport { LiftHilightMode } from './lift-hilight-mode';\r\n\r\n/**\r\n * Hilight mode that lifts graphics and applies a glow outline to make them\r\n * stand out from the rest of the map.\r\n */\r\nexport class GlowHilightMode extends LiftHilightMode {\r\n    handlers: Array<string> = [];\r\n\r\n    constructor(config: any, iApi: InstanceAPI) {\r\n        super(config, iApi);\r\n\r\n        this.hilightSetup(config);\r\n\r\n        this.handlers.push(\r\n            this.$iApi.event.on(GlobalEvents.MAP_CREATED, () => {\r\n                this.hilightSetup(config);\r\n            })\r\n        );\r\n    }\r\n\r\n    private hilightSetup(config: any) {\r\n        this.$iApi.geo.map.viewPromise.then(() => {\r\n            this.$iApi.geo.map.esriView!.highlightOptions = config.options;\r\n        });\r\n    }\r\n\r\n    async add(graphics: Array<Graphic> | Graphic) {\r\n        // add the given graphics to the layer\r\n        await super.add(graphics);\r\n\r\n        // apply the esri highlight to the graphics\r\n        const hilightLayer = this.$iApi.geo.layer.getLayer(HILIGHT_LAYER_NAME);\r\n        if (hilightLayer && hilightLayer.esriLayer && hilightLayer.isLoaded && hilightLayer instanceof GraphicLayer) {\r\n            const gs = graphics instanceof Array ? graphics : [graphics];\r\n            this.$iApi.geo.map.esriView?.whenLayerView(hilightLayer.esriLayer)?.then(function (layerView) {\r\n                layerView.highlight(gs.map(g => hilightLayer.getEsriGraphic(g.id)!));\r\n            });\r\n        }\r\n    }\r\n\r\n    async remove(graphics?: Array<Graphic> | Graphic | undefined) {\r\n        await super.remove(graphics);\r\n        // removing the graphic will also remove the esri highlight\r\n        // so there's nothing else to do here\r\n        return;\r\n    }\r\n}\r\n","import { CommonGraphicLayer, FixtureInstance } from '@/api/internal';\r\nimport { Graphic, LayerType } from '@/geo/api';\r\nimport { DEFAULT_CONFIG, HILIGHT_LAYER_NAME, HilightMode, type HilightConfig } from './hilight-defs';\r\nimport { BaseHilightMode } from './hilight-mode/base-hilight-mode';\r\nimport { FogHilightMode } from './hilight-mode/fog-hilight-mode';\r\nimport { GlowHilightMode } from './hilight-mode/glow-hilight-mode';\r\nimport { LiftHilightMode } from './hilight-mode/lift-hilight-mode';\r\n\r\n/**\r\n * Exposes methods to manage the hilighting of features on the map\r\n */\r\nexport class HilightAPI extends FixtureInstance {\r\n    hilightMode: BaseHilightMode = new BaseHilightMode({}, this.$iApi);\r\n\r\n    initialized(): void {\r\n        // create the highlight layer once the map is available\r\n        this.initHilightLayer();\r\n    }\r\n\r\n    _parseConfig(hilightConfig?: HilightConfig) {\r\n        if (hilightConfig) {\r\n            switch (hilightConfig.mode) {\r\n                case HilightMode.NONE:\r\n                    this.hilightMode = new BaseHilightMode(hilightConfig, this.$iApi);\r\n                    break;\r\n                case HilightMode.GLOW:\r\n                    this.hilightMode = new GlowHilightMode(hilightConfig, this.$iApi);\r\n                    break;\r\n                case HilightMode.LIFT:\r\n                    this.hilightMode = new LiftHilightMode(hilightConfig, this.$iApi);\r\n                    break;\r\n                case HilightMode.FOG:\r\n                    this.hilightMode = new FogHilightMode(hilightConfig, this.$iApi);\r\n                    break;\r\n                default:\r\n                    // in this case, the hilighter will use NONE (BaseHilightMode)\r\n                    console.error('Could not find hilight mode:', hilightConfig.mode);\r\n                    break;\r\n            }\r\n        } else {\r\n            // defaults to GLOW\r\n            this.hilightMode = new GlowHilightMode(DEFAULT_CONFIG, this.$iApi);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize the Hilight layer.\r\n     *\r\n     * @returns {Promise} resolves when layer is initialized\r\n     */\r\n    async initHilightLayer(): Promise<void> {\r\n        const hilightLayer = this.$iApi.geo.layer.createLayer({\r\n            id: HILIGHT_LAYER_NAME,\r\n            layerType: LayerType.GRAPHIC,\r\n            cosmetic: true,\r\n            url: ''\r\n        });\r\n\r\n        await this.$iApi.geo.map.addLayer(hilightLayer);\r\n    }\r\n\r\n    /**\r\n     * Add the given Graphics to the Hilighter\r\n     *\r\n     * @param {Graphic | Array<Graphic>} graphics Graphics to add\r\n     * @returns {Promise} resolves when graphics have been added\r\n     */\r\n    async addHilight(graphics: Array<Graphic> | Graphic): Promise<void> {\r\n        const gs = graphics instanceof Array ? graphics : [graphics];\r\n        await this.hilightMode.add(gs);\r\n    }\r\n\r\n    /**\r\n     * Remove the given Graphics from the Hilighter. If no graphics are provided,\r\n     * all highlighted items will be removed.\r\n     *\r\n     * @param {Graphic | Array<Graphic> | undefined} graphics Graphics to remove\r\n     * @returns {Promise} resolves when graphics have been removed\r\n     */\r\n    async removeHilight(graphics?: Array<Graphic> | Graphic): Promise<void> {\r\n        const gs = graphics ? (graphics instanceof Array ? graphics : [graphics]) : undefined;\r\n        await this.hilightMode.remove(gs);\r\n    }\r\n\r\n    /**\r\n     * Reload the provided graphics that are currently highlighted.\r\n     *\r\n     * @param {Array<Graphic> | Graphic} graphics\r\n     */\r\n    async reloadHilight(graphics: Array<Graphic> | Graphic) {\r\n        const gs = graphics instanceof Array ? graphics : [graphics];\r\n        await this.hilightMode.reloadHilight(gs);\r\n    }\r\n\r\n    /**\r\n     * Return all Graphics that match the given origin/uid/oid\r\n     *\r\n     * @param origin Graphic origin\r\n     * @param uid Associated layer UID of the Graphic\r\n     * @param oid Associated OID of the Graphic\r\n     */\r\n    async getGraphicsByKey(origin?: string, uid?: string, oid?: number): Promise<Array<Graphic>> {\r\n        const hilightLayer = await this.getHilightLayer();\r\n        if (!hilightLayer) {\r\n            return [];\r\n        }\r\n\r\n        let keys = hilightLayer.graphics.map(g => ({\r\n            ...this.deconstructGraphicKey(g.id),\r\n            og: g\r\n        }));\r\n\r\n        if (origin) {\r\n            keys = keys.filter(k => k.origin === origin);\r\n        }\r\n\r\n        if (uid) {\r\n            keys = keys.filter(k => k.uid === uid);\r\n        }\r\n\r\n        if (oid) {\r\n            keys = keys.filter(k => k.oid === oid);\r\n        }\r\n\r\n        return keys.map(k => k.og);\r\n    }\r\n\r\n    /**\r\n     * Return a well-formed graphic key\r\n     */\r\n    constructGraphicKey(origin: string, uid: string, oid: number): string {\r\n        return `${HILIGHT_LAYER_NAME}~${origin}~${uid}~${oid}`;\r\n    }\r\n\r\n    /**\r\n     * Return a deconstructed graphic key.\r\n     *\r\n     * @param key The graphic key to deconstruct\r\n     */\r\n    deconstructGraphicKey(key: string): {\r\n        origin: string;\r\n        uid: string;\r\n        oid: number;\r\n    } {\r\n        const ids = key.split('~');\r\n        if (ids.length !== 4) {\r\n            console.warn('Malformed Hilight Graphic key provided:', key);\r\n        }\r\n        return { origin: ids[1], uid: ids[2], oid: parseInt(ids[3]) };\r\n    }\r\n\r\n    /**\r\n     * Return the hilightLayer\r\n     */\r\n    async getHilightLayer(): Promise<CommonGraphicLayer | undefined> {\r\n        if (this.hilightMode) {\r\n            return await this.hilightMode.getHilightLayer();\r\n        } else {\r\n            console.warn('API get layer request before highlight mode object exists');\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\n","import { HilightAPI } from './api/hilight';\r\n\r\nclass HilightFixture extends HilightAPI {\r\n    async added() {\r\n        // console.log(`[fixture] ${this.id} added`);\r\n\r\n        this._parseConfig(this.config);\r\n        const unwatch = this.$vApp.$watch(\r\n            () => this.config,\r\n            (value: any) => this._parseConfig(value)\r\n        );\r\n\r\n        // override the removed method here to get access to scope\r\n        this.removed = () => {\r\n            // console.log(`[fixture] ${this.id} removed`);\r\n            unwatch();\r\n        };\r\n    }\r\n}\r\n\r\nexport default HilightFixture;\r\n"],"names":["BaseHilightMode","APIScope","HilightMode","config","iApi","graphics","hilightLayer","CommonGraphicLayer","method","precheckLayer","HILIGHT_LAYER_NAME","resolve","timeElapsed","layerWatcher","layer","LiftHilightMode","FogHilightMode","GlobalEvents","mapConfig","useConfigStore","fogLayer","FOG_HILIGHT_LAYER_NAME","LayerType","layerOrder","fogIdx","hilightIdx","lastRemove","TileLayer","GlowHilightMode","GraphicLayer","gs","layerView","g","HilightAPI","FixtureInstance","hilightConfig","DEFAULT_CONFIG","origin","uid","oid","keys","k","key","ids","HilightFixture","unwatch","value"],"mappings":"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"}