{"version":3,"file":"index-D40CRp-x.js","sources":["../../src/fixtures/export-legend/index.ts"],"sourcesContent":["import { FixtureInstance, LayerInstance } from '@/api/internal';\r\nimport type { ExportAPI, ExportSubFixture } from '@/fixtures/export/api/export';\r\nimport { fabric } from 'fabric';\r\nimport type { LegendSymbology } from '@/geo/api';\r\nimport type { ExportConfig } from '../export/store';\r\n\r\n/**\r\n * Represents a map layer.\r\n *\r\n * @interface Segment\r\n */\r\ninterface Segment {\r\n    title: fabric.Text;\r\n    items: SegmentChunk[];\r\n}\r\n\r\n/**\r\n * Represents a map layer entry.\r\n *\r\n * @interface SegmentChunk\r\n */\r\ninterface SegmentChunk {\r\n    title?: fabric.Text;\r\n\r\n    /**\r\n     * Represents layer entry symbology.\r\n     *\r\n     * @type {fabric.Group[]}\r\n     * @memberof SegmentChunk\r\n     */\r\n    items: fabric.Group[];\r\n}\r\n\r\nconst SEGMENT_TOP_MARGIN = 30;\r\nconst SEGMENT_BOTTOM_MARGIN = 20;\r\nconst CHUNK_TOP_MARGIN = 16;\r\nconst CHUNK_BOTTOM_MARGIN = 12;\r\nconst ITEM_MARGIN = 8;\r\n\r\nconst ROW_HEIGHT = 32;\r\nconst ICON_WIDTH = 32;\r\n\r\nconst MIN_COLUMN_WIDTH = 350;\r\nconst COLUMN_SPACING = 20;\r\n\r\nconst DEFAULT_FONT = 'Montserrat, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif';\r\n\r\nclass ExportLegendFixture extends FixtureInstance implements ExportSubFixture {\r\n    get config(): any {\r\n        const fixtureConfig: ExportConfig | undefined = this.$iApi.fixture.get<ExportAPI>('export').config;\r\n        return fixtureConfig?.legend;\r\n    }\r\n\r\n    async make(options: any): Promise<fabric.Group> {\r\n        // filter out loading/errored, invisible, and cosmetic layers\r\n        const layers = this.$iApi.geo.layer.allLayersOnMap().filter(layer => !layer.isCosmetic);\r\n\r\n        if (layers.length === 0) {\r\n            // return an empty group\r\n            return new fabric.Group([], {\r\n                originX: 'left'\r\n            });\r\n        }\r\n\r\n        // number of columns based on export width and min col width\r\n        const columns = Math.min(\r\n            layers.length,\r\n            Math.floor(options.width / (MIN_COLUMN_WIDTH + COLUMN_SPACING)) || 1 // round to 1 if floor is 0\r\n        );\r\n\r\n        // calculate column width such that columns are even spaced across entire export width\r\n        const columnWidth = (options.width - (columns - 1) * COLUMN_SPACING) / columns;\r\n\r\n        let runningHeight = 0;\r\n\r\n        const segments = await Promise.all(this._makeSegments(layers as unknown as Array<LayerInstance>, columnWidth));\r\n\r\n        // string all the graphic legend elements together adding margins between them\r\n        const fbAllItems = segments\r\n            .map(({ title: segmentTitle, items: chunks }, segmentIndex) => {\r\n                if (segmentIndex > 0) {\r\n                    runningHeight += SEGMENT_TOP_MARGIN;\r\n                }\r\n\r\n                segmentTitle.top = runningHeight;\r\n                runningHeight += segmentTitle.height! + SEGMENT_BOTTOM_MARGIN;\r\n\r\n                const allChunkItems = chunks.map(({ title: chunkTitle, items: chunkItems }, chunkIndex) => {\r\n                    const result = [];\r\n\r\n                    // if a single chunk shares the title with its parent segment, skip the chunk title\r\n                    if (chunkTitle && !(chunks.length === 1 && chunkTitle.text === segmentTitle.text)) {\r\n                        if (chunkIndex > 0) {\r\n                            runningHeight += CHUNK_TOP_MARGIN;\r\n                        }\r\n\r\n                        chunkTitle.top = runningHeight;\r\n                        runningHeight += chunkTitle.height! + CHUNK_BOTTOM_MARGIN;\r\n\r\n                        result.push(chunkTitle);\r\n                    }\r\n\r\n                    chunkItems.forEach(item => {\r\n                        item.top = runningHeight;\r\n                        runningHeight += item.height! + ITEM_MARGIN;\r\n                    });\r\n\r\n                    return [...result, ...chunkItems].filter(a => a);\r\n                });\r\n\r\n                // create a group for each config layer\r\n                return new fabric.Group([segmentTitle, ...allChunkItems.flat()]);\r\n            })\r\n            .flat();\r\n\r\n        const fbLegend = this._makeColumns(fbAllItems, columnWidth, columns);\r\n\r\n        return Promise.resolve(fbLegend);\r\n    }\r\n\r\n    /**\r\n     * Breaks up legend layers into columns\r\n     *\r\n     * @private\r\n     * @param {fabric.Group[]} items\r\n     * @param {number} columnWidth\r\n     * @param {number} columns\r\n     * @returns {fabric.Group}\r\n     * @memberof ExportLegendFixture\r\n     */\r\n    private _makeColumns(items: fabric.Group[], columnWidth: number, columns: number) {\r\n        let curColumn = 0;\r\n        let curTop = 0;\r\n        let accumLength = 0;\r\n        // target column height is the total length of all items divided by number of columns\r\n        const targetHeight: number = items[items.length - 1].aCoords!.bl.y / columns;\r\n\r\n        items.forEach((group, index) => {\r\n            const height: number = index !== items.length - 1 ? items[index + 1].top! - group.top! : group.height!;\r\n\r\n            // reached end of column, try to evently split items\r\n            const columnFull: boolean = accumLength > targetHeight * (curColumn + 1);\r\n            // don't allow column to go over target if layer is very long\r\n            const longLayer: boolean = curTop !== 0 && height > targetHeight;\r\n            // ensure there are no empty columns on the right\r\n            const fillColumns: boolean = columns - curColumn > items.length - index;\r\n\r\n            if ((columnFull || longLayer || fillColumns) && curColumn < columns) {\r\n                // move to next column\r\n                ++curColumn;\r\n                curTop = 0;\r\n            }\r\n\r\n            // update layer position in legend export\r\n            group.left = curColumn * (columnWidth + COLUMN_SPACING);\r\n            group.top = curTop;\r\n\r\n            curTop += height;\r\n            accumLength += height;\r\n        });\r\n\r\n        return new fabric.Group(items, {\r\n            originX: 'left'\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create segments of the export image based on the provided layers and layer configs.\r\n     *\r\n     * @private\r\n     * @param {LayerInstance[]} layers\r\n     * @param {RampLayerConfig[]} layerConfigs\r\n     * @returns {Promise<Segment>[]}\r\n     * @memberof ExportLegendFixture\r\n     */\r\n    private _makeSegments(layers: LayerInstance[], segmentWidth: number): Promise<Segment>[] {\r\n        return layers.map(async (layer: LayerInstance) => {\r\n            const title = new fabric.Textbox(layer.name, {\r\n                fontSize: 24,\r\n                fontFamily: DEFAULT_FONT,\r\n                width: segmentWidth\r\n            });\r\n\r\n            // filter out invisible layer entries\r\n            const ids = this._getLayerTreeIds(layer);\r\n\r\n            let items: any = [];\r\n            items = layer.supportsSublayers\r\n                ? await Promise.all(\r\n                      this._makeSegmentChunks(ids, layer, segmentWidth) // pass list of flatenned sublayer ids\r\n                  )\r\n                : await Promise.all(\r\n                      this._makeSegmentChunks([-1], layer, segmentWidth) // pass single -1 id so the root gets processed\r\n                  );\r\n\r\n            return { title, items };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates segment chunks based on the provided layer and layer entry id.\r\n     *\r\n     * Used for layers that support sublayers (e.g. MapImageLayers)\r\n     *\r\n     * @private\r\n     * @param {(number[] | string[])} ids\r\n     * @param {LayerInstance} layer\r\n     * @returns {Promise<SegmentChunk>[]}\r\n     * @memberof ExportLegendFixture\r\n     */\r\n    private _makeSegmentChunks(ids: number[], layer: LayerInstance, segmentWidth: number): Promise<SegmentChunk>[] {\r\n        const rootLayer: LayerInstance = layer;\r\n        return ids.map<Promise<SegmentChunk>>(async (idx: number) => {\r\n            const currLayer: LayerInstance | undefined = idx === -1 ? rootLayer : rootLayer.getSublayer(idx);\r\n\r\n            if (!currLayer) {\r\n                // This should not happen, but if it does return an ERROR label\r\n                return {\r\n                    title: new fabric.Textbox('ERROR', {\r\n                        fontSize: 20,\r\n                        fontFamily: DEFAULT_FONT,\r\n                        width: segmentWidth\r\n                    }),\r\n                    items: []\r\n                };\r\n            }\r\n\r\n            await Promise.all(currLayer.legend.map(lg => lg.drawPromise));\r\n            const symbologyStack = currLayer.legend;\r\n\r\n            const title = new fabric.Textbox(currLayer.name, {\r\n                fontSize: 20,\r\n                fontFamily: DEFAULT_FONT,\r\n                width: segmentWidth\r\n            });\r\n\r\n            const items = await Promise.all(this._makeChunkItems(symbologyStack, segmentWidth));\r\n\r\n            return {\r\n                title,\r\n                items\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates layer entry symbology based on the provided symbology stack.\r\n     *\r\n     * @private\r\n     * @param {LegendSymbology[]} symbologyStack\r\n     * @returns {Promise<fabric.Group>[]}\r\n     * @memberof ExportLegendFixture\r\n     */\r\n    private _makeChunkItems(symbologyStack: LegendSymbology[], segmentWidth: number): Promise<fabric.Group>[] {\r\n        return symbologyStack.map(async symbol => {\r\n            const fbSymbol = (await promisify(fabric.loadSVGFromString)(symbol.svgcode))[0];\r\n\r\n            if (!symbol.esriStandard) {\r\n                // WMS legend\r\n                const fbLabel = new fabric.Textbox(symbol.label, {\r\n                    fontSize: 12,\r\n                    fontFamily: DEFAULT_FONT,\r\n                    originY: 'center',\r\n                    left: 0,\r\n                    top: ROW_HEIGHT / 2,\r\n                    width: segmentWidth\r\n                });\r\n\r\n                const symbolWidth = Number(symbol.imgWidth!);\r\n                const symbolHeight = Number(symbol.imgHeight!);\r\n\r\n                // scale down image if wider than column\r\n                const scale = Math.min(1, segmentWidth / symbolWidth);\r\n\r\n                if (fbSymbol) {\r\n                    fbSymbol.originY = 'center';\r\n                    fbSymbol.top = (symbolHeight * scale) / 2 + ROW_HEIGHT;\r\n                    fbSymbol.scaleToHeight(symbolHeight * scale);\r\n                    fbSymbol.scaleToWidth(symbolWidth * scale);\r\n                }\r\n\r\n                return new fabric.Group([fbLabel, fbSymbol].filter(Boolean), {\r\n                    height: symbolHeight * scale + ROW_HEIGHT\r\n                });\r\n            } else {\r\n                fbSymbol.originY = 'center';\r\n                fbSymbol.top = ROW_HEIGHT / 2;\r\n\r\n                const fbLabel = new fabric.Textbox(symbol.label, {\r\n                    fontSize: 12,\r\n                    fontFamily: DEFAULT_FONT,\r\n                    originY: 'center',\r\n                    left: ICON_WIDTH + 20,\r\n                    top: ROW_HEIGHT / 2,\r\n                    width: segmentWidth - ICON_WIDTH - 20\r\n                });\r\n\r\n                return new fabric.Group([fbSymbol, fbLabel], {\r\n                    height: ROW_HEIGHT\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets flattened array of ids from layer tree\r\n     *\r\n     * @private\r\n     * @param {TreeNode} node\r\n     * @returns {number[]}\r\n     * @memberof ExportLegendFixture\r\n     */\r\n    private _getLayerTreeIds(rootLayer: LayerInstance): number[] {\r\n        const ids: Array<number> = [];\r\n        const queue: Array<LayerInstance> = [...rootLayer.sublayers];\r\n\r\n        while (queue.length > 0) {\r\n            const sublayer: LayerInstance = queue.shift()!;\r\n            if (!sublayer) {\r\n                continue;\r\n            }\r\n\r\n            sublayer.visibility && ids.push(sublayer.layerIdx);\r\n            queue.push(...sublayer.sublayers);\r\n        }\r\n\r\n        return ids;\r\n    }\r\n}\r\n\r\ntype Callback<A> = (args: A) => void;\r\n\r\n/**\r\n * A utility function to promisify callback-based function.\r\n * TODO: move somewhere where this can be reused\r\n *\r\n * @param fn A\r\n * @returns\r\n */\r\nconst promisify = <T, A>(fn: (args: T, cb: Callback<A>) => void): ((args: T) => Promise<A>) => {\r\n    return (args: T) =>\r\n        new Promise(resolve => {\r\n            fn(args, callbackArgs => {\r\n                resolve(callbackArgs);\r\n            });\r\n        });\r\n};\r\n\r\nexport default ExportLegendFixture;\r\n"],"names":["SEGMENT_TOP_MARGIN","SEGMENT_BOTTOM_MARGIN","CHUNK_TOP_MARGIN","CHUNK_BOTTOM_MARGIN","ITEM_MARGIN","ROW_HEIGHT","ICON_WIDTH","MIN_COLUMN_WIDTH","COLUMN_SPACING","DEFAULT_FONT","ExportLegendFixture","FixtureInstance","options","layers","layer","fabric","columns","columnWidth","runningHeight","fbAllItems","segmentTitle","chunks","segmentIndex","allChunkItems","chunkTitle","chunkItems","chunkIndex","result","item","a","fbLegend","items","curColumn","curTop","accumLength","targetHeight","group","index","height","columnFull","longLayer","fillColumns","segmentWidth","title","ids","rootLayer","idx","currLayer","lg","symbologyStack","symbol","fbSymbol","promisify","fbLabel","symbolWidth","symbolHeight","scale","queue","sublayer","fn","args","resolve","callbackArgs"],"mappings":"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"}