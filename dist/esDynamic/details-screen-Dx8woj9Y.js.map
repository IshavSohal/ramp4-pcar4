{"version":3,"file":"details-screen-Dx8woj9Y.js","sources":["../../src/fixtures/details/components/symbology-stack.vue","../../src/fixtures/details/components/symbology-item.vue","../../src/fixtures/details/components/symbology-list.vue","../../src/fixtures/details/templates/esri-default.vue","../../src/fixtures/details/templates/html-default.vue","../../src/fixtures/details/components/result-item.vue","../../src/fixtures/details/components/result-list.vue","../../src/fixtures/details/details-screen.vue"],"sourcesContent":["<template>\r\n    <div v-if=\"result.loaded\" class=\"relative\">\r\n        <div :class=\"result.items.length === 0 ? 'opacity-50' : ''\">\r\n            <!-- Multiple icons to display -->\r\n            <div v-if=\"stack.length > 1\" class=\"relative\">\r\n                <!-- the :class line calculates margin-left for each of the 3 symbols, and gives a margin-top to symbols that arent the first -->\r\n                <div\r\n                    class=\"absolute\"\r\n                    :class=\"[idx == 0 ? 'symbol-0' : idx == 1 ? 'left-3' : 'left-6']\"\r\n                    :style=\"{ 'z-index': 3 - idx }\"\r\n                    v-for=\"(item, idx) in stack.slice(0, 3).reverse()\"\r\n                    :key=\"idx\"\r\n                >\r\n                    <span v-if=\"stack[idx].svgcode\" class=\"symbologyIcon w-28 h-28\" v-html=\"stack[idx].svgcode\"></span>\r\n                    <img v-else-if=\"stack[idx].imgUrl\" class=\"symbologyIcon w-28 h-28\" :src=\"stack[idx].imgUrl\" />\r\n                </div>\r\n            </div>\r\n\r\n            <!-- Only one icon to display. -->\r\n            <div v-else-if=\"stack.length > 0\" class=\"w-32 h-32\">\r\n                <div class=\"symbologyIcon\">\r\n                    <span v-if=\"stack[0].svgcode\" v-html=\"stack[0].svgcode\"></span>\r\n                    <img v-else-if=\"stack[0].imgUrl\" class=\"symbologyIcon w-full h-full\" :src=\"stack[0].imgUrl\" />\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <!-- result counter -->\r\n        <div class=\"badge z-50 rounded-full text-white absolute h-10 w-10 p-8 inline-flex items-center justify-center\">\r\n            <div v-if=\"result.loaded\" class=\"px-5\">\r\n                {{ result.items.length }}\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <div v-else class=\"inline-flex justify-center items-center relative\">\r\n        <div class=\"symbologyIcon h-32 w-32\">\r\n            <div class=\"relative animate-spin spinner h-24 w-24\"></div>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\n// this renders the everything needed for a symbol stack running along the left side of the panel.\r\n// includes symbol stacking, loading spinners, result count badge\r\n\r\nimport type { LayerInstance } from '@/api';\r\n\r\nimport { onMounted, type PropType, ref } from 'vue';\r\n\r\nconst props = defineProps({\r\n    layer: { type: Object as PropType<LayerInstance>, required: true },\r\n    result: { type: Object as any, required: true }\r\n});\r\n\r\nconst stack = ref<any>([]); // ref instead of reactive to maintain reactivity after promise\r\n\r\nonMounted(() => {\r\n    stack.value = props.layer.legend;\r\n});\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n.badge {\r\n    background-color: #576870;\r\n    bottom: -5px;\r\n    right: -5px;\r\n    font-size: 8px;\r\n}\r\n</style>\r\n","<template>\r\n    <button\r\n        class=\"flex flex-grow justify-start items-center px-7 py-10 default-focus-style symbologyStackButton truncate\"\r\n        :class=\"selected ? 'detailsButtonSelected' : 'px-11'\"\r\n        @click.stop=\"\"\r\n        :content=\"layerName()\"\r\n        v-tippy=\"{ placement: 'right', sticky: true }\"\r\n    >\r\n        <SymbologyStack class=\"symbStack w-32 h-32 mr-10\" :layer=\"layer\" :result=\"result\"></SymbologyStack>\r\n        <div class=\"symbologyLayerName truncate\">\r\n            {{ layerName() }}\r\n        </div>\r\n    </button>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\n// this constructs an entire list item in the symbology-list\r\n// includes the symbology-stack, as well as fancy slideout magic to show\r\n// layer name when moused over\r\n\r\nimport { computed } from 'vue';\r\nimport SymbologyStack from './symbology-stack.vue';\r\nimport { useDetailsStore } from '../store';\r\n\r\nimport type { DetailsItemInstance } from '../store';\r\n\r\nconst detailsStore = useDetailsStore();\r\nconst detailProperties = computed<{ [id: string]: DetailsItemInstance }>(() => detailsStore.properties);\r\n\r\nconst props = defineProps({\r\n    layer: { type: Object as any, required: true },\r\n    result: { type: Object as any, required: true },\r\n    selected: { type: Boolean, required: true }\r\n});\r\n\r\n/**\r\n * Retrieve the layer name.\r\n */\r\nconst layerName = () => {\r\n    const layer = props.layer;\r\n    if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].name) {\r\n        return detailProperties.value[layer.id].name;\r\n    }\r\n    return layer?.name ?? '';\r\n};\r\n</script>\r\n\r\n<style lang=\"scss\">\r\n.symbStack {\r\n    flex: 0 0 32px;\r\n}\r\n.detailsButtonSelected {\r\n    border-left: 3px solid #576870;\r\n    padding-left: 4px !important;\r\n}\r\n.symbologyStackButton {\r\n    transition: background 0.3s;\r\n}\r\n.symbologyStackButton:hover {\r\n    background: #eee;\r\n}\r\n.symbologyLayerName {\r\n    flex: 1 1 auto;\r\n    text-align: left;\r\n}\r\n\r\n.symbologyStackButton:focus {\r\n    outline: 2px solid black;\r\n    z-index: 1;\r\n}\r\n</style>\r\n","<template>\r\n    <div\r\n        class=\"symbology-list absolute overflow-hidden z-50 p-0 w-48 bg-white text-sm inline-flex flex-col\"\r\n        :class=\"{ 'symbology-list-expanded': expanded }\"\r\n        @mouseover=\"handleMouseOver\"\r\n        @mouseleave=\"handleMouseLeave\"\r\n        @focus=\"handleItemFocus\"\r\n        @blur.self=\"handleItemBlur\"\r\n        v-focus-list\r\n        :content=\"t('details.layers.results.list.tooltip')\"\r\n        v-tippy=\"{\r\n            trigger: 'manual',\r\n            placement: 'top-start',\r\n            touch: false\r\n        }\"\r\n        ref=\"el\"\r\n    >\r\n        <div class=\"flex justify-start relative\" v-for=\"(item, idx) in props.results\" :key=\"idx\">\r\n            <SymbologyItem\r\n                :key=\"item.uid\"\r\n                :layer=\"getLayerInfo(item.uid)\"\r\n                :result=\"item\"\r\n                :selected=\"item.uid === selectedLayer\"\r\n                @click=\"handleItemClick(item.uid)\"\r\n                v-focus-item\r\n            ></SymbologyItem>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\n// this renders the list of symbology items that run along the left side\r\n\r\nimport { ref, watch, onBeforeMount, onBeforeUnmount, onMounted } from 'vue';\r\nimport { useLayerStore } from '@/stores/layer';\r\n\r\nimport type { LayerInstance } from '@/api';\r\nimport { useI18n } from 'vue-i18n';\r\n\r\nimport SymbologyItem from './symbology-item.vue';\r\n\r\nconst { t } = useI18n();\r\nconst layerStore = useLayerStore();\r\n\r\nconst el = ref<Element>();\r\nconst blurEvent = () => {\r\n    (el.value as any)._tippy.hide();\r\n};\r\nconst keyupEvent = (e: Event) => {\r\n    const evt = e as KeyboardEvent;\r\n    if (evt.key === 'Tab' && el.value?.matches(':focus')) {\r\n        (el.value as any)._tippy.show();\r\n    }\r\n};\r\n\r\nconst emit = defineEmits(['selection-changed']);\r\nconst props = defineProps({\r\n    results: { type: Object as any, required: true },\r\n    selected: { type: String, required: true }\r\n});\r\n\r\n// Keep track of the currently selected layer index.\r\nconst selectedLayer = ref<string>('');\r\nconst watchers = ref<Array<Function>>([]);\r\n\r\n// Expanded is true if the sidebar is expanded. Hovering is true only if the cursor is currently over the sidebar.\r\nconst expanded = ref<Boolean>(false);\r\nconst hovering = ref<Boolean>(false);\r\n\r\n/**\r\n * Return the LayerInstance that cooresponds with the provided UID.\r\n * @param uid the UID of the layer to look up.\r\n */\r\nconst getLayerInfo = (uid: string) => {\r\n    let layer: LayerInstance | undefined = layerStore.getLayerByUid(uid);\r\n    return layer;\r\n};\r\n\r\n/**\r\n * Handles when a user clicks on an item.\r\n * @param uid the UID of the clicked layer\r\n */\r\nconst handleItemClick = (uid: string) => {\r\n    selectedLayer.value = uid;\r\n    emit('selection-changed', uid);\r\n\r\n    // Close the sidebar when an item is clicked.\r\n    expanded.value = false;\r\n};\r\n\r\n/**\r\n * Handles when a user moves their mouse over the sidebar.\r\n */\r\nconst handleMouseOver = () => {\r\n    if (!hovering.value) {\r\n        // If not already hovering, delay expansion of the sidebar for 500ms.\r\n        setTimeout(() => {\r\n            expanded.value = hovering.value;\r\n        }, 500);\r\n    }\r\n\r\n    hovering.value = true;\r\n};\r\n\r\n/**\r\n * Handles when the user moves their mouse away from the sidebar.\r\n */\r\nconst handleMouseLeave = () => {\r\n    expanded.value = hovering.value = false;\r\n};\r\n\r\n/**\r\n * Activates when an item in the list is focused.\r\n */\r\nconst handleItemFocus = () => {\r\n    if (!hovering.value) {\r\n        expanded.value = true;\r\n    }\r\n    hovering.value = true;\r\n};\r\n\r\n/**\r\n * Activates when an item in the list is unfocused.\r\n */\r\nconst handleItemBlur = () => {\r\n    expanded.value = hovering.value = false;\r\n};\r\n\r\nonBeforeMount(() => {\r\n    // keep track of this watcher because it needs to be removed when this component is unmounted\r\n    watchers.value.push(\r\n        watch(props, () => {\r\n            // Something has changed, so re-fetch the icon.\r\n            selectedLayer.value = props.selected;\r\n        })\r\n    );\r\n});\r\n\r\nonMounted(() => {\r\n    el.value?.addEventListener('blur', blurEvent);\r\n    el.value?.addEventListener('keyup', keyupEvent);\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n    watchers.value.forEach(unwatch => unwatch());\r\n\r\n    el.value?.removeEventListener('blur', blurEvent);\r\n    el.value?.removeEventListener('keyup', keyupEvent);\r\n});\r\n</script>\r\n\r\n<style lang=\"scss\">\r\n.symbology-list {\r\n    /** fun magic to get the bar to take up the entire height */\r\n    height: auto;\r\n    top: 0px;\r\n    bottom: -8px;\r\n\r\n    border-right: 1px solid #eee;\r\n    box-shadow: -1px 0px 5px rgba(0, 0, 0, 0.5);\r\n\r\n    margin: -8px;\r\n    margin-bottom: 0px;\r\n\r\n    transition: all 0.3s cubic-bezier(0.35, 0, 0.25, 1);\r\n}\r\n.symbology-list-expanded {\r\n    width: 70% !important;\r\n    overflow-y: auto !important;\r\n}\r\n</style>\r\n","<template>\r\n    <div>\r\n        <div\r\n            class=\"p-5 pl-3 flex justify-end flex-wrap even:bg-gray-300\"\r\n            v-for=\"(val, name, itemIdx) in itemData()\"\r\n            :key=\"itemIdx\"\r\n        >\r\n            <span class=\"inline font-bold\">{{ val.alias }}</span>\r\n            <span class=\"flex-auto\"></span>\r\n            <span class=\"inline\" v-html=\"formatValues(val.value, val.alias, val.type)\"></span>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { inject } from 'vue';\r\nimport type { PropType } from 'vue';\r\nimport type { FieldDefinition } from '@/geo/api';\r\nimport type { DetailsFieldItem } from '@/fixtures/details/store';\r\nimport linkifyHtml from 'linkify-html';\r\nimport type { IdentifyItem, InstanceAPI } from '@/api';\r\nimport { useI18n } from 'vue-i18n';\r\n\r\nconst { t } = useI18n();\r\n\r\nconst iApi = inject<InstanceAPI>('iApi');\r\n\r\nconst props = defineProps({\r\n    fixtureFields: {\r\n        type: Object as PropType<Array<DetailsFieldItem>>,\r\n        required: false\r\n    },\r\n    fields: {\r\n        type: Object as PropType<Array<FieldDefinition>>,\r\n        required: true\r\n    },\r\n    identifyData: {\r\n        type: Object as PropType<IdentifyItem>,\r\n        required: true\r\n    }\r\n});\r\n\r\nconst findAndDelete = (fields: FieldDefinition[], propertyType: 'type' | 'name', property: string, helper: any) => {\r\n    const field = fields.find(f => f[propertyType].toLowerCase() === property.toLowerCase());\r\n\r\n    // If the field is found, delete it from the helper object\r\n    if (field) delete helper[field.name];\r\n};\r\n\r\n/**\r\n * Constructs and returns a metadata mapping of what we actually want to display.\r\n * Key: field name\r\n * Value: object with these props\r\n * - value (formatted)\r\n * - alias (display text for field. See aliases.name below)\r\n * - type (field data type)\r\n */\r\nconst itemData = () => {\r\n    const clonePayload = Object.assign({}, props.identifyData.data);\r\n\r\n    // Remove any fields of type geometry\r\n    findAndDelete(props.fields, 'type', 'geometry', clonePayload);\r\n\r\n    if (!iApi?.ui.exposeOids) {\r\n        // check global oid flag\r\n        findAndDelete(props.fields, 'type', 'oid', clonePayload);\r\n    }\r\n\r\n    if (!iApi?.ui.exposeMeasurements) {\r\n        // check global measurements flag\r\n        findAndDelete(props.fields, 'name', 'shape_length', clonePayload);\r\n        findAndDelete(props.fields, 'name', 'shape_area', clonePayload);\r\n    }\r\n\r\n    /**\r\n     * Builds up a mapping of all LAYER field names --> data about field\r\n     * - name (display name. Priority order: detail fixture config alias, layer alias, layer field)\r\n     * - type (field data type)\r\n     * - visible (if should be displayed; detail fixture config option)\r\n     */\r\n    const fieldsMetadata: any = {};\r\n    props.fields.forEach(field => {\r\n        // Check to see if this field is being overwritten in the fixture config.\r\n        const checkField = props.fixtureFields?.find(item => field.name === item.field);\r\n\r\n        fieldsMetadata[field.name] = {\r\n            name: checkField?.alias || field.alias || field.name,\r\n            type: field.type,\r\n            visible: checkField?.visible ?? true\r\n        }; // use the key name if alias is not defined. Default visibility to true if it's not defined.\r\n    });\r\n\r\n    /**\r\n     * Builds up a mapping of valid PAYLOAD attribute field names --> data about that attribute\r\n     * - value (formatted)\r\n     * - alias (display text for field. See aliases.name below)\r\n     * - type (field data type)\r\n     *\r\n     * Invalid fields are: ones the system is hiding, and ones that don't exist on the layer\r\n     */\r\n    const displayMetadata: any = {};\r\n\r\n    // we iterate on the clone since that is what had the field removals.\r\n    Object.keys(clonePayload).forEach(key => {\r\n        const fieldMD = fieldsMetadata[key];\r\n        if (fieldMD && fieldMD.visible) {\r\n            // field exists in layer, and should be shown\r\n\r\n            const cloneValue = clonePayload[key];\r\n\r\n            displayMetadata[key] = {\r\n                value: typeof cloneValue === 'number' ? iApi?.ui.formatNumber(cloneValue) : cloneValue,\r\n                alias: fieldMD.name,\r\n                type: fieldMD.type\r\n            };\r\n        }\r\n    });\r\n\r\n    for (const [key] of Object.entries(displayMetadata)) {\r\n        // only replace html special chars if string represents plain text\r\n        if (iApi!.ui.isPlainText(displayMetadata[key].value)) {\r\n            displayMetadata[key].value = iApi!.ui.escapeHtml(displayMetadata[key].value);\r\n        }\r\n    }\r\n\r\n    return displayMetadata;\r\n};\r\n\r\n// render value based on type\r\nconst formatValues = (html: string, alias: string, type: string): string => {\r\n    switch (type) {\r\n        case 'date':\r\n            return makeDate(html);\r\n        default:\r\n            return makeHtmlLink(html, alias);\r\n    }\r\n};\r\n\r\n// make links look like links and work like links\r\nconst makeHtmlLink = (html: string, alias: string): string => {\r\n    if (!html) {\r\n        return html;\r\n    }\r\n\r\n    // Check to see if url is a valid image / data url based on extension type or format\r\n    if (\r\n        !!html.trim().match(/\\.(jpeg|jpg|gif|png)$/) ||\r\n        !!html.trim().match(\r\n            /^\\s*data:([a-z]+\\/[a-z]+(;[a-z\\-]+\\=[a-z\\-]+)?)?(;base64)?,[a-z0-9\\!\\$\\&\\'\\,\\(\\)\\*\\+\\,\\;\\=\\-\\.\\_\\~\\:\\@\\/\\?\\%\\s]*\\s*$/i //eslint-disable-line\r\n        )\r\n    ) {\r\n        return `<img src=\"${html}\" alt=\"${t('details.item.alert.defaultAltText', { alias: alias })}\" />`;\r\n    }\r\n\r\n    const classes = 'underline text-blue-700 break-all';\r\n    const div = document.createElement('div');\r\n    div.innerHTML = html.trim();\r\n\r\n    // check if the html string is just an <a> tag\r\n    if (div.firstElementChild?.tagName == 'A') {\r\n        div.firstElementChild.className = classes;\r\n        return div.innerHTML;\r\n    } else {\r\n        // otherwise, look for any valid links\r\n        const options = {\r\n            className: classes,\r\n            target: '_blank',\r\n            validate: {\r\n                url: (value: string) => /^https?:\\/\\//.test(value) // only links that begin with a protocol will be hyperlinked\r\n            }\r\n        };\r\n        return linkifyHtml(html, options);\r\n    }\r\n};\r\n\r\n// convert timestamps into date strings that match the datagrid\r\nconst makeDate = (html: string): string => {\r\n    // the value is saved as a string, so attempt to convert it to a number\r\n    const numericDate = parseInt(html);\r\n\r\n    // if the date can't be converted to a number, then it may already be formatted. Display it as it is.\r\n    if (isNaN(numericDate)) {\r\n        return html;\r\n    }\r\n\r\n    // Return in YYYY-MM-DD format\r\n    const formattedDate = new Date(numericDate);\r\n    return formattedDate.toISOString().split('T')[0];\r\n};\r\n</script>\r\n\r\n<style lang=\"scss\"></style>\r\n","<template>\r\n    <div\r\n        class=\"whitespace-pre-wrap break-words h-full overflow-auto\"\r\n        v-if=\"identifyData\"\r\n        v-html=\"identifyData.data.data ?? identifyData.data\"\r\n    ></div>\r\n    <div v-else>{{ t('details.layers.results.empty') }}</div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport type { PropType } from 'vue';\r\nimport type { IdentifyItem } from '@/api';\r\nimport { useI18n } from 'vue-i18n';\r\n\r\nconst { t } = useI18n();\r\n\r\ndefineProps({\r\n    identifyData: {\r\n        type: Object as PropType<IdentifyItem>,\r\n        required: true\r\n    }\r\n});\r\n</script>\r\n\r\n<style lang=\"scss\"></style>\r\n","<template>\r\n    <!-- Header including icon, name, zoom button -->\r\n    <div class=\"relative flex flex-grow truncate\">\r\n        <div class=\"flex flex-grow items-center truncate\" v-if=\"supportsFeatures\">\r\n            <!-- display symbol if it has loaded, otherwise display a loading spinner -->\r\n            <div class=\"flex p-8 items-center\">\r\n                <span v-if=\"data.loaded && icon\" class=\"flex-none symbologyIcon\" v-html=\"icon\"></span>\r\n                <div class=\"symbologyIcon p-6\" v-else>\r\n                    <div class=\"animate-spin spinner h-20 w-20\"></div>\r\n                </div>\r\n            </div>\r\n\r\n            <!-- display name of the data point -->\r\n            <span\r\n                v-if=\"data.loaded\"\r\n                class=\"pl-3 text-left flex-grow itemName\"\r\n                :content=\"itemName\"\r\n                v-html=\"makeHtmlLink(itemName)\"\r\n                v-truncate=\"{\r\n                    options: { placement: 'right' }\r\n                }\"\r\n                :tabindex=\"inList ? -1 : 0\"\r\n            ></span>\r\n            <div v-else class=\"flex p-6 flex-grow\">\r\n                {{ t('details.loading') }}\r\n            </div>\r\n\r\n            <!-- zoom icon -->\r\n            <span class=\"zoomButton text-center p-3\" v-if=\"data.loaded\"\r\n                ><button\r\n                    type=\"button\"\r\n                    :content=\"t(`details.item.zoom${zoomStatus === 'none' ? '' : `.${zoomStatus}`}`)\"\r\n                    v-tippy=\"{ placement: 'bottom' }\"\r\n                    :aria-label=\"t(`grid.cells.zoom${zoomStatus === 'none' ? '' : `.${zoomStatus}`}`)\"\r\n                    ref=\"zoomButton\"\r\n                    @click=\"\r\n                        (e: MouseEvent) => {\r\n                            e.stopPropagation();\r\n                            zoomToFeature();\r\n                        }\r\n                    \"\r\n                    class=\"text-gray-600 w-24 h-24 p-2 flex justify-center items-center\"\r\n                    v-if=\"isMapLayer\"\r\n                >\r\n                    <div v-if=\"zoomStatus === 'zooming'\" class=\"m-auto animate-spin spinner h-20 w-20\"></div>\r\n                    <svg\r\n                        v-else-if=\"zoomStatus === 'zoomed'\"\r\n                        xmlns=\"http://www.w3.org/2000/svg\"\r\n                        fill=\"none\"\r\n                        viewBox=\"0 0 24 24\"\r\n                        stroke-width=\"1.5\"\r\n                        stroke=\"green\"\r\n                        class=\"m-auto w-20 h-20\"\r\n                    >\r\n                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 12.75l6 6 9-13.5\" />\r\n                    </svg>\r\n                    <svg\r\n                        v-else-if=\"zoomStatus === 'error'\"\r\n                        xmlns=\"http://www.w3.org/2000/svg\"\r\n                        fill=\"none\"\r\n                        viewBox=\"0 0 24 24\"\r\n                        stroke-width=\"1.5\"\r\n                        stroke=\"red\"\r\n                        class=\"m-auto w-20 h-20\"\r\n                    >\r\n                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18L18 6M6 6l12 12\" />\r\n                    </svg>\r\n                    <span v-else v-html=\"iApi.ui.getZoomIcon()\"></span></button\r\n            ></span>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Details Component -->\r\n    <component\r\n        v-if=\"!!open\"\r\n        :is=\"detailsTemplate\"\r\n        :identifyData=\"data\"\r\n        :fields=\"fieldsList\"\r\n        :fixtureFields=\"fixtureFields\"\r\n        class=\"p-8\"\r\n    ></component>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\n// handles the rendering of a single result item.\r\n// has support for the different supported formats, and applying vue templates\r\n\r\nimport { useLayerStore } from '@/stores/layer';\r\nimport { GeometryType, LayerType } from '@/geo/api';\r\nimport { DetailsItemInstance, useDetailsStore, type DetailsFieldItem } from '../store';\r\nimport { computed, ref, inject, onBeforeMount, onBeforeUnmount, watch } from 'vue';\r\nimport { useI18n } from 'vue-i18n';\r\nimport linkifyHtml from 'linkify-html';\r\n\r\nimport ESRIDefault from '../templates/esri-default.vue';\r\nimport HTMLDefault from '../templates/html-default.vue';\r\n\r\nimport type { FieldDefinition } from '@/geo/api';\r\nimport type { IdentifyItem, InstanceAPI, LayerInstance } from '@/api';\r\nimport type { PropType } from 'vue';\r\n\r\nconst layerStore = useLayerStore();\r\nconst props = defineProps({\r\n    uid: { type: String, required: true },\r\n    data: { type: Object as PropType<IdentifyItem>, required: true },\r\n    open: { type: Boolean, required: false },\r\n    inList: { type: Boolean, required: false }\r\n});\r\n\r\nconst iApi = inject<InstanceAPI>('iApi')!;\r\nconst watchers = ref<Array<Function>>([]);\r\nconst detailsStore = useDetailsStore();\r\nconst { t } = useI18n();\r\n\r\n/**\r\n * Icon string to display for this item\r\n */\r\nconst icon = ref<string>('');\r\nconst zoomStatus = ref<'zooming' | 'zoomed' | 'error' | 'none'>('none');\r\nconst zoomButton = ref<HTMLElement>();\r\n\r\n/**\r\n * Return the LayerInstance that cooresponds with the UID provided in props.\r\n */\r\nconst getLayerInfo = () => {\r\n    let layer: LayerInstance | undefined = layerStore.getLayerByUid(props.uid);\r\n    return layer;\r\n};\r\n\r\nconst detailProperties = computed<{ [id: string]: DetailsItemInstance }>(() => detailsStore.properties);\r\n\r\nconst defaultTemplates = computed<{ [type: string]: string }>(() => detailsStore.defaultTemplates);\r\n\r\nconst supportsFeatures = computed<Boolean>(() => {\r\n    return getLayerInfo()?.supportsFeatures ?? false;\r\n});\r\n\r\nconst isMapLayer = computed<Boolean>(() => {\r\n    return getLayerInfo()?.mapLayer ?? false;\r\n});\r\n\r\n/**\r\n * Determine the name of the data point.\r\n */\r\nconst itemName = computed<string>(() => {\r\n    const nameField = getLayerInfo()?.nameField;\r\n    let returnValue = nameField && props.data.loaded ? props.data.data[nameField] : iApi.$i18n.t('details.items.title');\r\n\r\n    // only replace html special chars if string represents plain text\r\n    if (iApi!.ui.isPlainText(returnValue)) {\r\n        returnValue = iApi!.ui.escapeHtml(returnValue);\r\n    }\r\n\r\n    return returnValue;\r\n});\r\n\r\n// make links look like links and work like links\r\nconst makeHtmlLink = (html: any): any => {\r\n    if (typeof html === 'string') {\r\n        const classes = 'underline text-blue-700 break-all';\r\n        const div = document.createElement('div');\r\n        div.innerHTML = html.trim();\r\n\r\n        // check if the html string is just an <a> tag\r\n        if (div.firstElementChild?.tagName == 'A') {\r\n            div.firstElementChild.className = classes;\r\n            return div.innerHTML;\r\n        } else {\r\n            // otherwise, look for any valid links\r\n            const options = {\r\n                className: classes,\r\n                target: '_blank',\r\n                validate: {\r\n                    url: (value: string) => /^https?:\\/\\//.test(value) // only links that begin with a protocol will be hyperlinked\r\n                }\r\n            };\r\n            return linkifyHtml(html, options);\r\n        }\r\n    }\r\n    return html;\r\n};\r\n\r\n/**\r\n * Called whenever the displayed item changes\r\n */\r\nconst itemChanged = () => {\r\n    updateZoomStatus('none');\r\n    if (props.data.loaded) {\r\n        fetchIcon();\r\n    } else {\r\n        // request any details download and wait.\r\n        // innards of .load() are smart enough not to double-request.\r\n        // TODO revist when we implement pagination on the result-list.vue list mode.\r\n        //      if it only renders what is on current page, then only visible items should\r\n        //      hit this and make load requests. But need to ensure -- hitting everything\r\n        //      will cause issue #2156\r\n\r\n        props.data.load().then(() => {\r\n            fetchIcon();\r\n        });\r\n\r\n        // TODO do we need some type of updateAlert that says the screen is now\r\n        //      in a loading state?\r\n    }\r\n};\r\n\r\n/**\r\n * Get the icon of the identify result.\r\n */\r\nconst fetchIcon = () => {\r\n    icon.value = '';\r\n    if (!(props.data && props.data.loaded)) {\r\n        return;\r\n    }\r\n\r\n    const layer: LayerInstance | undefined = getLayerInfo();\r\n\r\n    if (layer === undefined) {\r\n        console.warn(`could not find layer for uid ${props.uid} during icon lookup`);\r\n        return;\r\n    }\r\n\r\n    if (layer.supportsFeatures) {\r\n        const oidField = layer.oidField;\r\n\r\n        layer.getIcon(props.data.data[oidField]).then((value: string) => {\r\n            icon.value = value;\r\n        });\r\n    }\r\n};\r\n\r\n/**\r\n * Fetch the correct details template.\r\n */\r\nconst detailsTemplate = computed(() => {\r\n    const layer: LayerInstance | undefined = getLayerInfo();\r\n\r\n    // If there is a custom template binding for this layer in the store, then\r\n    // return its name.\r\n    if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].template) {\r\n        return detailProperties.value[layer.id].template;\r\n    }\r\n\r\n    // If nothing is found, use a default template from config\r\n    if (defaultTemplates.value && defaultTemplates.value[props.data.format]) {\r\n        return defaultTemplates.value[props.data.format];\r\n    }\r\n\r\n    // If default template is not specified, use our default template\r\n    if (!supportsFeatures.value) {\r\n        return HTMLDefault;\r\n    } else {\r\n        return ESRIDefault;\r\n    }\r\n});\r\n\r\n/**\r\n * Retrieve layer fields.\r\n */\r\nconst fieldsList = computed<Array<FieldDefinition>>(() => {\r\n    // wms layers do not support fields\r\n    if (!supportsFeatures.value) {\r\n        return [];\r\n    }\r\n    const layer: LayerInstance | undefined = getLayerInfo();\r\n    const fields = layer?.fields;\r\n    return fields || [];\r\n});\r\n\r\n/**\r\n * Check for any field overrides.\r\n */\r\nconst fixtureFields = computed<DetailsFieldItem[] | undefined>(() => {\r\n    const layer: LayerInstance | undefined = getLayerInfo();\r\n\r\n    if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].fields) {\r\n        return detailProperties.value[layer.id].fields;\r\n    }\r\n    return undefined;\r\n});\r\n\r\nconst updateZoomStatus = (value: 'zooming' | 'zoomed' | 'error' | 'none') => {\r\n    if (value === 'zoomed' || value === 'error') {\r\n        setTimeout(() => {\r\n            zoomStatus.value = value;\r\n            (zoomButton.value as any)?._tippy.show();\r\n            setTimeout(() => {\r\n                (zoomButton.value as any)?._tippy.hide();\r\n                zoomStatus.value = 'none';\r\n            }, 3000);\r\n        }, 300);\r\n    } else {\r\n        zoomStatus.value = value;\r\n    }\r\n};\r\n\r\n/**\r\n * Zoom to feature on the map\r\n */\r\nconst zoomToFeature = () => {\r\n    if (zoomStatus.value !== 'none') {\r\n        return;\r\n    }\r\n\r\n    updateZoomStatus('zooming');\r\n    const layer: LayerInstance | undefined = getLayerInfo();\r\n\r\n    if (layer === undefined || !layer.isLoaded) {\r\n        console.warn(`Could not find layer for uid ${props.uid} during zoom geometry lookup`);\r\n        updateZoomStatus('error');\r\n        return;\r\n    }\r\n\r\n    if (!props.data.loaded) {\r\n        console.warn('Details zoomToFeature call on item that is still loading. Should be impossible, alert the devs.');\r\n        updateZoomStatus('error');\r\n        return;\r\n    }\r\n\r\n    const oid = props.data.data[layer.oidField];\r\n    const zoomUsingGraphic = () => {\r\n        const opts = { getGeom: true };\r\n        layer\r\n            .getGraphic(oid, opts)\r\n            .then(g => {\r\n                if (g.geometry.invalid()) {\r\n                    console.error(`Could not find graphic for objectid ${oid}`);\r\n                    updateZoomStatus('error');\r\n                } else {\r\n                    iApi.geo.map.zoomMapTo(g.geometry);\r\n                    updateZoomStatus('zoomed');\r\n                    iApi.updateAlert(iApi.$i18n.t('details.item.alert.zoom'));\r\n                }\r\n            })\r\n            .catch(() => {\r\n                updateZoomStatus('error');\r\n            });\r\n    };\r\n\r\n    if (layer.layerType === LayerType.FEATURE && layer.geomType !== GeometryType.POINT) {\r\n        layer\r\n            .getGraphicExtent(oid)\r\n            .then(e => {\r\n                iApi.geo.map.zoomMapTo(e);\r\n                updateZoomStatus('zoomed');\r\n                iApi.updateAlert(iApi.$i18n.t('details.item.alert.zoom'));\r\n            })\r\n            .catch(() => {\r\n                zoomUsingGraphic();\r\n            });\r\n    } else {\r\n        zoomUsingGraphic();\r\n    }\r\n};\r\n\r\nonBeforeMount(() => {\r\n    // keep track of this watcher because it needs to be removed when this component is unmounted\r\n    watchers.value.push(\r\n        watch(\r\n            props,\r\n            () => {\r\n                // Something has changed, so re-fetch the icon.\r\n                itemChanged();\r\n            },\r\n            {\r\n                deep: false,\r\n                immediate: true\r\n            }\r\n        )\r\n    );\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n    watchers.value.forEach(unwatch => unwatch());\r\n});\r\n</script>\r\n\r\n<style lang=\"scss\" scoped></style>\r\n","<template>\r\n    <div\r\n        class=\"detailsContent relative flex flex-col flex-grow pl-5\"\r\n        :style=\"results.length > 1 ? { 'margin-left': '42px' } : ''\"\r\n        v-if=\"isLayerResultLoaded && activeGreedy === 0\"\r\n    >\r\n        <!-- layer name -->\r\n        <h1\r\n            class=\"layerName w-full flex-grow p-5 pb-8 font-bold truncate\"\r\n            v-if=\"layerExists\"\r\n            v-truncate=\"{ options: { placement: 'top-start' } }\"\r\n            tabIndex=\"0\"\r\n        >\r\n            {{ layerName }}\r\n        </h1>\r\n\r\n        <!-- highlight toggle -->\r\n        <div class=\"p-8 mb-8 bg-gray-100 flex justify-between\" v-if=\"canHighlight\">\r\n            <label for=\"toggle\">{{ t('details.togglehilight.title') }}</label>\r\n            <Toggle\r\n                :config=\"{\r\n                    value: hilightToggle,\r\n                    disabled: false\r\n                }\"\r\n                @toggled=\"onHilightToggle\"\r\n            ></Toggle>\r\n        </div>\r\n\r\n        <!-- paginator and list button for multiple features -->\r\n        <div class=\"flex flex-col justify-between p-8 mb-8 bg-gray-100\" v-if=\"showPaginator\">\r\n            <div class=\"flex\">\r\n                <button\r\n                    v-if=\"!showList\"\r\n                    type=\"button\"\r\n                    class=\"px-8 font-bold hover:bg-gray-200 focus:bg-gray-200\"\r\n                    :aria-label=\"t('details.item.see.list')\"\r\n                    @click=\"clickShowList()\"\r\n                >\r\n                    {{ t('details.item.see.list') }}\r\n                </button>\r\n                <div class=\"flex ml-auto bg-gray-200 py-8 items-center\" :class=\"{ 'w-full': showList }\">\r\n                    <button\r\n                        type=\"button\"\r\n                        :content=\"t(showList ? 'details.items.previous' : 'details.item.previous.item')\"\r\n                        v-tippy=\"{ placement: 'top' }\"\r\n                        @click=\"advanceItemIndex(-1)\"\r\n                        class=\"mx-2 opacity-60 hover:opacity-90 disabled:opacity-30 disabled:cursor-default\"\r\n                        :aria-label=\"t(showList ? 'details.items.previous' : 'details.item.previous.item')\"\r\n                        :disabled=\"currentIdx === 0\"\r\n                    >\r\n                        <svg height=\"24\" width=\"24\" viewBox=\"0 0 23 23\">\r\n                            <g>\r\n                                <path d=\"M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z\" />\r\n                            </g>\r\n                        </svg>\r\n                    </button>\r\n                    <span class=\"px-3 text-center flex-grow\">\r\n                        {{\r\n                            showList\r\n                                ? t('details.items.range', [\r\n                                      currentIdx + 1,\r\n                                      Math.min(endIdx, getLayerIdentifyItems().length),\r\n                                      getLayerIdentifyItems().length\r\n                                  ])\r\n                                : t('details.item.count', [currentIdx + 1, getLayerIdentifyItems().length])\r\n                        }}\r\n                    </span>\r\n                    <button\r\n                        type=\"button\"\r\n                        :content=\"t(showList ? 'details.items.next' : 'details.item.next.item')\"\r\n                        v-tippy=\"{ placement: 'top' }\"\r\n                        @click=\"advanceItemIndex(1)\"\r\n                        class=\"mx-2 rotate-180 opacity-60 hover:opacity-90 disabled:opacity-30 disabled:cursor-default\"\r\n                        :aria-label=\"t(showList ? 'details.items.next' : 'details.item.next.item')\"\r\n                        :disabled=\"\r\n                            (!showList && currentIdx === getLayerIdentifyItems().length - 1) ||\r\n                            (showList && endIdx >= getLayerIdentifyItems().length)\r\n                        \"\r\n                    >\r\n                        <svg height=\"24\" width=\"24\" viewBox=\"0 0 23 23\">\r\n                            <g>\r\n                                <path d=\"M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z\" />\r\n                            </g>\r\n                        </svg>\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <!-- details result, or result list -->\r\n        <div v-if=\"layerExists\">\r\n            <div v-if=\"getLayerIdentifyItems().length > 0\">\r\n                <div\r\n                    v-if=\"showList\"\r\n                    class=\"flex flex-col\"\r\n                    v-focus-list\r\n                    :content=\"t('details.layers.results.list.tooltip')\"\r\n                    v-tippy=\"{\r\n                        trigger: 'manual',\r\n                        placement: 'top-start',\r\n                        touch: false\r\n                    }\"\r\n                    ref=\"el\"\r\n                >\r\n                    <button\r\n                        class=\"flex flex-grow truncate default-focus-style hover:bg-gray-200\"\r\n                        v-for=\"(item, idx) in getLayerIdentifyItems().slice(currentIdx, endIdx)\"\r\n                        :key=\"idx\"\r\n                        @click=\"clickListItem(currentIdx + idx)\"\r\n                        v-focus-item=\"'show-truncate'\"\r\n                    >\r\n                        <ResultItem :data=\"item\" :uid=\"uid\" :open=\"false\" :in-list=\"true\"></ResultItem>\r\n                    </button>\r\n                </div>\r\n                <ResultItem :data=\"currentIdentifyItem\" :uid=\"uid\" :open=\"true\" :in-list=\"false\" v-else></ResultItem>\r\n            </div>\r\n            <div class=\"text-center\" v-else>\r\n                {{ t('details.layers.results.empty.currentLayer') }}\r\n            </div>\r\n        </div>\r\n        <!-- layer does not exist anymore, show no data text -->\r\n        <div v-else class=\"p-5\">\r\n            {{ t('details.item.no.data') }}\r\n        </div>\r\n    </div>\r\n\r\n    <!-- identified item is loading -->\r\n    <div v-else class=\"flex justify-center py-10 items-center\" :class=\"results.length > 1 ? 'ml-42' : ''\">\r\n        <span class=\"animate-spin spinner h-20 w-20 px-5 mr-8\"></span>\r\n        {{ t('details.item.loading') }}\r\n    </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\n// acts as the result container for a single layer's result set. Includes header controls,\r\n// and will render the list view if we're in that mode. If in single detail mode, it just\r\n// inserts a result-item under the header.\r\n\r\nimport { useLayerStore } from '@/stores/layer';\r\nimport { useI18n } from 'vue-i18n';\r\nimport type { DetailsAPI } from '../api/details';\r\nimport ResultItem from './result-item.vue';\r\nimport Toggle from '../../../components/controls/toggle-switch-control.vue';\r\n\r\nimport { GlobalEvents } from '@/api';\r\nimport type { IdentifyItem, IdentifyResult, InstanceAPI, LayerInstance, PanelInstance } from '@/api';\r\n\r\nimport type { BasemapChange } from '@/geo/api';\r\n\r\nimport { computed, inject, onMounted, onBeforeMount, onBeforeUnmount, ref, watch } from 'vue';\r\nimport type { PropType } from 'vue';\r\n\r\nimport { useDetailsStore } from '../store';\r\nimport type { DetailsItemInstance } from '../store';\r\n\r\nconst el = ref<Element>();\r\nconst blurEvent = () => {\r\n    (el.value as any)._tippy.hide();\r\n};\r\nconst keyupEvent = (e: Event) => {\r\n    const evt = e as KeyboardEvent;\r\n    if (evt.key === 'Tab' && el.value?.matches(':focus')) {\r\n        (el.value as any)._tippy.show();\r\n    }\r\n};\r\n\r\nconst iApi = inject<InstanceAPI>('iApi')!;\r\n\r\nconst detailsStore = useDetailsStore();\r\nconst layerStore = useLayerStore();\r\nconst props = defineProps({\r\n    uid: { type: String, required: true },\r\n    results: { type: Object as PropType<Array<IdentifyResult>>, required: true }\r\n});\r\nconst { t } = useI18n();\r\n\r\n/**\r\n * If we could find the bound layer in our instance\r\n */\r\nconst layerExists = ref<Boolean>(false);\r\n\r\n/**\r\n * Details fixture\r\n */\r\nconst detailsFixture = ref<DetailsAPI>(iApi.fixture.get('details'));\r\n\r\n/**\r\n * Value of the onscreen highlighter toggle control\r\n */\r\nconst hilightToggle = ref<boolean>(true);\r\n\r\n/**\r\n * If we are displaying list view or single item view\r\n */\r\nconst showList = ref<boolean>(false);\r\n\r\n/**\r\n * Index of the item we are displaying within the result's item array\r\n * Persists in list view\r\n */\r\nconst currentIdx = ref<number>(0);\r\n\r\n/**\r\n * Number of items to display at once in list view\r\n */\r\nconst itemsPerPage = ref<number>(20);\r\n\r\nconst handlers = ref<Array<string>>([]);\r\nconst watchers = ref<Array<Function>>([]);\r\n\r\nconst activeGreedy = computed<number>(() => detailsStore.activeGreedy);\r\nconst detailProperties = computed<{ [id: string]: DetailsItemInstance }>(() => detailsStore.properties);\r\nconst endIdx = computed<number>(() => currentIdx.value + itemsPerPage.value);\r\n\r\n/**\r\n * Return the LayerInstance that cooresponds with the UID provided in props.\r\n */\r\nconst getBoundLayer = () => {\r\n    return layerStore.getLayerByUid(props.uid);\r\n};\r\n\r\n/**\r\n * Find the layer result object for the bound layer, if exists\r\n */\r\nconst getBoundLayerResult = (): IdentifyResult | undefined => {\r\n    return props.results.find(layerIR => {\r\n        return layerIR.uid === props.uid;\r\n    });\r\n};\r\n\r\n/**\r\n * Computed property that returns true if the layer's overall identify result has loaded.\r\n */\r\nconst isLayerResultLoaded = computed<Boolean>(() => {\r\n    const results = getBoundLayerResult();\r\n    return results?.loaded ?? false;\r\n});\r\n\r\nconst itemRequestTime = computed<Number | undefined>(() => {\r\n    const results = getBoundLayerResult();\r\n    return results?.requestTime;\r\n});\r\n\r\nconst showPaginator = computed<boolean>(\r\n    () =>\r\n        layerExists.value &&\r\n        ((!showList.value && getLayerIdentifyItems().length > 1) ||\r\n            (showList.value && getLayerIdentifyItems().length > itemsPerPage.value))\r\n);\r\n\r\nconst layerName = computed<string>(() => {\r\n    const layer = getBoundLayer();\r\n\r\n    if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].name) {\r\n        return detailProperties.value[layer.id].name;\r\n    }\r\n    return layer?.name ?? '';\r\n});\r\n\r\n/**\r\n * Lets us watch() the uid\r\n */\r\nconst uidCompute = computed<string>(() => {\r\n    return props.uid;\r\n});\r\n\r\n/**\r\n * Retrieves the identify items that belong to the layer currently bound to this list.\r\n * If there are no results, returns an empty array.\r\n */\r\nconst getLayerIdentifyItems = () => {\r\n    const results = getBoundLayerResult();\r\n\r\n    return results ? results.items : [];\r\n};\r\n\r\n/**\r\n * Computed property that returns the identify item currently being viewed.\r\n * In list mode, this returns last item viewed in detail view (defaults to first).\r\n * If no results, returns undefined\r\n */\r\nconst currentIdentifyItem = computed<IdentifyItem>(() => {\r\n    return getLayerIdentifyItems()[currentIdx.value];\r\n});\r\n\r\n/**\r\n * Computed property that indicates if highlighting is a possibility\r\n */\r\nconst canHighlight = computed<Boolean>(() => {\r\n    if (detailsFixture.value.hasHilighter()) {\r\n        const layer = getBoundLayer();\r\n        if (layer) {\r\n            return layer.mapLayer && layer.supportsFeatures;\r\n        }\r\n    }\r\n    return false;\r\n});\r\n\r\n/**\r\n * Event handler for the UI highlight toggle. Toggles highlight on data points.\r\n * @param value the value to assign the highlight\r\n */\r\nconst onHilightToggle = (value: boolean) => {\r\n    // change control state, remember in store, update any highlighting\r\n\r\n    hilightToggle.value = value;\r\n    detailsStore.hilightToggle = value;\r\n    updateHighlight();\r\n};\r\n\r\n/**\r\n * Initialize the details screen\r\n */\r\nconst initDetails = () => {\r\n    const layer = getBoundLayer();\r\n\r\n    currentIdx.value = currentIdx.value ?? 0;\r\n    hilightToggle.value = detailsStore.hilightToggle ?? hilightToggle.value;\r\n    showList.value = false;\r\n\r\n    // could not find this layer, so mark this result as invalid\r\n    // this handles the case where user minimized item screen -> deletes layer -> opens item screen again\r\n    layerExists.value = !!layer;\r\n\r\n    updateHighlight();\r\n};\r\n\r\n/**\r\n * Advance the item index by direction (an integer). Singular in detail mode, by a page in list mode\r\n */\r\nconst advanceItemIndex = (direction: number) => {\r\n    if (showList.value) {\r\n        currentIdx.value += direction * itemsPerPage.value;\r\n        updateHighlight();\r\n    } else {\r\n        currentIdx.value += direction;\r\n    }\r\n};\r\n\r\n/**\r\n * Updates the highlighter when something changes (panel minimized, opened, change in selected result, etc.)\r\n */\r\nconst updateHighlight = () => {\r\n    /*\r\n    Dev notes for paths that hit this method, since its a bit spicey.\r\n    currentIdentifyItem watcher -> initDetails : handles changes in the details view of an item.\r\n        includes initial load, layer change, item pagination. Anything that isn't in list mode.\r\n    uidCompute watcher : handles a new layer being selected and we are in list mode.\r\n    advanceItemIndex : handles pagination change when in list mode\r\n    onHilightToggle : handles user mashing the toggler button\r\n    clickShowList : handles user going from detail view to list view on same layer\r\n    clickListItem : handles weird scenario where user clicks first (top) item in list view to switch to its detail view\r\n    BASEMAP_CHANGE event : handles re-applying hilight if schema changed\r\n    */\r\n\r\n    const resultItems = getLayerIdentifyItems();\r\n\r\n    if (hilightToggle.value && isLayerResultLoaded.value && resultItems.length > 0 && canHighlight.value) {\r\n        // we are highlighting, and there is something that could be hilighted.\r\n        // the hilightDetailsItems will handle the waiting for items to finish loading, as well as ensuring\r\n        // that any stale loads will not be drawn / removed when users spam their highlights real fast.\r\n\r\n        if (showList.value) {\r\n            // highlight what is on current page of the list.\r\n            detailsFixture.value.hilightDetailsItems(resultItems.slice(currentIdx.value, endIdx.value), props.uid);\r\n        } else {\r\n            // highlight current item being displayed.\r\n            // being extra careful just incase our index went beyond the array bounds\r\n            const currItem = resultItems[currentIdx.value];\r\n            if (currItem) {\r\n                detailsFixture.value.hilightDetailsItems([currItem], props.uid);\r\n            }\r\n        }\r\n    } else {\r\n        // nothing to hilight. This ensures any old details highlights get wiped\r\n        detailsFixture.value.removeDetailsHilight();\r\n    }\r\n};\r\n\r\n/**\r\n * Called when the `Show List` button is pressed. Enables list view and sets highlight to show\r\n * all items in the list.\r\n */\r\nconst clickShowList = () => {\r\n    showList.value = true;\r\n\r\n    currentIdx.value = Math.floor(currentIdx.value / itemsPerPage.value) * itemsPerPage.value;\r\n    updateHighlight();\r\n};\r\n\r\n/**\r\n * Clean up for when the details screen is closed.\r\n */\r\nconst detailsClosed = () => {\r\n    detailsFixture.value.removeDetailsHilight();\r\n\r\n    // (JR) commenting this out. if user turns off toggle, it shouldnt reset back to on when screen closes.\r\n    // detailsStore.hilightToggle = true;\r\n};\r\n\r\n/**\r\n * Clean up for when the details screen is minimized.\r\n */\r\nconst detailsMinimized = () => {\r\n    detailsFixture.value.removeDetailsHilight();\r\n};\r\n\r\n/**\r\n * Called when an item in the list is clicked. Disables list view and updates highlight.\r\n * @param idx the index of the point that was clicked.\r\n */\r\nconst clickListItem = (idx: number) => {\r\n    const secretIdx = currentIdx.value;\r\n    currentIdx.value = idx;\r\n    showList.value = false;\r\n    if (secretIdx === idx) {\r\n        // we clicked on the row that currentIdx was secretly tracking.\r\n        // as such, the watcher on the current item won't trigger, so\r\n        // need to update the highlight\r\n        updateHighlight();\r\n    }\r\n};\r\n\r\nonMounted(() => {\r\n    // close this panel if layer is removed\r\n    handlers.value.push(\r\n        iApi.event.on(GlobalEvents.LAYER_REMOVE, (removedLayer: LayerInstance) => {\r\n            const detailsPanel = iApi.panel.get('details');\r\n            if (props.uid === removedLayer.uid && !!detailsPanel) {\r\n                detailsPanel.close();\r\n            }\r\n        })\r\n    );\r\n\r\n    handlers.value.push(\r\n        iApi.event.on(GlobalEvents.PANEL_CLOSED, (panel: PanelInstance) => {\r\n            if (panel.id === 'details') {\r\n                detailsClosed();\r\n            }\r\n        })\r\n    );\r\n\r\n    handlers.value.push(\r\n        iApi.event.on(GlobalEvents.PANEL_MINIMIZED, (panel: PanelInstance) => {\r\n            if (panel.id === 'details') {\r\n                detailsMinimized();\r\n            }\r\n        })\r\n    );\r\n\r\n    handlers.value.push(\r\n        iApi.event.on(GlobalEvents.MAP_BASEMAPCHANGE, (payload: BasemapChange) => {\r\n            if (hilightToggle.value && payload.schemaChanged) {\r\n                // will just wipe and re-apply the highlight\r\n                updateHighlight();\r\n            }\r\n        })\r\n    );\r\n\r\n    el.value?.addEventListener('blur', blurEvent);\r\n    el.value?.addEventListener('keyup', keyupEvent);\r\n});\r\n\r\nonBeforeMount(() => {\r\n    // Keep an eye to see if the currently selected identify item has been changed.\r\n    // Use a watcher to account for the async nature of results appearing in the\r\n    // IdentifyItems object\r\n    watchers.value.push(\r\n        watch(\r\n            currentIdentifyItem,\r\n            () => {\r\n                // ignore stuff in list mode. we manually work the highlights in that mode.\r\n                if (!showList.value) {\r\n                    // Re-initialize the details panel if the content has changed.\r\n                    initDetails();\r\n\r\n                    // If the identifyItem is undefined, clear any hilights.\r\n                    // this occurs when the bound layer has no results.\r\n                    if (currentIdentifyItem.value === undefined) {\r\n                        detailsFixture.value.removeDetailsHilight();\r\n                    }\r\n                }\r\n            },\r\n            {\r\n                deep: false,\r\n                immediate: true\r\n            }\r\n        )\r\n    );\r\n\r\n    // handle the case where the layer changes and we are in list mode.\r\n    // that change comes from `details-screen.vue` updating the props of this component,\r\n    // to there is no \"manual update\" of the highlight from local button event handlers.\r\n    watchers.value.push(\r\n        watch(\r\n            uidCompute,\r\n            () => {\r\n                const localUid = props.uid;\r\n\r\n                if (showList.value && localUid) {\r\n                    // we're in list mode, and a valid layer is linked\r\n\r\n                    // find layer result, wait for outer request to finish (need items to pass to hilighter)\r\n                    const layerIR = getBoundLayerResult();\r\n                    if (layerIR) {\r\n                        layerIR.loading.then(() => {\r\n                            if (props.uid === localUid && showList.value) {\r\n                                // Still on the same layer. User didn't pick diff layer during the loading wait.\r\n                                // Still in list mode. User didn't pick diff layer, change to detail mode, then come back.\r\n                                //\r\n                                // If user switches to a different layer, stays in list mode, and comes back to this prior to either layer being loaded,\r\n                                // will probably get a double hilight request on this layer (first visit & second vist resolve at same time),\r\n                                // but will just spam warnings on the console. Requires slow layers and fidgity user.\r\n                                // If we really don't like that, need to think of some wilder solution to track async stuff across components.\r\n\r\n                                updateHighlight();\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            },\r\n            {\r\n                deep: false,\r\n                immediate: true\r\n            }\r\n        )\r\n    );\r\n\r\n    // If a new request is made, reset the index.\r\n    watchers.value.push(\r\n        watch(itemRequestTime, () => {\r\n            currentIdx.value = 0;\r\n        })\r\n    );\r\n\r\n    // Similarily to above, if a new layer is selected, reset the index.\r\n    watchers.value.push(\r\n        watch(\r\n            () => props.uid,\r\n            () => {\r\n                currentIdx.value = 0;\r\n            }\r\n        )\r\n    );\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n    // clean up hooks into various events.\r\n    watchers.value.forEach(unwatch => unwatch());\r\n    handlers.value.forEach(handler => iApi.event.off(handler));\r\n\r\n    el.value?.removeEventListener('blur', blurEvent);\r\n    el.value?.removeEventListener('keyup', keyupEvent);\r\n});\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n.layerName {\r\n    border-bottom: 1px solid #eee;\r\n}\r\n</style>\r\n","<template>\r\n    <panel-screen :panel=\"panel\">\r\n        <template #header>\r\n            {{\r\n                // Show different titles based on what requested the panel\r\n                detailsStore.origin === 'toggleEvent'\r\n                    ? t('details.layers.title.gridOrigin')\r\n                    : t('details.layers.title.identifyOrigin')\r\n            }}\r\n        </template>\r\n\r\n        <template #content>\r\n            <div class=\"relative h-full\">\r\n                <!-- Layer Picker, symbology stacks -->\r\n                <SymbologyList\r\n                    :results=\"layerResults\"\r\n                    :detailsProperties=\"detailProperties\"\r\n                    :selected=\"selectedLayer\"\r\n                    @selection-changed=\"changeLayerSelection\"\r\n                    v-if=\"layerResults.length > 1\"\r\n                ></SymbologyList>\r\n\r\n                <!-- Main Details Panel -->\r\n                <div class=\"detailsContentSection overflow-y-auto h-full\">\r\n                    <ResultList :uid=\"selectedLayer\" :results=\"layerResults\" v-if=\"!noResults\"></ResultList>\r\n                    <div :class=\"['text-center', { 'ml-42': layerResults.length > 1 }]\" v-else>\r\n                        {{\r\n                            layerResults.length >= 1\r\n                                ? t('details.layers.results.empty')\r\n                                : t('details.layers.results.empty.noLayers')\r\n                        }}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </template>\r\n    </panel-screen>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { computed, onBeforeMount, onBeforeUnmount, ref, inject, watch } from 'vue';\r\n\r\nimport SymbologyList from './components/symbology-list.vue';\r\nimport ResultList from './components/result-list.vue';\r\n\r\nimport type { PropType } from 'vue';\r\nimport type { IdentifyResult, InstanceAPI, PanelInstance } from '@/api';\r\nimport type { DetailsItemInstance } from './store';\r\n\r\nimport { useI18n } from 'vue-i18n';\r\nimport { useDetailsStore } from './store';\r\n\r\nconst { t } = useI18n();\r\nconst iApi = inject<InstanceAPI>('iApi')!;\r\nconst detailsStore = useDetailsStore();\r\n\r\nconst handlers = ref<Array<string>>([]);\r\nconst watchers = ref<Array<Function>>([]);\r\nconst layerResults = ref<Array<IdentifyResult>>([]);\r\nconst noResults = ref<boolean>(false);\r\n\r\n/**\r\n * UID of the layer \"selected\" into the detail/list section. Empty string when panel is freshly opened.\r\n */\r\nconst selectedLayer = ref<string>('');\r\n\r\n/**\r\n * Contains the timestamp of the most recent payload. 0 if we are not watching for a greedy open\r\n */\r\nconst activeGreedy = computed<number>(() => detailsStore.activeGreedy);\r\nconst payload = computed<IdentifyResult[]>(() => detailsStore.payload);\r\nconst detailProperties = computed<{ [id: string]: DetailsItemInstance }>(() => detailsStore.properties);\r\n\r\ndefineProps({\r\n    panel: {\r\n        type: Object as PropType<PanelInstance>\r\n    }\r\n});\r\n\r\n/**\r\n * Handles user picking a new layer from the \"symbol stack\" list\r\n */\r\nconst changeLayerSelection = (uid: string) => {\r\n    selectedLayer.value = uid;\r\n};\r\n\r\n/**\r\n * Finds the result object for a layer uid, or undefined if no result exists\r\n * @param uid logical layer uid\r\n */\r\nconst findLayerResult = (uid: string): IdentifyResult | undefined => layerResults.value.find(item => item.uid === uid);\r\n\r\n/**\r\n * Intake a new identify result set, initiate auto-open logic.\r\n */\r\nconst loadPayloadItems = (newPayload: Array<IdentifyResult>): void => {\r\n    // NOTE: the incoming payload array needs to be made reactive at the source,\r\n    // i.e. in the layer that ran the identify and created this stuff.\r\n    // Not ideal. Have tried a number of workarounds but vue remains\r\n    // disrespectful in ignoring changes to array elements and updating\r\n    // controls in the template v-for's.\r\n    // I think the reason is because a promise that lives outside of\r\n    // the component is updating values, and the vue reactivity magic\r\n    // is not registering it in the dependency graph thing. Still don't know\r\n    // enough to say for sure.\r\n    // The alternative is to use $forceUpdate, which works but seems less\r\n    // efficient and sort of defeats the purpose of using a framework with\r\n    // \"smart\" two way binding.\r\n    // Tried making a reactive copy of elements here that would watch\r\n    // the original elements and update itself, would work for the\r\n    // IdentifyResults but the nested IdentifyItems would still break.\r\n    // It was also a big hack.\r\n    // Would like to revist, as this current solution is unintuitive,\r\n    // nobody writing a new layer type is going to have a clue they need\r\n    // to wrap their identify outputs in reactive() due to disrespectful code.\r\n\r\n    // if no payload, just return\r\n    if (newPayload === undefined) {\r\n        return;\r\n    }\r\n\r\n    // track last identify request timestamp and add to payload items. If no new results,\r\n    // disable the greedy identify.\r\n    detailsStore.activeGreedy = newPayload.length === 0 ? 0 : newPayload[0].requestTime;\r\n\r\n    layerResults.value = newPayload;\r\n\r\n    autoOpen(newPayload);\r\n};\r\n\r\n/**\r\n * Auto-selects which layer to show in the detail section when a new payload of identify results arrive.\r\n *\r\n * 1. If a layer is already the active layer in the details view, we wait for it to report its findings.\r\n *    If it has a result, it remains the active layer.\r\n * 2. If no active layer (freshly opened panel or old active layer was deleted), or the active layer had\r\n *    no results in 1., we then watch identify results for all candidate layers. First layer to report\r\n *    a hit becomes the active layer.\r\n */\r\nconst autoOpen = (newPayload: Array<IdentifyResult>): void => {\r\n    // if the detail panel is already showing details of a specific layer,\r\n    // wait on that layer to resolve first\r\n    if (selectedLayer.value) {\r\n        const selectedResult = findLayerResult(selectedLayer.value);\r\n\r\n        if (selectedResult) {\r\n            // wait on the currently selected layer to see if it resolves with new results\r\n            selectedResult.loading.then(() => {\r\n                // new identify request came in while loading old results, exit greedy algo\r\n                if (selectedResult.requestTime !== activeGreedy.value) {\r\n                    return;\r\n                }\r\n\r\n                if (selectedResult.items.length > 0) {\r\n                    // got a hit. update items screen with new results and turn off greedy loading\r\n                    detailsStore.activeGreedy = 0;\r\n                    noResults.value = false;\r\n                } else {\r\n                    // current layer has no hits, fall back to examining all.\r\n                    autoOpenAny(newPayload);\r\n                }\r\n            });\r\n        } else {\r\n            // last opened layer no longer exists, proceed examine all layers\r\n            autoOpenAny(newPayload);\r\n        }\r\n    } else {\r\n        // panel was freshly opened. show first layer with results\r\n        autoOpenAny(newPayload);\r\n    }\r\n};\r\n\r\n/**\r\n * Will watch all the result items. First layer to resolve with a valid result will become\r\n * the active layer in the details view.\r\n *\r\n * @param newPayload the identify result payload we're watching\r\n * @param priorityStack helper param for priority recursion. Is omitted on initial call\r\n */\r\nconst autoOpenAny = (newPayload: Array<IdentifyResult>, priorityStack?: Array<[number, Array<string>]>): void => {\r\n    /**\r\n     * Array of [priority, [layerIds]], sorted by highest to lowest priority value (low number goes first)\r\n     */\r\n    let priStack: Array<[number, Array<string>]>;\r\n    if (priorityStack) {\r\n        // recursive call, use previously generated stack\r\n        priStack = priorityStack;\r\n    } else {\r\n        const layerDetailsConfigs = detailsStore.properties;\r\n\r\n        // list of [priority, layerId]\r\n        const layerPriorities = newPayload.map((idRes): [number, string] => [\r\n            (layerDetailsConfigs[idRes.layerId]?.priority as number) ?? 50,\r\n            idRes.layerId\r\n        ]);\r\n        // create set of distinct priority values\r\n        const setMagic = new Set(layerPriorities.map(lp => lp[0]));\r\n        priStack = [];\r\n        // group layer ids by priority value\r\n        setMagic.forEach(uniquePriority => {\r\n            const matchingLayerIds = layerPriorities.filter(lp => lp[0] === uniquePriority).map(lp => lp[1]);\r\n            priStack.push([uniquePriority, matchingLayerIds]);\r\n        });\r\n        // sort by priority value in descending order\r\n        priStack.sort((a, b) => b[0] - a[0]);\r\n    }\r\n\r\n    if (priStack.length === 0) {\r\n        // handles case of no identifiable layers (either from initial conditions, or all priorities have been popped).\r\n        // Stop & exit.\r\n        detailsStore.activeGreedy = 0;\r\n        noResults.value = true;\r\n        return;\r\n    }\r\n\r\n    // watch the priority layers\r\n    const currentPriorites = priStack[priStack.length - 1][1];\r\n    const loadingResults = newPayload\r\n        .filter(payloadIR => currentPriorites.includes(payloadIR.layerId))\r\n        .map(payloadIR =>\r\n            payloadIR.loading.then(() => (payloadIR.items.length > 0 ? Promise.resolve(payloadIR) : Promise.reject()))\r\n        );\r\n    const lastTime = newPayload.length === 0 ? 0 : newPayload[0].requestTime;\r\n\r\n    // wait on any layer promise to resolve first with new identify results\r\n    Promise.any(loadingResults)\r\n        .then(winningResult => {\r\n            // new identify request came in while loading old results, exit greedy algo\r\n            if (winningResult.requestTime !== activeGreedy.value) {\r\n                return;\r\n            }\r\n\r\n            // open results item screen and turn off greedy loading\r\n            detailsStore.activeGreedy = 0;\r\n            selectedLayer.value = winningResult.uid;\r\n            noResults.value = false;\r\n        })\r\n        .catch(() => {\r\n            if (lastTime === activeGreedy.value) {\r\n                // this process is still the active greedy result.\r\n                // try next priority bucket. recursive call will also handle the no-result empty array case\r\n                priStack.pop();\r\n                autoOpenAny(newPayload, priStack);\r\n            }\r\n        });\r\n};\r\n\r\n/* Vue Lifecycle Functions */\r\n\r\nonBeforeMount(() => {\r\n    // keep track of this watcher because it needs to be removed when this component is unmounted\r\n    watchers.value.push(\r\n        watch(\r\n            payload,\r\n            (newPayload: Array<IdentifyResult>) => {\r\n                // Reload items\r\n                loadPayloadItems(newPayload);\r\n            },\r\n            {\r\n                deep: false, // was true when our array had undefineds. now that objects arrive intact, we dont want this triggering when innards update\r\n                immediate: true\r\n            }\r\n        )\r\n    );\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n    handlers.value.forEach(handler => iApi.event.off(handler));\r\n    watchers.value.forEach(unwatch => unwatch());\r\n});\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n.detailsContentSection {\r\n    padding-right: 8px;\r\n    margin-right: -8px;\r\n}\r\n</style>\r\n"],"names":["props","__props","stack","ref","onMounted","detailsStore","useDetailsStore","detailProperties","computed","layerName","layer","t","useI18n","layerStore","useLayerStore","el","blurEvent","keyupEvent","e","emit","__emit","selectedLayer","watchers","expanded","hovering","getLayerInfo","uid","handleItemClick","handleMouseOver","handleMouseLeave","handleItemFocus","handleItemBlur","onBeforeMount","watch","onBeforeUnmount","unwatch","iApi","inject","findAndDelete","fields","propertyType","property","helper","field","f","itemData","clonePayload","fieldsMetadata","checkField","item","displayMetadata","key","fieldMD","cloneValue","formatValues","html","alias","type","makeDate","makeHtmlLink","classes","div","linkifyHtml","value","numericDate","icon","zoomStatus","zoomButton","defaultTemplates","supportsFeatures","isMapLayer","itemName","nameField","returnValue","itemChanged","updateZoomStatus","fetchIcon","oidField","detailsTemplate","ESRIDefault","HTMLDefault","fieldsList","fixtureFields","zoomToFeature","oid","zoomUsingGraphic","opts","g","LayerType","GeometryType","layerExists","detailsFixture","hilightToggle","showList","currentIdx","itemsPerPage","handlers","activeGreedy","endIdx","getBoundLayer","getBoundLayerResult","layerIR","isLayerResultLoaded","itemRequestTime","showPaginator","getLayerIdentifyItems","uidCompute","results","currentIdentifyItem","canHighlight","onHilightToggle","updateHighlight","initDetails","advanceItemIndex","direction","resultItems","currItem","clickShowList","detailsClosed","detailsMinimized","clickListItem","idx","secretIdx","GlobalEvents","removedLayer","detailsPanel","panel","payload","localUid","handler","layerResults","noResults","changeLayerSelection","findLayerResult","loadPayloadItems","newPayload","autoOpen","selectedResult","autoOpenAny","priorityStack","priStack","layerDetailsConfigs","layerPriorities","idRes","setMagic","lp","uniquePriority","matchingLayerIds","a","b","currentPriorites","loadingResults","payloadIR","lastTime","winningResult"],"mappings":"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"}