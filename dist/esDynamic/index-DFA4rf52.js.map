{"version":3,"file":"index-DFA4rf52.js","sources":["../../src/fixtures/wizard/api/wizard.ts","../../src/fixtures/wizard/store/layer-source.ts","../../src/fixtures/wizard/lang/lang.csv?raw","../../src/fixtures/wizard/index.ts"],"sourcesContent":["import { FixtureInstance } from '@/api';\r\n\r\nexport class WizardAPI extends FixtureInstance {\r\n    /**\r\n     * Opens or closes the wizard fixture panel\r\n     *\r\n     * @memberof WizardAPI\r\n     * @param open force panel open or closed\r\n     */\r\n    toggleWizard(open?: boolean): void {\r\n        const panel = this.$iApi.panel.get('wizard');\r\n        this.$iApi.panel.toggle(panel, open);\r\n    }\r\n}\r\n","import { LayerType } from '@/geo/api';\r\nimport type { FieldDefinition, RampLayerConfig } from '@/geo/api';\r\nimport { APIScope, InstanceAPI } from '@/api/internal';\r\nimport { UrlWrapper } from '@/geo/api';\r\nimport axios from 'redaxios';\r\n\r\nexport interface LayerInfo {\r\n    config: RampLayerConfig; // the layer's config\r\n    configOptions: Array<string>; // the layer's config options that will be taken from user input in the UI\r\n    fields?: Array<FieldDefinition>; // the fields for the layer\r\n    latLonFields?: { lat: Array<string>; lon: Array<string> }; // lat and lon are a list of field names that can be possible lat/lon fields\r\n    layers?: Array<SublayerInfo>; // a nested list of info for the parent layer, sublayer groups, and sublayers. Only defined for MIL/WMS\r\n    layersRaw?: [];\r\n}\r\n\r\nexport interface SublayerInfo {\r\n    id: number | string;\r\n    label: string;\r\n    children: Array<number | string> | undefined;\r\n}\r\n\r\nexport class LayerSource extends APIScope {\r\n    layerCount = 0;\r\n    sublayerCount = 0;\r\n\r\n    constructor($iApi: InstanceAPI) {\r\n        super($iApi);\r\n    }\r\n\r\n    /**\r\n     * Get layer info from a file url or data\r\n     *\r\n     * @param {string} url a service url to load, name of file if file data is provided\r\n     * @param {string} fileType format of the file (layer type)\r\n     * @param {ArrayBuffer} [fileData] raw file data buffer\r\n     * @returns {Promise<LayerInfo | undefined>} LayerInfo object\r\n     */\r\n    async fetchFileInfo(url: string, fileType: LayerType, fileData?: ArrayBuffer): Promise<LayerInfo | undefined> {\r\n        if (!fileData) {\r\n            // if given a url, load data so we can get fields\r\n            fileData = await this.$iApi.geo.layer.files.fetchFileData(url, fileType);\r\n        }\r\n\r\n        switch (fileType) {\r\n            case LayerType.GEOJSON:\r\n                return this.getGeojsonInfo(url, fileData!);\r\n            case LayerType.SHAPEFILE:\r\n                return this.getShapfileInfo(url, fileData!);\r\n            case LayerType.CSV:\r\n                return this.getCsvInfo(url, fileData!);\r\n            default:\r\n                console.error(`Unsupported file type passed to fetchFileInfo - '${fileType}'`);\r\n        }\r\n    }\r\n\r\n    async getGeojsonInfo(url: string, fileData: ArrayBuffer | object): Promise<LayerInfo> {\r\n        if (fileData instanceof ArrayBuffer) {\r\n            fileData = JSON.parse(new TextDecoder('utf-8').decode(new Uint8Array(fileData)));\r\n        }\r\n\r\n        const config = {\r\n            id: `geojson#${++this.layerCount}`,\r\n            layerType: LayerType.GEOJSON,\r\n            url,\r\n            name: url.substring(url.lastIndexOf('/') + 1),\r\n            state: { opacity: 1, visibility: true },\r\n            rawData: fileData\r\n        };\r\n\r\n        return {\r\n            config,\r\n            fields: [{ name: 'OBJECTID', type: 'oid' }].concat(\r\n                this.$iApi.geo.layer.files.extractGeoJsonFields(fileData)\r\n            ),\r\n            configOptions: ['name', 'nameField', 'tooltipField', 'colour']\r\n        };\r\n    }\r\n\r\n    async getCsvInfo(url: string, fileData: ArrayBuffer | string): Promise<LayerInfo> {\r\n        if (fileData instanceof ArrayBuffer) {\r\n            fileData = new TextDecoder('utf-8').decode(new Uint8Array(fileData));\r\n        }\r\n        const config = {\r\n            id: `csv#${++this.layerCount}`,\r\n            layerType: LayerType.CSV,\r\n            url,\r\n            name: url.substring(url.lastIndexOf('/') + 1),\r\n            state: { opacity: 1, visibility: true },\r\n            rawData: fileData\r\n        };\r\n\r\n        return {\r\n            config,\r\n            fields: [{ name: 'OBJECTID', type: 'oid' }].concat(this.$iApi.geo.layer.files.extractCsvFields(fileData)),\r\n            latLonFields: this.$iApi.geo.layer.files.filterCsvLatLonFields(fileData),\r\n            configOptions: ['name', 'nameField', 'tooltipField', 'latField', 'longField', 'colour']\r\n        };\r\n    }\r\n\r\n    async getShapfileInfo(url: string, fileData: ArrayBuffer): Promise<LayerInfo> {\r\n        const jsonData = await this.$iApi.geo.layer.files.shapefileToGeoJson(fileData);\r\n\r\n        return this.getGeojsonInfo(url, jsonData);\r\n    }\r\n\r\n    /**\r\n     * Get layer info from a service url\r\n     *\r\n     * @param {string} url a service url to load\r\n     * @param {string} serviceType type of layer\r\n     * @returns {Promise<LayerInfo | undefined>} LayerInfo object\r\n     */\r\n    async fetchServiceInfo(url: string, serviceType: string, nested: boolean): Promise<LayerInfo | undefined> {\r\n        switch (serviceType) {\r\n            case LayerType.FEATURE:\r\n                return this.getFeatureInfo(url);\r\n            case LayerType.MAPIMAGE:\r\n                return this.getMapImageInfo(url, nested);\r\n            case LayerType.TILE:\r\n                return this.getTileInfo(url);\r\n            case LayerType.IMAGERY:\r\n                return this.getImageryInfo(url);\r\n            case LayerType.WFS:\r\n                return this.getWfsInfo(url);\r\n            case LayerType.WMS:\r\n                return this.getWmsInfo(url, nested);\r\n        }\r\n    }\r\n\r\n    async getFeatureInfo(url: string): Promise<LayerInfo> {\r\n        const response = await axios.get(url, { params: { f: 'json' } });\r\n\r\n        const config = {\r\n            id: `${LayerType.FEATURE}#${++this.layerCount}`,\r\n            url: url,\r\n            layerType: LayerType.FEATURE,\r\n            name: response.data.name,\r\n            nameField: response.data.displayField,\r\n            tooltipField: response.data.displayField,\r\n            state: { opacity: 1, visibility: true }\r\n        };\r\n\r\n        return {\r\n            config,\r\n            fields: response.data.fields,\r\n            configOptions: ['name', 'nameField', 'tooltipField']\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets MIL data from source, formats it as a tree, and returns a promise of the data with configuration\r\n     *\r\n     * @param {string} url\r\n     * @returns {Promise<LayerInfo>} data configuration\r\n     */\r\n    async getMapImageInfo(url: string, nested: boolean): Promise<LayerInfo> {\r\n        const response = await axios.get(url, { params: { f: 'json' } });\r\n        const config = {\r\n            id: `${LayerType.MAPIMAGE}#${++this.layerCount}`,\r\n            url: url,\r\n            layerType: LayerType.MAPIMAGE,\r\n            name: response.data.mapName,\r\n            sublayers: [],\r\n            state: { opacity: 1, visibility: true }\r\n        };\r\n\r\n        return {\r\n            config,\r\n            layers: this.createLayerHierarchy(response.data.layers, nested),\r\n            configOptions: ['name', 'sublayers'],\r\n            layersRaw: response.data.layers\r\n        };\r\n    }\r\n\r\n    createLayerHierarchy(layers: any[], nested: boolean) {\r\n        // avoid case of disordered layers from endpoint\r\n        layers.sort((l1: any, l2: any) => l1.id - l2.id);\r\n\r\n        // traverses the layer tree to insert child layers\r\n        const findParent = (id: number, sublayers: Array<any>): any => {\r\n            if (sublayers === undefined) {\r\n                return false;\r\n            }\r\n            let parent;\r\n            if (sublayers.find(sl => sl.id === id)) {\r\n                return sublayers.find(sl => sl.id === id);\r\n            } else {\r\n                for (const sublayer of sublayers) {\r\n                    parent = findParent(id, sublayer.children);\r\n                    if (parent !== false) {\r\n                        return parent;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n        };\r\n\r\n        const opts: Array<SublayerInfo> = [];\r\n\r\n        const parentIds = new Set(\r\n            layers.filter(layer => layer.subLayerIds && layer.subLayerIds.length > 0).map(layer => layer.id)\r\n        );\r\n\r\n        for (const layer of layers) {\r\n            if (nested && layer.parentLayerId === -1) {\r\n                opts.push({\r\n                    id: layer.id,\r\n                    label: layer.name,\r\n                    children: layer.subLayerIds ? [] : undefined\r\n                });\r\n            } else if (nested) {\r\n                const parentLayer = findParent(layer.parentLayerId, opts);\r\n                parentLayer.children = [\r\n                    ...parentLayer.children,\r\n                    {\r\n                        id: layer.id,\r\n                        label: layer.name,\r\n                        children: layer.subLayerIds ? [] : undefined\r\n                    }\r\n                ];\r\n            } else if (!parentIds.has(layer.id)) {\r\n                opts.push({\r\n                    id: layer.id,\r\n                    label: layer.name,\r\n                    children: undefined\r\n                });\r\n            }\r\n        }\r\n\r\n        return opts;\r\n    }\r\n\r\n    async getTileInfo(url: string): Promise<LayerInfo> {\r\n        const response = await axios.get(url, { params: { f: 'json' } });\r\n\r\n        const config = {\r\n            id: `${LayerType.TILE}#${++this.layerCount}`,\r\n            url: url,\r\n            layerType: LayerType.TILE,\r\n            name: response.data.mapName,\r\n            state: { opacity: 1, visibility: true }\r\n        };\r\n\r\n        return {\r\n            config,\r\n            configOptions: ['name']\r\n        };\r\n    }\r\n\r\n    async getImageryInfo(url: string): Promise<LayerInfo> {\r\n        const response = await axios.get(url, { params: { f: 'json' } });\r\n\r\n        const config = {\r\n            id: `${LayerType.IMAGERY}#${++this.layerCount}`,\r\n            url: url,\r\n            layerType: LayerType.IMAGERY,\r\n            name: response.data.name,\r\n            state: { opacity: 1, visibility: true }\r\n        };\r\n\r\n        return {\r\n            config,\r\n            configOptions: ['name']\r\n        };\r\n    }\r\n\r\n    async getWfsInfo(url: string): Promise<LayerInfo> {\r\n        // get wfs data here then load as geojson layer so we can get fields\r\n        const wrapper = new UrlWrapper(url);\r\n        const { offset, limit } = wrapper.queryMap;\r\n        const wfsJson = await this.$iApi.geo.layer.ogc.loadWfsData(\r\n            url,\r\n            -1,\r\n            parseInt(offset) || 0,\r\n            parseInt(limit) || 1000\r\n        );\r\n\r\n        return this.getGeojsonInfo(url.match(/\\/([^/]+)\\/items/)?.[1] || 'Layer', wfsJson);\r\n    }\r\n\r\n    /**\r\n     * Gets WMS data from source, formats it, and returns a promise of the data with configuration\r\n     *\r\n     * @param {string} url\r\n     * @returns {Promise<LayerInfo>} data configuration\r\n     */\r\n    async getWmsInfo(url: string, nested: boolean): Promise<LayerInfo> {\r\n        const capabilities = await this.$iApi.geo.layer.ogc.parseCapabilities(url);\r\n\r\n        const config = {\r\n            id: `${LayerType.WMS}#${++this.layerCount}`,\r\n            url: url,\r\n            layerType: LayerType.WMS,\r\n            name: url,\r\n            featureInfoMimeType: capabilities.queryTypes[0],\r\n            state: { opacity: 1, visibility: true }\r\n        };\r\n\r\n        return {\r\n            config,\r\n            layers: this.mapWmsLayerList(capabilities.layers, nested),\r\n            configOptions: ['name', 'sublayers'],\r\n            layersRaw: capabilities.layers\r\n        };\r\n    }\r\n\r\n    mapWmsLayerList(layers: any, nested: boolean) {\r\n        // filter out items with non-existent id\r\n        let modLayers: any = [];\r\n        layers.forEach((layer: any) => {\r\n            if (layer.name === null && layer.layers) {\r\n                modLayers = [...modLayers, ...layer.layers];\r\n            } else {\r\n                modLayers.push(layer);\r\n            }\r\n        });\r\n\r\n        if (nested) {\r\n            return modLayers.flatMap((layer: any) => {\r\n                return {\r\n                    id: `${layer.name}#${++this.sublayerCount}`,\r\n                    label: layer.title,\r\n                    children: layer.layers.length > 0 ? this.mapWmsLayerList(layer.layers, nested) : undefined\r\n                };\r\n            });\r\n        } else {\r\n            return modLayers.flatMap((layer: any) =>\r\n                layer.layers && layer.layers.length > 0\r\n                    ? this.mapWmsLayerList(layer.layers, nested)\r\n                    : {\r\n                          id: `${layer.name}#${++this.sublayerCount}`,\r\n                          label: layer.title\r\n                      }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Guesses type of file or service given a URL\r\n     *\r\n     * @param {string} url\r\n     * @returns {string} file or layer type\r\n     */\r\n    guessFormatFromURL(url: string): string {\r\n        // check if file url\r\n        switch (url.match(/\\.(zip|csv|geojson|json)$/)?.[1]) {\r\n            case 'zip':\r\n                return LayerType.SHAPEFILE;\r\n            case 'csv':\r\n                return LayerType.CSV;\r\n            case 'geojson':\r\n            case 'json':\r\n                return LayerType.GEOJSON;\r\n        }\r\n\r\n        // probably an image layer if ends with ImageServer\r\n        if (url.match(/\\/ImageServer\\/?$/gi)) {\r\n            return LayerType.IMAGERY;\r\n        }\r\n\r\n        // probably a wfs layer if contains /collections/\r\n        if (url.match(/\\/collections\\//gi)) {\r\n            return LayerType.WFS;\r\n        }\r\n\r\n        // probably esri layer if contains /arcgis/rest/services/\r\n        if (url.match(/arcgis\\/rest\\/services\\//gi)) {\r\n            // probably a feature layer if ends with a number\r\n            if (url.match(/\\/\\d+\\/?$/g)) {\r\n                return LayerType.FEATURE;\r\n            }\r\n\r\n            return LayerType.MAPIMAGE;\r\n        }\r\n\r\n        // probably wms layer if contains service= or verison= or /wms\r\n        if (url.match(/service=|version=|\\/wms/gi)) {\r\n            return LayerType.WMS;\r\n        }\r\n\r\n        return '';\r\n    }\r\n}\r\n","export default \"key,enValue,enValid,frValue,frValid\\r\\nwizard.title,Import Layer,1,Importer un fichier,1\\r\\nwizard.upload.title,Upload data,1,Charger des données,1\\r\\nwizard.upload.or,or,1,ou,1\\r\\nwizard.upload.file.label,Upload a file,1,Télécharger un fichier,1\\r\\nwizard.upload.file.help,Drop or select a file to upload,1,Déposer ou sélectionner un fichier à télécharger,1\\r\\nwizard.upload.file.error.failed,File upload failed,1,Le téléchargement du fichier a échoué,1\\r\\nwizard.upload.url.label,URL to file or service,1,URL vers fichier ou service,1\\r\\nwizard.upload.url.error.required,URL is required,1,L'URL est requise,1\\r\\nwizard.upload.url.error.url,Please enter a valid URL,1,Veuillez saisir une adresse URL valide,1\\r\\nwizard.format.title,Select format,1,Choisir un format,1\\r\\nwizard.format.type.service,Service type,1,Type de service,1\\r\\nwizard.format.type.file,File format,1,Format du fichier,1\\r\\nwizard.format.type.error.required,Service or file type is required,1,Le service ou le type de fichier est requis,1\\r\\nwizard.format.type.error.invalid,Invalid file or service type,1,Type de fichier ou de service non valide,1\\r\\nwizard.format.type.error.failure,Failed to load data from file/service,1,Échec du chargement des données à partir du fichier/service,1\\r\\nwizard.format.info.cors,Service needs to be CORS enabled,1,Le service doit être compatible CORS.,1\\r\\nwizard.format.warn.cors,Service may not support CORS,1,Le service ne pend peut-être pas en charge CORS.,1\\r\\nwizard.format.warn.vpn,Service may require a VPN connection,1,Le service peut nécessiter une connexion RPV,1\\r\\nwizard.fileType.csv,CSV,1,CSV,1\\r\\nwizard.fileType.shapefile,zipped Shapefile,1,Shapefile zippé,1\\r\\nwizard.fileType.geojson,GeoJSON,1,GeoJSON,1\\r\\nwizard.layerType.esriFeature,ESRI Feature Layer,1,Couche d'éléments d'ESRI,1\\r\\nwizard.layerType.esriMapImage,ESRI Map Image Layer,1,Couche d'image de la carte ESRI,1\\r\\nwizard.layerType.esriImagery,ESRI Imagery Layer,1,Couche d'imagerie d'ESRI,1\\r\\nwizard.layerType.esriTile,ESRI Tile Layer,1,Couche de tuiles d'ESRI,1\\r\\nwizard.layerType.ogcWms,OGC Web Map Service,1,Couche WMS de l'OGC,1\\r\\nwizard.layerType.ogcWfs,OGC Web Feature Service,1,Service d'entités Web OGC,1\\r\\nwizard.configure.title,Configure layer,1,Configurer la couche,1\\r\\nwizard.configure.name.error.required,Name is required,1,Le champ Nom est obligatoire,1\\r\\nwizard.configure.name.label,Layer Name,1,Nom de la couche,1\\r\\nwizard.configure.nameField.label,Primary Field,1,Champ clé,1\\r\\nwizard.configure.tooltipField.label,Tooltip Field,1,Champ infobulle,1\\r\\nwizard.configure.latField.label,Latitude Field,1,Champ latitude,1\\r\\nwizard.configure.longField.label,Longitude Field,1,Champ longitude,1\\r\\nwizard.configure.sublayers.error.required,Sublayers are required,1,Des sous-couches sont requises,1\\r\\nwizard.configure.sublayers.label,Layers,1,Couches,1\\r\\nwizard.configure.sublayers.results,No results,1,Aucun résultat,1\\r\\nwizard.configure.sublayers.search,Search layers,1,Rechercher des couches,1\\r\\nwizard.configure.sublayers.select,Select layer(s),1,Sélectionner les couches,1\\r\\nwizard.configure.sublayers.clearAll,Clear all,1,Effacer tout,1\\r\\nwizard.configure.sublayers.nested,Nested,1,Imbriquées,1\\r\\nwizard.configure.colour.label,Colour,1,Couleur,1\\r\\nwizard.configure.colour.hue,Hue,1,Teinte,1\\r\\nwizard.configure.colour.copy,Copy colour,1,Copier la couleur,1\\r\\nwizard.configure.colour.hex,Hex,1,Hex,1\\r\\nwizard.step.cancel,Cancel,1,Annuler,1\\r\\nwizard.step.continue,Continue,1,Continuer,1\\r\\nwizard.upload.success,has been uploaded successfully.,1,a été téléversé avec succès.,1\\r\\nwizard.upload.fail,failed to upload.,1,n'a pas pu être téléversé.,1\"","import { markRaw } from 'vue';\r\nimport { WizardAPI } from './api/wizard';\r\nimport { LayerSource } from './store/layer-source';\r\nimport messages from './lang/lang.csv?raw';\r\nimport { useWizardStore } from './store';\r\n\r\nclass WizardFixture extends WizardAPI {\r\n    added() {\r\n        // console.log(`[fixture] ${this.id} added`);\r\n\r\n        this.$iApi.panel.register(\r\n            {\r\n                wizard: {\r\n                    screens: {\r\n                        'wizard-screen': () => markRaw(import('./screen.vue'))\r\n                    },\r\n                    button: {\r\n                        tooltip: 'wizard.title',\r\n                        icon: '<svg class=\"fill-current\" viewBox=\"0 0 23 21\"><path d=\"M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z\"></path></svg>'\r\n                    },\r\n                    style: {\r\n                        width: '350px'\r\n                    },\r\n                    alertName: 'wizard.title'\r\n                }\r\n            },\r\n            {\r\n                i18n: { messages }\r\n            }\r\n        );\r\n\r\n        this.handlePanelTeleports(['wizard']);\r\n\r\n        let layerSource: LayerSource | undefined = new LayerSource(this.$iApi);\r\n\r\n        const wizardStore = useWizardStore(this.$vApp.$pinia);\r\n        //@ts-ignore\r\n        wizardStore.layerSource = layerSource;\r\n\r\n        // override the removed method here to get access to scope\r\n        this.removed = () => {\r\n            // console.log(`[fixture] ${this.id} removed`);\r\n            this.$iApi.panel.remove('wizard');\r\n            layerSource = undefined; // will be cleaned up by JS garbage collector\r\n            wizardStore.$reset();\r\n        };\r\n    }\r\n}\r\n\r\nexport default WizardFixture;\r\n"],"names":["WizardAPI","FixtureInstance","open","panel","LayerSource","APIScope","$iApi","url","fileType","fileData","LayerType","jsonData","serviceType","nested","response","axios","layers","l1","l2","findParent","id","sublayers","parent","sl","sublayer","opts","parentIds","layer","parentLayer","wrapper","UrlWrapper","offset","limit","wfsJson","capabilities","modLayers","messages","WizardFixture","markRaw","layerSource","wizardStore","useWizardStore"],"mappings":"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"}