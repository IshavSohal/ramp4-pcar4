{"version":3,"file":"index-BVoeUa1Z.js","sources":["../../src/fixtures/legend/api/legend.ts","../../src/fixtures/legend/nav-button.vue","../../src/fixtures/legend/lang/lang.csv?raw","../../src/fixtures/legend/index.ts"],"sourcesContent":["import { FixtureInstance, LayerInstance } from '@/api';\r\nimport { LayerType, type TreeNode } from '@/geo/api';\r\nimport { type LegendConfig, useLegendStore } from '../store';\r\nimport { LayerItem } from '../store/layer-item';\r\nimport { LegendItem } from '../store/legend-item';\r\nimport { SectionItem } from '../store/section-item';\r\n\r\nexport class LegendAPI extends FixtureInstance {\r\n    /**\r\n     * Parses the legend config JSON snippet from the config file and save resulting objects to the fixture store.\r\n     *\r\n     * @param {LegendConfig | undefined} legendConfig\r\n     */\r\n    _parseConfig(legendConfig?: LegendConfig): void {\r\n        // parse the header controls, or default the controls\r\n        const controls: Array<string> = legendConfig?.headerControls?.slice() ?? [\r\n            'wizard',\r\n            'layerReorder',\r\n            'groupToggle',\r\n            'visibilityToggle'\r\n        ];\r\n        useLegendStore(this.$vApp.$pinia).headerControls = controls;\r\n\r\n        if (!legendConfig || !legendConfig.root.children) {\r\n            return;\r\n        }\r\n\r\n        useLegendStore(this.$vApp.$pinia).multilineItems = legendConfig.multilineItems?.enabled ?? true;\r\n\r\n        // line-clamp only supports values 1-6, and custom values i.e. line-clamp-[4] don't\r\n        // seem to work. So we limit it here.\r\n        const lineClampValues = [1, 2, 3, 4, 5, 6];\r\n        if (\r\n            !legendConfig.multilineItems?.maxLines ||\r\n            !lineClampValues.includes(legendConfig.multilineItems?.maxLines)\r\n        ) {\r\n            useLegendStore(this.$vApp.$pinia).maxLines = 3;\r\n        } else {\r\n            useLegendStore(this.$vApp.$pinia).maxLines = legendConfig.multilineItems.maxLines;\r\n        }\r\n\r\n        this.handlePanelWidths(['legend']);\r\n        this.handlePanelTeleports(['legend']);\r\n\r\n        // get all layer fixture configs to read layer-specific legend properties\r\n        const layerLegendConfigs: { [layerId: string]: any } = this.getLayerFixtureConfigs();\r\n\r\n        legendConfig.root.children.forEach(legendItem => {\r\n            // pass the layer legend fixture config\r\n            legendItem.layerLegendConfigs = layerLegendConfigs;\r\n            this.addItem(legendItem);\r\n        });\r\n\r\n        // update legend in case layers were added before the legend was created\r\n        this.$iApi.geo.layer.allLayers().forEach(l => {\r\n            this.updateLegend(l);\r\n        });\r\n    }\r\n\r\n    // Create\r\n\r\n    /**\r\n     * Construct a legend item given the legend config\r\n     *\r\n     * @param {any} itemConf legend item config\r\n     * @param {LegendItem | undefined} parent the parent legend item for the created item\r\n     * @returns {LegendItem} returns the constructed legend item\r\n     * @memberof LegendAPI\r\n     */\r\n    createItem(itemConf: any, parent?: LegendItem): LegendItem {\r\n        let item: LegendItem | undefined = undefined;\r\n\r\n        if (itemConf.layerId === undefined) {\r\n            // (assuming visibility sets and groups will specify in config `exclusiveVisibility` or `children` properties, respectively)\r\n            // create a wrapper legend object for group or visibility set\r\n            item = new SectionItem(this.$iApi, itemConf, parent);\r\n        } else {\r\n            // create a wrapper legend object for single layer item\r\n            // if the item is a sublayer, override the item id to the sublayers id\r\n            if (itemConf.sublayerIndex !== undefined) {\r\n                itemConf.layerId = `${itemConf.layerId}-${itemConf.sublayerIndex}`;\r\n            }\r\n            item = new LayerItem(this.$iApi, itemConf, parent) as unknown as LegendItem;\r\n        }\r\n\r\n        // initialize objects for all non-hidden group/set children entries\r\n        const children = itemConf.children;\r\n\r\n        // construct children\r\n        if (children) {\r\n            children.forEach((childConf: any) => {\r\n                // pass the layer fixture config to child items\r\n                if (itemConf.layerLegendConfigs !== undefined) {\r\n                    childConf.layerLegendConfigs = itemConf.layerLegendConfigs;\r\n                }\r\n\r\n                // ts ignoring below because returned item is \"LegendItem\", but accepted type is \"LayerItem | SectionItem\"\r\n                // which is the same thing! (╯°□°）╯︵ ┻━┻\r\n                //@ts-ignore\r\n                item!.children.push(this.createItem(childConf, item));\r\n            });\r\n        }\r\n\r\n        return item!;\r\n    }\r\n\r\n    /**\r\n     * Add a legend item given the legend config, or legend item instance\r\n     *\r\n     * @param {any | LegendItem} item the config for the legend item or a legend item instance\r\n     * @param {LegendItem | undefined} parent optional parent item to create this item under\r\n     * @returns {LegendItem} the added legend item\r\n     * @memberof LegendAPI\r\n     */\r\n    addItem(item: any | LegendItem, parent?: LegendItem): LegendItem {\r\n        const constructedItem: LegendItem = item instanceof LegendItem ? item : this.createItem(item, parent);\r\n        this._insertItem(constructedItem, parent);\r\n\r\n        return constructedItem;\r\n    }\r\n\r\n    /**\r\n     * Add a layer legend item given a layer instance\r\n     *\r\n     * @param {LayerInstance} layer the layer to create an item for\r\n     * @param {LegendItem | undefined} parent optional parent item to create this item under\r\n     * @returns {Promise<LegendItem>} a promise that resolves with the added layer item\r\n     * @memberof LegendAPI\r\n     */\r\n    async addLayerItem(layer: LayerInstance, parent?: LegendItem): Promise<LayerItem> {\r\n        // only create a top-level legend item for the layer that will be in a placeholder state\r\n        const item: LayerItem = new LayerItem(\r\n            this.$iApi,\r\n            {\r\n                layerId: layer.id,\r\n                sublayerIndex: layer.isSublayer ? layer.layerIdx : undefined,\r\n                name: layer.name\r\n            },\r\n            parent\r\n        );\r\n        // add the layer item to store\r\n        // will be in a placeholder state until the layer is loaded\r\n        this._insertItem(item as unknown as LegendItem, parent);\r\n\r\n        // Updates the legend with the inserted item\r\n        // tree growing magic also takes place here for MILs\r\n        this.updateLegend(layer);\r\n\r\n        return item;\r\n    }\r\n\r\n    // Read\r\n\r\n    /**\r\n     * Returns `LegendConfig` section of the global config file.\r\n     *\r\n     * @readonly\r\n     * @type {LegendConfig}\r\n     * @memberof LegendAPI\r\n     */\r\n    get config(): LegendConfig | undefined {\r\n        return super.config;\r\n    }\r\n\r\n    /**\r\n     * Returns the full legend tree.\r\n     * Note: This returns a direct reference to the legend tree. Mutations will persist.\r\n     *\r\n     * @returns {Array<LegendItem>} returns the full legend tree\r\n     * @memberof LegendAPI\r\n     */\r\n    getLegend(): Array<LegendItem> {\r\n        return (useLegendStore(this.$vApp.$pinia).children as unknown as Array<LegendItem>) || [];\r\n    }\r\n\r\n    /**\r\n     * Maps the current legend tree into a legend config snippet.\r\n     *\r\n     * In addition to legend config schema properties, this snippet will also include\r\n     * properties such as the item type, item's uid, layer uid etc.\r\n     *\r\n     * @returns {any} returns the legend config\r\n     * @memberof LegendAPI\r\n     */\r\n    getLegendConfig(): any {\r\n        return {\r\n            root: {\r\n                children: this.getLegend().map(item => item.getConfig())\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get a legend item given its uid.\r\n     *\r\n     * @param {string} uid the uid of the legend item\r\n     * @returns {LegendItem | undefined} return legend item with given uid. returns undefined if item is not found.\r\n     * @memberof LegendAPI\r\n     */\r\n    getItem(uid: string): LegendItem | undefined {\r\n        const legend = this.getLegend();\r\n\r\n        let result: LegendItem | undefined;\r\n        legend.some(topItem => {\r\n            result = this.searchTreeFirst(topItem, item => item.uid === uid);\r\n            return result !== undefined;\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the first found layer item connected to the layer with the given id/uid or the given layer instance.\r\n     *\r\n     * @param {string | LayerInstance} layer the id/uid of the layer or layer instance\r\n     * @returns {LegendItem | undefined} return layer item tied to the found layer. returns undefined if no such item is found.\r\n     * @memberof LegendAPI\r\n     */\r\n    getLayerItem(layer: string | LayerInstance): LayerItem | undefined {\r\n        let uid: string;\r\n        let id: string;\r\n        let result: LayerItem | undefined;\r\n\r\n        if (typeof layer === 'string') {\r\n            id = layer;\r\n            uid = layer;\r\n        } else {\r\n            id = layer.id;\r\n            uid = layer.uid;\r\n        }\r\n\r\n        const legend = this.getLegend();\r\n\r\n        // find first\r\n        legend.some(topItem => {\r\n            result = this.searchTreeFirst(\r\n                topItem,\r\n                item => item instanceof LayerItem && (item.layerId === id || item.uid === uid)\r\n            ) as unknown as LayerItem | undefined;\r\n\r\n            // kickout\r\n            return result !== undefined;\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get all legend items with the given expanded state.\r\n     * Not specifying the expanded state will return all items with expanded set to `true`\r\n     *\r\n     * @param {boolean | undefined} expanded the expanded state to check for\r\n     * @returns {Array<LegendItem>} the items with the given expanded state\r\n     * @memberof LegendAPI\r\n     */\r\n    getAllExpanded(expanded?: boolean): Array<LegendItem> {\r\n        const check = expanded ?? true;\r\n\r\n        return this.searchLegend(item => item.children.length > 0 && item.expanded === check);\r\n    }\r\n\r\n    /**\r\n     * Get all legend items with the given visibility state.\r\n     * Not specifying the visibility state will return all items with visibility set to `true`\r\n     *\r\n     * @param {boolean | undefined} visibility the visibility state to check for\r\n     * @returns {Array<LegendItem>} the items with the given expanded state\r\n     * @memberof LegendAPI\r\n     */\r\n    getAllVisible(visibility?: boolean): Array<LegendItem> {\r\n        const check = visibility ?? true;\r\n        return this.searchLegend(item => item.visibility === check);\r\n    }\r\n\r\n    /**\r\n     * Return every legend block bound to a registered layer. Parent-child layer types will\r\n     * return everything tied to the entire layer (parent & children)\r\n     *\r\n     * @param {LayerInstance | string} layer a layer instance, layer id, or layer uid\r\n     * @returns {Array<LayerItem>} all legend items bound to the layer\r\n     */\r\n    getLayerBoundItems(layer: LayerInstance | string): Array<LayerItem> {\r\n        // find the parentmost layer id\r\n        let parentMostId = '';\r\n\r\n        // since we support uid on parameter, and can't diff between regular id, need a layer-lookup for string\r\n        const layerInstance = layer instanceof LayerInstance ? layer : this.$iApi.geo.layer.getLayer(layer);\r\n        if (layerInstance) {\r\n            // if sublayer doesn't have parentlayer, things already horribly broken.\r\n            // empty string just avoids undefined errors, will eventually return [] just slower\r\n            parentMostId = layerInstance.isSublayer ? layerInstance.parentLayer?.id || '' : layerInstance.id;\r\n        } else {\r\n            // layer not registered.\r\n            return [];\r\n        }\r\n\r\n        return this.searchLegend(\r\n            block =>\r\n                block instanceof LayerItem && (block.layerId === parentMostId || block.parentLayerId === parentMostId)\r\n        ) as unknown as Array<LayerItem>;\r\n    }\r\n\r\n    // Update\r\n\r\n    /**\r\n     * Update all layer items bound to the given layer.\r\n     * Does nothing if no layer items are found\r\n     *\r\n     * @param {LayerInstance} layer the layer to update the legend with\r\n     * @memberof LegendAPI\r\n     */\r\n    updateLegend(layer: LayerInstance): void {\r\n        // helper function to link a layer into a layer item\r\n        const updateLayerItem = (sourceLayer: LayerInstance | string, error: boolean) => {\r\n            const layerItem = this.getLayerItem(sourceLayer);\r\n            if (error) {\r\n                if (layerItem && sourceLayer instanceof LayerInstance) {\r\n                    layerItem.layer = sourceLayer;\r\n                }\r\n                layerItem?.error();\r\n            } else {\r\n                layerItem?.load(sourceLayer instanceof LayerInstance ? sourceLayer : undefined);\r\n            }\r\n        };\r\n\r\n        layer\r\n            .loadPromise()\r\n            .then(() => {\r\n                // NOTE: potential limitation here.\r\n                //       getLayerItem() only returns the first match found.\r\n                //       If we had a legend that shows the same layer in multiple blocks,\r\n                //       this might get squirrely. This isn't a typical (or even sensical)\r\n                //       scenario, but you can configure a legend that way.\r\n                //       Not changing anything at the moment (algo is a bit \"intense\"),\r\n                //       but commenting to make it obvious if we do encounter something.\r\n                let layerItem = this.getLayerItem(layer);\r\n                if (layer.layerType === LayerType.MAPIMAGE) {\r\n                    // For MIL, need to do tree growing magic\r\n                    const treeParser = (node: TreeNode) => {\r\n                        if (node.isLayerRoot && !node.isLogicalLayer) {\r\n                            // is root, but not logical layer (MIL)\r\n                            // grow out the full tree if it has not already been grown\r\n                            layerItem = this.getLayerItem(layer);\r\n                            updateLayerItem(layer, false);\r\n                            if (layerItem && !layerItem.treeGrown) {\r\n                                node.children\r\n                                    .map(childNode => this._treeWalker(layer, childNode))\r\n                                    .map(childConf => this.addItem(childConf, layerItem as unknown as LegendItem));\r\n                                layerItem.treeGrown = true;\r\n                            }\r\n                            // parse child nodes\r\n                            node.children.forEach(childNode => treeParser(childNode));\r\n                        } else if (!node.isLayerRoot && !node.isLogicalLayer) {\r\n                            // is not root, and is not logical layer (MIL sub groups)\r\n                            // we remove the current layer item for the group, and instead turn it into a group\r\n                            layerItem = this.getLayerItem(`${layer.id}-${node.layerIdx}`);\r\n                            if (layerItem) {\r\n                                const layerItemConf = layerItem.getConfig();\r\n                                delete layerItemConf.layerId;\r\n                                delete layerItemConf.sublayerIndex;\r\n                                delete layerItemConf.children;\r\n                                if (!layerItemConf.name) {\r\n                                    delete layerItemConf.name;\r\n                                }\r\n                                const replacementConf = {\r\n                                    ...this._treeWalker(layer, node),\r\n                                    ...layerItemConf\r\n                                };\r\n                                const replacementItem: LegendItem = this.createItem(replacementConf);\r\n                                this._replaceItem(layerItem as unknown as LegendItem, replacementItem);\r\n                            }\r\n                            // parse child nodes\r\n                            node.children.forEach(childNode => treeParser(childNode));\r\n                        } else if (node.isLogicalLayer) {\r\n                            // is logical layer (regular layers and sublayers)\r\n                            updateLayerItem(this._treeWalker(layer, node).layer, false);\r\n                        }\r\n                    };\r\n                    treeParser(layer.getLayerTree());\r\n                } else {\r\n                    // For all other layer types, just update the layer item\r\n                    updateLayerItem(layer, false);\r\n                }\r\n            })\r\n            .catch(() => {\r\n                // layer had a failure, or was manually cancelled.\r\n                updateLayerItem(layer, true); // update the root layer item first\r\n                if (layer.supportsSublayers) {\r\n                    layer.config.sublayers.forEach((sublayer: any) => {\r\n                        updateLayerItem(`${layer.id}-${sublayer.index}`, true); // hacky solution because sublayers arent created on error\r\n                    });\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Set the expanded state of legend items to `expanded`\r\n     *\r\n     * @param {boolean} expanded the expanded state the items will be set to\r\n     * @param {LegendItem | undefined} root the root item to start updating the expanded state from\r\n     * @memberof LegendAPI\r\n     */\r\n    expandItems(expanded: boolean, root?: LegendItem): void {\r\n        const legend: Array<LegendItem> = this.getLegend();\r\n        const items = root === undefined ? legend : root.children;\r\n        if (root !== undefined) {\r\n            this._toggleState(root, { expanded: expanded });\r\n        }\r\n        items.forEach((item: LegendItem) => {\r\n            this._toggleState(item, { expanded: expanded });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set the visibility state of legend items to `visibility`\r\n     *\r\n     * @param {boolean} visibility the visibility state the items will be set to\r\n     * @param {LegendItem | undefined} root the root item to start updating the visibility state from\r\n     * @memberof LegendAPI\r\n     */\r\n    showItems(visibility: boolean, root?: LegendItem): void {\r\n        const legend: Array<LegendItem> = this.getLegend();\r\n        const items = root === undefined ? legend : root.children;\r\n        if (root !== undefined) {\r\n            this._toggleState(root, { visibility: visibility });\r\n        }\r\n        items.forEach((item: LegendItem) => {\r\n            this._toggleState(item, { visibility: visibility });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reload the all legend items connected to the given layer.\r\n     * This preps the items for the reload. It does not reload the actual layer.\r\n     * Parent-child layer types will prep all items related to the layer (both\r\n     * parent and sublayers)\r\n     *\r\n     * @param {LayerInstance | string} layer a layer instance, layer id, or layer uid referencing the reloaded layer\r\n     * @returns {boolean} returns true if item was successfully reloaded, false otherwise\r\n     * @memberof LegendAPI\r\n     */\r\n    reloadLayerItem(layer: LayerInstance | string): boolean {\r\n        const affectedBlocks = this.getLayerBoundItems(layer);\r\n\r\n        affectedBlocks.forEach(block => block.reload());\r\n\r\n        return affectedBlocks.length > 0;\r\n    }\r\n\r\n    // Delete\r\n\r\n    /**\r\n     * Removes the legend item with the given uid, or the item instance.\r\n     *\r\n     * @param {string | LegendItem} item the uid of item or legend item instance to be removed\r\n     * @returns {boolean} returns true if item was removed, false otherwise\r\n     * @memberof LegendAPI\r\n     */\r\n    removeItem(item: string | LegendItem): boolean {\r\n        const itemToRemove: LegendItem | undefined = typeof item === 'string' ? this.getItem(item) : item;\r\n\r\n        if (itemToRemove !== undefined) {\r\n            return this._deleteItem(itemToRemove);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Remove the layer item connected to the layer with the given id/uid or the given layer instance.\r\n     *\r\n     * @param {string | LayerInstance} layer the id/uid of the layer or layer instance\r\n     * @returns {boolean} returns true if item was removed, false otherwise\r\n     * @memberof LegendAPI\r\n     */\r\n    removeLayerItem(layer: string | LayerInstance): boolean {\r\n        // see NOTE comment in updateLegend(). This only removes the first\r\n        // found item. Very rare to have > 1, but just sayin'.\r\n        const itemToRemove: LayerItem | undefined = this.getLayerItem(layer);\r\n\r\n        if (itemToRemove !== undefined) {\r\n            return this._deleteItem(itemToRemove as unknown as LegendItem);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // _Helpers\r\n\r\n    /**\r\n     * Search for the first legend item that satisfies the predicate, starting from the given root item.\r\n     *\r\n     * @param {LegendItem} root the root item to start searching from\r\n     * @param {(item: LegendItem) => boolean} predicate boolean predicate to test each item\r\n     * @returns {LegendItem \\ undefined} return the first item that satisfies the given predicate. returns undefined if item is not found.\r\n     */\r\n    searchTreeFirst(root: LegendItem, predicate: (item: LegendItem) => boolean): LegendItem | undefined {\r\n        if (predicate(root)) {\r\n            return root;\r\n        } else {\r\n            let result: LegendItem | undefined;\r\n            root.children.some(child => {\r\n                result = this.searchTreeFirst(child, predicate);\r\n                return result !== undefined;\r\n            });\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Search for all legend items that satisfy the predicate, starting from the given root item.\r\n     *\r\n     * @param {LegendItem} root the root item to start searching from\r\n     * @param {(item: LegendItem) => boolean} predicate predicate boolean predicate to test each item\r\n     * @returns {Array<LegendItem>} return all items that satisfies the given predicate.\r\n     */\r\n    searchTreeAll(root: LegendItem, predicate: (item: LegendItem) => boolean): Array<LegendItem> {\r\n        const items: Array<LegendItem> = [];\r\n\r\n        // good-ol' bfs\r\n        const queue: Array<LegendItem> = [root];\r\n        while (queue.length > 0) {\r\n            const item = queue.shift();\r\n            if (item && predicate(item)) {\r\n                items.push(item);\r\n            }\r\n            if (item) {\r\n                queue.push(...item.children);\r\n            }\r\n        }\r\n\r\n        return items;\r\n    }\r\n\r\n    /**\r\n     * Search the entire legend for items that satisfy the predicate\r\n     *\r\n     * @param {(item: LegendItem) => boolean} predicate predicate boolean predicate to test each item\r\n     * @returns {Array<LegendItem>} return all items that satisfies the given predicate.\r\n     */\r\n    searchLegend(predicate: (item: LegendItem) => boolean): Array<LegendItem> {\r\n        // for reasons mysterious, the legend store doesn't track the legend root.\r\n        // it only tracks the children of the root.\r\n        // the extra flat() lets us mimic as if we could just pass the ultimate root\r\n        // to searchTreeAll\r\n        return this.getLegend()\r\n            .map(rootChildItem => this.searchTreeAll(rootChildItem, predicate))\r\n            .flat();\r\n    }\r\n\r\n    /**\r\n     * Toggles visibility for all items or expands/collapses all groups.\r\n     *\r\n     * @param {LegendItem} item current legend item that is being checked\r\n     * @param {any} options specifies whether visibility or expand/collapse functionality is to be changed\r\n     */\r\n    private _toggleState(item: LegendItem, options: any): void {\r\n        const visibility = options.visibility;\r\n        const expanded = options.expanded;\r\n        // for current legend child toggle properties if possible, check for appropriate legend element type\r\n        if (visibility !== undefined) {\r\n            // Seems to be working fine magically without the edge case check.\r\n            // Adding the edge case check breaks toggling all visibility in some cases.\r\n            // visibility set edge case\r\n            // if (!(item.parent && item.parent.visibility === visibility)) {\r\n            item.toggleVisibility(visibility);\r\n            // }\r\n        }\r\n        if (expanded !== undefined && item.children.length > 0) {\r\n            item.toggleExpanded(expanded);\r\n        }\r\n        // traverse the tree and make recursive calls\r\n        if (item.children && item.children.length > 0) {\r\n            item.children.forEach(ch => {\r\n                // level order traversal\r\n                this._toggleState(ch, options);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add the given legend item to the legend store\r\n     *\r\n     * @param {Legenditem} item the legend item to be added\r\n     * @param {LegendItem | undefined} parent the parent legend item for this item\r\n     */\r\n    private _insertItem(item: LegendItem, parent?: LegendItem): void {\r\n        useLegendStore(this.$vApp.$pinia).addItem({ item, parent });\r\n    }\r\n\r\n    /**\r\n     * Deletes the given legend item from the legend store\r\n     *\r\n     * @param {Legenditem} item the legend item to be deleted\r\n     * @returns {boolean} returns true if item was removed, false otherwise\r\n     */\r\n    private _deleteItem(item: LegendItem): boolean {\r\n        const store = useLegendStore(this.$vApp.$pinia);\r\n        const removeItemAndDescendants = (itemToRemove: LegendItem) => {\r\n            // Recursively remove all children first\r\n            if (itemToRemove.children.length > 0) {\r\n                itemToRemove.children.forEach((child: LegendItem) => {\r\n                    removeItemAndDescendants(child);\r\n                });\r\n            }\r\n\r\n            // unhook layer item listeners\r\n            if (itemToRemove instanceof LayerItem) {\r\n                itemToRemove.handlers.forEach(handler => this.$iApi.event.off(handler));\r\n            }\r\n\r\n            // remove item from store\r\n            store.removeItem(itemToRemove);\r\n        };\r\n\r\n        removeItemAndDescendants(item);\r\n\r\n        return true;\r\n    }\r\n\r\n    private _replaceItem(oldItem: LegendItem, newItem: LegendItem) {\r\n        useLegendStore(this.$vApp.$pinia).replaceItem({ oldItem, newItem });\r\n    }\r\n\r\n    // map out layer's layer tree children into a legend configs\r\n    private _treeWalker(layer: LayerInstance, node: TreeNode, extraConfig?: object): any {\r\n        // the tree node does not have a reference to the layer, so we need to fetch sublayers manually\r\n        // will be undefined for non-root + non-logical layers (a.k.a MIL sub groups)\r\n\r\n        // TODO: could modify LayerInstance's getSublayer to do what this helper is doing.\r\n        //       current getSublayer only checks the sublayer list one level down, but in\r\n        //       a more complex layer tree the requested sublayer can be much more nested\r\n\r\n        // local function to search a sublayer instance in the layer's tree with the given layer uid\r\n        // we need this local function because it is possible that this layer has not been added to\r\n        // the map yet, hence using geo.layer.getLayer will not work\r\n        const getLayer = (uid: string): LayerInstance | undefined => {\r\n            const queue = [layer];\r\n            while (queue.length > 0) {\r\n                const l = queue.shift();\r\n                if (l && l.uid === uid) {\r\n                    return l;\r\n                }\r\n                if (l) {\r\n                    queue.push(...l.sublayers);\r\n                }\r\n            }\r\n        };\r\n\r\n        const currLayer = getLayer(node.uid)!;\r\n\r\n        // current item legend config snippet\r\n        const currItem: any = {};\r\n\r\n        if (node.isLayerRoot && !node.isLogicalLayer) {\r\n            // is root, but not logical layer (MIL)\r\n            currItem.layer = currLayer;\r\n            currItem.name = currLayer.name;\r\n            // TODO: since .children is used here, only legend groups will be created here when MIL is added\r\n            //       can enhance later to use .exclusiveVisibility if user wants to add MIL as visibility set from wizard\r\n            currItem.children = node.children.map(childNode => this._treeWalker(layer, childNode, extraConfig));\r\n        } else if (!node.isLayerRoot && !node.isLogicalLayer) {\r\n            // is not root, and is not logical layer (MIL sub groups)\r\n            // coud merge above if-branch with this one, but will keep them separate for clarity\r\n            currItem.name = node.name;\r\n            // TODO: since .children is used here, only legend groups will be created here when MIL is added\r\n            //       can enhance later to use .exclusiveVisibility if user wants to add MIL as visibility set from wizard\r\n            currItem.children = node.children.map(childNode => this._treeWalker(layer, childNode, extraConfig));\r\n        } else if (node.isLogicalLayer) {\r\n            // is logical layer (regular layers and sublayers)\r\n            currItem.layer = currLayer;\r\n            currItem.name = currLayer.name;\r\n            currItem.layerId = currLayer.id;\r\n            currItem.sublayerIndex = layer.isSublayer ? layer.layerIdx : undefined;\r\n        }\r\n\r\n        return { ...currItem, ...extraConfig };\r\n    }\r\n}\r\n","<template>\r\n    <mapnav-button :onClickFunction=\"togglePanel\" :tooltip=\"t('legend.title')\">\r\n        <svg class=\"fill-current w-32 h-20\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\r\n            <path d=\"M0 0h24v24H0z\" fill=\"none\" />\r\n            <path\r\n                d=\"M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z\"\r\n            />\r\n        </svg>\r\n    </mapnav-button>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { inject } from 'vue';\r\nimport { useI18n } from 'vue-i18n';\r\nimport type { InstanceAPI } from '@/api';\r\n\r\nconst { t } = useI18n();\r\nconst iApi = inject('iApi') as InstanceAPI;\r\n\r\nconst togglePanel = () => {\r\n    iApi.panel.toggle('legend');\r\n};\r\n</script>\r\n\r\n<style lang=\"scss\" scoped></style>\r\n","export default \"key,enValue,enValid,frValue,frValid\\r\\nlegend.title,Legend,1,Légende,1\\r\\nlegend.header.addlayer,Add Layer,1,Ajouter une couche,1\\r\\nlegend.header.reorderlayers,Reorder Layers,1,Réorganiser les couches,1\\r\\nlegend.header.groups,Toggle Groups,1,Basculer les Groupes,1\\r\\nlegend.header.groups.expand,Expand All,1,Élargir les groupes,1\\r\\nlegend.header.groups.collapse,Collapse All,1,Réduire les groupes,1\\r\\nlegend.header.visible,Toggle Visibility,1,Basculer la Visibilité,1\\r\\nlegend.header.visible.show,Show All,1,Montrer tout,1\\r\\nlegend.header.visible.hide,Hide All,1,Cacher tout,1\\r\\nlegend.group.expand,Expand Group,1,Développer un groupe,1\\r\\nlegend.group.collapse,Collapse Group,1,Réduire un groupe,1\\r\\nlegend.visibility.showLayer,Show layer,1,Afficher la couche,1\\r\\nlegend.visibility.hideLayer,Hide layer,1,Masquer la couche,1\\r\\nlegend.visibility.showSymbol,Show symbol,1,Afficher le symbole,1\\r\\nlegend.visibility.hideSymbol,Hide symbol,1,Masquer le symbole,1\\r\\nlegend.visibility.showGroup,Show group,1,Afficher le groupe,1\\r\\nlegend.visibility.hideGroup,Hide group,1,Masquer le groupe,1\\r\\nlegend.symbology.expand,Expand legend,1,Développer la légende,1\\r\\nlegend.symbology.hide,Hide legend,1,Masquer la légende,1\\r\\nlegend.symbology.loading,Loading...,1,Chargement en cours...,1\\r\\nlegend.layer.data,Show more data,1,Afficher plus de données,1\\r\\nlegend.layer.data.only,Layer not on map,1,Couche non visualisable,1\\r\\nlegend.layer.offscale,Layer out of scale,1,Couche hors de portée,1\\r\\nlegend.layer.zoomToVisible,Zoom to visible scale,1,Zoom sur l'échelle visible,1\\r\\nlegend.layer.options,More options,1,Plus d'options,1\\r\\nlegend.layer.controls.metadata,Metadata,1,Métadonnées,1\\r\\nlegend.layer.controls.settings,Settings,1,Paramètres,1\\r\\nlegend.layer.controls.datatable,Datatable,1,Tableau de données,1\\r\\nlegend.layer.controls.symbology,Legend,1,Légende,1\\r\\nlegend.layer.controls.boundaryzoom,Zoom to Layer Boundary,1,Zoomer à la limite,1\\r\\nlegend.layer.controls.cancel,Cancel,1,Annuler,1\\r\\nlegend.layer.controls.remove,Remove,1,Retirer,1\\r\\nlegend.layer.controls.reload,Reload,1,Recharger,1\\r\\nlegend.layer.controls.reloadDisabled,Layer cannot be reloaded,1,Le calque ne peut pas être rechargé,0\\r\\nlegend.alert.symbologyExpanded,Layer legend expanded,1,Légende de la couche développée,1\\r\\nlegend.alert.symbologyCollapsed,Layer legend collapsed,1,Légende de la couche réduite,1\\r\\nlegend.alert.groupExpanded,Legend group expanded,1,Groupe de légende développé,1\\r\\nlegend.alert.groupCollapsed,Legend group collapsed,1,Groupe de légende réduit,1\\r\\nlegend.alert.layerAdded,{name} layer added to legend,1,{name} couche ajoutée à la légende,1\\r\\nlegend.alert.layerRemoved,{name} layer removed from legend,1,Couche {name} retiré de la légende,1\\r\\n\"","import { markRaw } from 'vue';\r\nimport { LegendAPI } from './api/legend';\r\nimport LegendNavButtonV from './nav-button.vue';\r\n\r\nimport messages from './lang/lang.csv?raw';\r\nimport { useAppbarStore } from '../appbar/store';\r\nimport { useMapnavStore } from '../mapnav/store';\r\nimport { useLegendStore } from './store';\r\n\r\nclass LegendFixture extends LegendAPI {\r\n    added() {\r\n        // console.log(`[fixture] ${this.id} added`);\r\n\r\n        this.$iApi.component('legend-nav-button', LegendNavButtonV);\r\n\r\n        this.$iApi.panel.register(\r\n            {\r\n                legend: {\r\n                    screens: {\r\n                        'legend-screen': () => markRaw(import('./screen.vue'))\r\n                    },\r\n                    style: {\r\n                        width: '350px'\r\n                    },\r\n                    alertName: 'legend.title',\r\n                    button: {\r\n                        tooltip: 'legend.title',\r\n                        // https://material.io/resources/icons/?icon=layers&style=baseline\r\n                        icon: '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0z\" fill=\"none\" /><path d=\"M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z\" /></svg>'\r\n                    }\r\n                }\r\n            },\r\n            {\r\n                i18n: { messages }\r\n            }\r\n        );\r\n\r\n        // parse legend section of config and store information in legend store\r\n        // here we create a copy of the config because the config parser will mutate the layer ids in the config\r\n        this._parseConfig(this.config !== undefined ? JSON.parse(JSON.stringify(this.config)) : undefined);\r\n        const unwatch = this.$vApp.$watch(\r\n            () => this.config,\r\n            (value: any) => this._parseConfig(value !== undefined ? JSON.parse(JSON.stringify(value)) : undefined)\r\n        );\r\n\r\n        // override the removed method here to get access to scope\r\n        this.removed = () => {\r\n            // remove all le\r\n            // console.log(`[fixture] ${this.id} removed`);\r\n            unwatch();\r\n\r\n            if (this.$iApi.fixture.exists('appbar')) {\r\n                const appbarStore = useAppbarStore(this.$vApp.$pinia);\r\n                appbarStore.removeButton('legend');\r\n            }\r\n\r\n            if (this.$iApi.fixture.exists('mapnav')) {\r\n                const mapnavStore = useMapnavStore(this.$vApp.$pinia);\r\n                mapnavStore.removeItem('legend');\r\n            }\r\n\r\n            const legendStore = useLegendStore();\r\n            legendStore.$reset();\r\n\r\n            this.$iApi.panel.remove('legend');\r\n        };\r\n    }\r\n}\r\n\r\nexport default LegendFixture;\r\n"],"names":["LegendAPI","FixtureInstance","legendConfig","controls","useLegendStore","lineClampValues","layerLegendConfigs","legendItem","l","itemConf","parent","item","SectionItem","LayerItem","children","childConf","constructedItem","LegendItem","layer","uid","legend","result","topItem","id","expanded","check","visibility","parentMostId","layerInstance","LayerInstance","block","updateLayerItem","sourceLayer","error","layerItem","LayerType","treeParser","node","childNode","layerItemConf","replacementConf","replacementItem","sublayer","root","items","affectedBlocks","itemToRemove","predicate","child","queue","rootChildItem","options","ch","store","removeItemAndDescendants","handler","oldItem","newItem","extraConfig","currLayer","currItem","t","useI18n","iApi","inject","togglePanel","messages","LegendFixture","LegendNavButtonV","markRaw","unwatch","value","useAppbarStore","useMapnavStore"],"mappings":"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"}