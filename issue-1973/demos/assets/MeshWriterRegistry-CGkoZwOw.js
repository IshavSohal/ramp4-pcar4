import { a as a$1, c as c$2, f as f$1, e as e$2 } from './UpdateTracking2D-C4LWDD8Y.js';
import { N, m as m$1, S as S$1, g as g$1, i as i$3, a as m$2, T, s as s$3, v as v$1, _, c as c$3, h as h$1, o as o$4, b as h$2, d as s$4, e as c$4 } from './PieChartMeshWriter-BSg8SdKd.js';
import { jm as ht, dp as rt, jn as M$1, jo as n$2, db as u$1, bQ as t$1, jp as i$1, fL as o, jq as B, jr as v, js as u$2, jt as l$2, ju as o$1, dw as e$1, fH as n$3, O, P as a$2, s as s$2, G as n$4 } from './main-5ivotA7d.js';
import { r as r$2, i as i$2, o as o$3 } from './LabelMetric-CsopNW4j.js';
import { t } from './constants-BNnV1ogR.js';
import { o as o$2 } from './grouping-3jYIV8wh.js';
import { s as s$1 } from './AttributeStore-DBgvAy34.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
function e(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t}function n$1(t,e){return Math.sqrt(t*t+e*e)}function s(t){const e=n$1(t[0],t[1]);t[0]/=e,t[1]/=e;}function i(t,e){return n$1(t[0]-e[0],t[1]-e[1])}function r$1(t,e){return t[e+1]}function h(t){return t.length-1}function a(t){let e=0;for(let n=0;n<h(t);n++)e+=c$1(t,n);return e}function c$1(t,e,n=1){let[s,i]=r$1(t,e);return [s,i]=[Math.round(s),Math.round(i)],Math.sqrt(s*s+i*i)*n}class u{constructor(t,e,n,s,i){this._segments=t,this._index=e,this._distance=n,this._xStart=s,this._yStart=i,this._done=!1;}static create(t){return new u(t,0,0,t[0][0],t[0][1])}clone(){return new u(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(t){return this._index===t._index||t._index===this._index-1&&(0===this._distance||1===t._distance)||t._index===this._index+1&&(1===this._distance||0===t._distance)}leq(t){return this._index<t._index||this._index===t._index&&this._distance<=t._distance}geq(t){return this._index>t._index||this._index===t._index&&this._distance>=t._distance}get _segment(){return this._segments[this._index+1]}get angle(){const t=this.dy,e=(0*t+-1*-this.dx)/(1*this.length);let n=Math.acos(e);return t>0&&(n=2*Math.PI-n),n}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:t,dy:e}=this;return Math.sqrt(t*t+e*e)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<h(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(t,e){const n=this.backwardLength;if(t<=n)return this._distance=(n-t)/this.length,this;let s=this.backwardLength;for(;this.prev();){if(s+this.length>t)return this._seekBackwards(t-s);s+=this.length;}return this._distance=0,e?this:null}seek(t,e=!1){if(t<0)return this._seekBackwards(Math.abs(t),e);if(t<=this.remainingLength)return this._distance=(this.backwardLength+t)/this.length,this;let n=this.remainingLength;for(;this.next();){if(n+this.length>t)return this.seek(t-n,e);n+=this.length;}return this._distance=1,e?this:null}}function d(e,n,s,i=!0){const r=a(e),h=u.create(e),c=r/2;if(!i)return h.seek(c),void(Math.abs(h.x)<t&&Math.abs(h.y)<t&&s(h.clone(),0,c+0*n,r));const d=Math.max((r-n)/2,0),o=Math.floor(d/n),_=c-o*n;h.seek(_);for(let a=-o;a<=o;a++)Math.abs(h.x)<t&&Math.abs(h.y)<t&&s(h.clone(),a,c+a*n,r),h.seek(n);}function l$1(t,e){const n=e;for(let s=0;s<t.length;s++){let e=t[s];g(e,n);const i=[];i.push(e[0]);for(let t=1;t<e.length;t++){const[n,s]=e[t-1],[r,h]=e[t],a=r-n,c=h-s;i.push([a,c]);}t[s]=i,e=i;}return t}function g(t,n){const r=1e-6;if(n<=0)return;const h=t.length;if(h<3)return;const a=[];let c=0;a.push(0);for(let e=1;e<h;e++)c+=i(t[e],t[e-1]),a.push(c);n=Math.min(n,.2*c);const u=[];u.push(t[0][0]),u.push(t[0][1]);const d=t[h-1][0],o=t[h-1][1],_=e([0,0],t[0],t[1]);s(_),t[0][0]+=n*_[0],t[0][1]+=n*_[1],e(_,t[h-1],t[h-2]),s(_),t[h-1][0]+=n*_[0],t[h-1][1]+=n*_[1];for(let e=1;e<h;e++)a[e]+=n;a[h-1]+=n;const l=.5*n;for(let e=1;e<h-1;e++){let s=0,i=0,c=0;for(let h=e-1;h>=0&&!(a[h+1]<a[e]-l);h--){const u=l+a[h+1]-a[e],d=a[h+1]-a[h],o=a[e]-a[h]<l?1:u/d;if(Math.abs(o)<r)break;const _=o*o,g=o*u-.5*_*d,x=o*d/n,f=t[h+1],y=t[h][0]-f[0],k=t[h][1]-f[1];s+=x/g*(f[0]*o*u+.5*_*(u*y-d*f[0])-_*o*d*y/3),i+=x/g*(f[1]*o*u+.5*_*(u*k-d*f[1])-_*o*d*k/3),c+=x;}for(let u=e+1;u<h&&!(a[u-1]>a[e]+l);u++){const h=l-a[u-1]+a[e],d=a[u]-a[u-1],o=a[u]-a[e]<l?1:h/d;if(Math.abs(o)<r)break;const _=o*o,g=o*h-.5*_*d,x=o*d/n,f=t[u-1],y=t[u][0]-f[0],k=t[u][1]-f[1];s+=x/g*(f[0]*o*h+.5*_*(h*y-d*f[0])-_*o*d*y/3),i+=x/g*(f[1]*o*h+.5*_*(h*k-d*f[1])-_*o*d*k/3),c+=x;}u.push(s/c),u.push(i/c);}u.push(d),u.push(o);for(let e=0,s=0;e<h;e++)t[e][0]=u[s++],t[e][1]=u[s++];}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
const L=1,S=0,I=128,A=o$1((e=>{let t=0;if(0===e)return 1/0;for(;!(e%2);)t++,e/=2;return t}));class z extends N{constructor(){super(...arguments),this._zoomLevel=0;}_write(e,t,i,s){if(this._zoomLevel=s||0,null!=i)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const i=t.readXForDisplay(),s=t.readYForDisplay();return this._writePoint(e,i,s,t)}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const i=t.readCentroidForDisplay();if(!i)return;const[s,r]=i.coords;return this._writePoint(e,s,r,t)}case"esriGeometryPolyline":this._writeLines(e,t);}}_writePoint(e,t,i,s){const r=this._getShaping();if(!r)return;let o=this._getPointReferenceBounds();o||(o={offsetX:0,offsetY:0,size:0});const n=r.boundsT,a=a$1(this.evaluatedMeshParams.horizontalAlignment),l=c$2(this.evaluatedMeshParams.verticalAlignment),h=this.evaluatedMeshParams.scaleInfo?.maxScale??0,c=this.evaluatedMeshParams.scaleInfo?.minScale??0,m=f$1(s.getDisplayId());e.metricStart(new r$2(m,t,i,a,l,h,c,o)),e.metricBoxWrite(n),this._writeGlyphs(e,s.getDisplayId(),t,i,r,0,o),e.metricEnd();}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:i,verticalAlignment:s}=this.evaluatedMeshParams,r=this.evaluatedMeshParams.repeatLabelDistance||128,o=this._getShaping("middle");if(!o)return;const n=(e,t,i,s)=>this._placeSubdivGlyphs(e,t,i,s),a=(o.bounds.width+r)/(1<<L);this._current={out:e,id:t.getDisplayId(),shaping:o,zoomRange:m$1(i,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null},this._verticalPlacement="bottom"===s?"above":"top"===s?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,n,a):this._writeCenterAlong(t,n,a);}_writeAboveAndBelowAlong(e,i,s){const{repeatLabel:r,fontSize:o}=this.evaluatedMeshParams,{shaping:n}=this._current,a=u$1(o),l=e.readGeometryForDisplay();if(!l)return;const h=new e$1;ht(h,l,!1,!1,"esriGeometryPolyline",1);const c=D(new e$1,h,a),m=D(new e$1,h,-a),g=rt(m,"esriGeometryPolyline",!1,!1),p=rt(c,"esriGeometryPolyline",!1,!1),_=l$1(p.paths,n.bounds.width),x=l$1(g.paths,n.bounds.width);this._current.offsetDirection="above";for(const t of _)d(t,s,i,!!r);this._current.offsetDirection="below";for(const t of x)d(t,s,i,!!r);}_writeCenterAlong(e,t,i){const{repeatLabel:s}=this.evaluatedMeshParams,{shaping:r}=this._current,o=l$1(e.readLegacyGeometryForDisplay().paths,r.bounds.width);for(const n of o)d(n,i,t,!!s);}_placeSubdivGlyphs(e,t,i,s){const{allowOverrun:r,labelPosition:o,repeatLabelDistance:n}=this.evaluatedMeshParams,a=this._current.zoomRange[0],l=A(t),h=this._current.shaping.bounds.width/(1<<L),c=Math.sqrt(n||I)/(1<<L),m=Math.min(i,s-i),d=this._current.shaping.isMultiline?S$1:Math.log2(m/(c+h/2)),u=0===t?d:Math.min(l,d),f=Math.max(a,this._zoomLevel+L-u),g=this._zoomLevel-f,p=this._current.shaping.bounds.width/2*2**g;this._current.shaping.isMultiline?0===t&&this._placeStraight(e,f):r&&g<0?this._placeStraightAlong(e,a):"parallel"===o?this._placeStraightAlong(e,f):"curved"===o&&this._placeCurved(e,f,p);}_placeStraight(e,t){const{out:i,id:s,shaping:r,referenceBounds:o}=this._current,{x:n,y:a}=e,l=f$1(s),h=this.evaluatedMeshParams.scaleInfo?.maxScale??0,c=this.evaluatedMeshParams.scaleInfo?.minScale??0;i.metricStart(new r$2(l,e.x,e.y,0,0,h,c,null)),i.metricBoxWrite(r.boundsT);const m=e.angle*(180/Math.PI)%360,d=(e.angle*(180/Math.PI)+180)%360;this._writeGlyphs(i,s,n,a,r,0,o,{clipAngle:m,mapAligned:!0,isLineLabel:!0,minZoom:t}),this._writeGlyphs(i,s,n,a,r,0,o,{clipAngle:d,mapAligned:!0,isLineLabel:!0,minZoom:t}),i.metricEnd();}_placeCurved(e,t,i){const{out:s,id:r}=this._current,o=e.clone(),n=e.angle*(180/Math.PI)%360,a=(e.angle*(180/Math.PI)+180)%360,l=f$1(r),h=this.evaluatedMeshParams.scaleInfo?.maxScale??0,c=this.evaluatedMeshParams.scaleInfo?.minScale??0;s.metricStart(new r$2(l,e.x,e.y,0,0,h,c,null)),this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(o,t,1,n),this._placeBack(e,o,t,i,1,n),this._placeForward(e,o,t,i,1,n)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(o,t,0,a),this._placeBack(e,o,t,i,0,a),this._placeForward(e,o,t,i,0,a)),s.metricEnd();}_placeStraightAlong(e,o){const{out:n,id:a,shaping:l,zoomRange:h,referenceBounds:m}=this._current,{boxBorderLineColor:d,boxBackgroundColor:u}=this.evaluatedMeshParams,f=e.clone(),g=e.angle*(180/Math.PI)%360,p=(e.angle*(180/Math.PI)+180)%360;if(l.glyphs.length>0&&!(!d&&!u)){const d=Math.max(o,h[0],0),u=Math.min(S$1,h[1]),f=M$1(n$2(),-e.angle),_={minZoom:d,maxZoom:u,clipAngle:g,mapAligned:!0,isLineLabel:!0},x=u$1(this.evaluatedMeshParams.offsetX),y=u$1(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const t=t$1(x,-1*y),[i,o]=l.shapeBackground(i$1(n$2(),f,t));n.recordStart(this.instanceId,this.attributeLayout,l.glyphs[0].textureBinding);const h=2*Math.max(i.width,i.height);n.recordBounds(e.x+i.x,e.y+i.y,h,h),this._writeTextBox(n,a,e.x,e.y,o,m,_),n.recordEnd();}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const t=t$1(x,y),[i,o]=l.shapeBackground(i$1(n$2(),f,t));_.clipAngle=p,n.recordStart(this.instanceId,this.attributeLayout,l.glyphs[0].textureBinding);const h=2*Math.max(i.width,i.height);n.recordBounds(e.x+i.x,e.y+i.y,h,h),this._writeTextBox(n,a,e.x,e.y,o,m,_),n.recordEnd();}}const x=f$1(a),v=this.evaluatedMeshParams.scaleInfo?.maxScale??0,M=this.evaluatedMeshParams.scaleInfo?.minScale??0;n.metricStart(new r$2(x,e.x,e.y,0,0,v,M,null)),this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(f,o,1,g,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(f,o,0,p,!0),n.metricEnd();}_placeBack(e,t,i,s,r,o){const n=e.clone();let a=e.backwardLength+S;for(;n.prev()&&!(a>=s);)this._placeOnSegment(n,t,a,i,-1,r,o),a+=n.length+S;}_placeForward(e,t,i,s,r,o){const n=e.clone();let a=e.remainingLength+S;for(;n.next()&&!(a>=s);)this._placeOnSegment(n,t,a,i,1,r,o),a+=n.length+S;}_placeFirst(e,t,i,s,r=!1){const{out:o,id:n,shaping:a,zoomRange:l,referenceBounds:h}=this._current,c=a.glyphs;for(const m of c){const c=m.x>a.bounds.x?i:1-i,d=c*e.remainingLength+(1-c)*e.backwardLength,u=Math.abs(m.x+m.width/2-a.bounds.x),f=Math.max(0,this._zoomLevel+Math.log2(u/(d+S))),g=Math.max(t,r?0:f);m.maxZoom=Math.min(l[1],S$1),m.angle=e.angle+(1-i)*Math.PI,m.minZoom=Math.max(l[0],g),this._writeLineGlyph(o,n,e.x,e.y,a.bounds,m,s,h,!0),i&&this._isVisible(m.minZoom,m.maxZoom)&&o.metricBoxWrite(m.bounds);}}_placeOnSegment(e,t,i,s,r,o,n){const{out:a,id:l,shaping:h,referenceBounds:c}=this._current,m=h.glyphs,d=e.dx/e.length,u=e.dy/e.length,f={x:e.x+i*-r*d,y:e.y+i*-r*u};for(const g of m){const m=g.x>h.bounds.x?o:1-o;if(!(m&&1===r||!m&&-1===r))continue;const d=Math.abs(g.x+g.width/2-h.bounds.x),u=Math.max(0,this._zoomLevel+Math.log2(d/i)-.1),p=Math.max(s,this._zoomLevel+Math.log2(d/(i+e.length+S)));if(0!==u&&(g.angle=e.angle+(1-o)*Math.PI,g.minZoom=p,g.maxZoom=u,this._writeLineGlyph(a,l,f.x,f.y,h.bounds,g,n,c,!0),o&&this._isVisible(g.minZoom,g.maxZoom))){const i=g.bounds,s=e.x-t.x,r=e.y-t.y,o=new i$2(i.center[0]+s,i.center[1]+r,i.width,i.height);a.metricBoxWrite(o);}}}_writeLineGlyph(e,t,i,s,r,o,n,a,l){const h=i+r.x,c=s+r.y,m=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),d=Math.max(r.width,r.height)*m;e.recordStart(this.instanceId,this.attributeLayout,o.textureBinding),e.recordBounds(h,c,d,d);const{texcoords:u,offsets:f}=o,g=this._textMeshTransformProps.fontSize;this._writeQuad(e,t,i,s,{texcoords:u,offsets:f,fontSize:g,color:g$1(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:a,minZoom:Math.max(this._current.zoomRange[0],o.minZoom),maxZoom:Math.min(this._current.zoomRange[1],o.maxZoom),clipAngle:n,mapAligned:l,isLineLabel:!0}),e.recordEnd();}_isVisible(e,t){const i=this._zoomLevel;return e<=i&&i<=t}}function D(e,t,i){const{coords:s,lengths:r}=t,c=n$3(),d=n$3(),u=n$3(),f=n$3(),g=n$3(),p=n$3(),_=2;let x=0;for(let m=0;m<r.length;m++){const t=r[m];for(let r=0;r<t;r++){const m=_*(r+x-1),y=_*(r+x),v$1=_*(r+x+1);r>0?o(c,s[m],s[m+1]):o(c,0,0),o(d,s[y],s[y+1]),r<t-1?o(u,s[v$1],s[v$1+1]):o(u,0,0),0===r?o(f,0,0):(B(f,d,c),v(f,f),o(f,f[1],-f[0])),r===t-1?o(g,0,0):(B(g,u,d),v(g,g),o(g,g[1],-g[0])),u$2(p,f,g),v(p,p);const M=p[0]*g[0]+p[1]*g[1];0!==M&&l$2(p,p,M),l$2(p,p,i),e.coords.push(d[0]+p[0],d[1]+p[1]);}e.lengths.push(t),x+=t;}return e}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
class r extends s$1{constructor(e){super(),this._value=e;}resize(e){}read(e,r){return this._value}readWithDefault(e,r,t){return this._value}referencesScale(){return !1}referencesGeometry(){return !1}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
const n=()=>n$4.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function c(e,r$1,t=!1){const{defaultValue:s,valueExpressionInfo:a,value:o}=r$1;if(a){const{expression:o}=a,i=await e.createComputedField({expression:o},t);return i?{...r$1,computed:i,defaultValue:s}:null}return {...r$1,computed:new r(o),defaultValue:s}}async function m(e,r){const{defaultValue:t,valueExpressionInfo:s}=r,{expression:a}=s,o=await e.createComputedField({expression:a});return o?{...r,computed:o,defaultValue:t}:null}const p=e=>"boolean"!=typeof e&&"number"!=typeof e&&"valueExpressionInfo"in e,f=e=>e.some((e=>{for(const r in e){const t=e[r];if(p(t))return !0}return !1}));class l{static async create(r,t,s){const a={},o=new Map,i=new Map,n=new Map,u=new Map,d=new Map;for(const l in s){const h=s[l];if(null!=h&&"object"==typeof h)if(Array.isArray(h)){if("object"==typeof h[0])throw new Error(`InternalError: Cannot handle ${l}. Nested array params are not supported`);a[l]=h;}else if("valueExpressionInfo"in h){if(h.value){a[l]=h.value;continue}const e=await m(r,h);if(!e){a[l]=h.defaultValue;continue}o.set(l,e),a[l]=null;}else switch(h.type){case"cim-effect-infos":if(h.effectInfos.some((e=>e.overrides.length))){i.set(l,{effects:await Promise.all(h.effectInfos.map((async t=>{const s=t.overrides.map((e=>c(r,e)));return {effect:t.effect,compiledOverrides:(await Promise.all(s)).filter(O)}})))});break}a[l]=h.effectInfos.map((e=>e.effect));break;case"cim-marker-placement-param":h.overrides.length&&n.set(l,{placementInfo:h,compiledOverrides:(await Promise.all(h.overrides.map((e=>c(r,e))))).filter(O)}),a[l]=h.placement;break;case"text-rasterization-param":{if(h.overrides.length){const t=h.overrides.map((e=>c(r,e,h.useLegacyLabelEvaluationRules)));u.set(l,{compiledOverrides:(await Promise.all(t)).filter(O),rasterizationParam:h,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:h.resource};a[l]=await t.fetchResourceImmediate(s)??null;break}case"sprite-rasterization-param":{if(h.overrides.length){const t=h.overrides.map((e=>c(r,e)));u.set(l,{compiledOverrides:(await Promise.all(t)).filter(O),rasterizationParam:h,objectIdToResourceId:new Map});continue}if("animated"===h.resource.type){u.set(l,{compiledOverrides:[],rasterizationParam:h,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:h.resource};a[l]=await t.fetchResourceImmediate(s)??null;break}case"cim-marker-transform-param":{const{params:e}=h;if(f(e)){const t={compiledMarkerInfos:[]};await Promise.all(e.map((async e=>{const s={props:{}};for(const t in e)if(p(e[t])){const a=await m(r,e[t]);s.compiledExpressionMap||(s.compiledExpressionMap=new Map);const o=s.compiledExpressionMap;a&&o.set(t,a);}else s.props[t]=e[t];t.compiledMarkerInfos.push(s);}))),d.set(l,t);}else a[l]={type:"cim-marker-transform-info",infos:e};break}default:a[l]=h;}else a[l]=h;}return new l(s,a,o,i,n,u,d)}constructor(e,r,t,s,a,o,i){this.inputMeshParams=e,this._resolvedMeshParams=r,this._dynamicProperties=t,this._dynamicEffectProperties=s,this._dynamicPlacementProperties=a,this._dynamicAsyncProperties=o,this._dynamicTransformProperties=i,this.evaluator=e=>e;}get hasDynamicProperties(){return !!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,s,i){for(const m of this._dynamicAsyncProperties.values()){const p=a$2(m.rasterizationParam.resource);"animated"===m.rasterizationParam.resource.type&&m.rasterizationParam.resource.randomizeStartTime&&(p.primitiveName="__RESERVED__PRIMITIVE__NAME__",p.startGroup=o$2(s.getObjectId()||0));for(const{primitiveName:e,propertyName:t,computed:a,defaultValue:l,valueExpressionInfo:u}of m.compiledOverrides)try{const r="animated"===m.rasterizationParam.resource.type?p.primitiveName:e;o$3(p,r,t,a,s,i,l);}catch(c){n().errorOnce(new s$2("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${u?.expression}' (primitive: '${e}', property: '${t}')`,c));}const f=e.enqueueRequest({type:"cim-rasterization-info",resource:p});m.objectIdToResourceId.set(s.getObjectId(),f);}}evaluateMeshParams(e,r,t){for(const[s,a]of this._dynamicProperties.entries())this._resolvedMeshParams[s]=a.computed.readWithDefault(r,t,a.defaultValue);for(const[s,a]of this._dynamicPlacementProperties.entries())for(const{computed:e,defaultValue:o,propertyName:i}of a.compiledOverrides){const n=e.readWithDefault(r,t,o);a.placementInfo.placement[i]=n,this._resolvedMeshParams[s]=a.placementInfo.placement;}for(const[s,a]of this._dynamicEffectProperties.entries())for(const e of a.effects){for(const{computed:s,defaultValue:a,propertyName:o}of e.compiledOverrides){const i=s.readWithDefault(r,t,a);e.effect[o]=i;}this._resolvedMeshParams[s]=a.effects.map((e=>e.effect));}for(const[s,a]of this._dynamicTransformProperties.entries()){const e={type:"cim-marker-transform-info",infos:[]};for(const s of a.compiledMarkerInfos){const a={...s.props};if(s.compiledExpressionMap)for(const[e,o]of s.compiledExpressionMap){const s=o.computed.readWithDefault(r,t,o.defaultValue);a[e]="number"==typeof s||"boolean"==typeof s?s:o.defaultValue;}e.infos.push(a);}this._resolvedMeshParams[s]=e;}for(const[s,a]of this._dynamicAsyncProperties.entries()){const t=a.objectIdToResourceId.get(r.getObjectId());if(null==t)continue;const o=e.getResource(t);this._resolvedMeshParams[s]=o;}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
class W{async createMeshWriter(e,r,t,i){const s=this._getMeshWriter(i.techniqueType),l$1=await l.create(e,r,i.inputParams),a=new s(i.id,l$1,i.optionalAttributes,t);return await a.loadDependencies(),a}_getMeshWriter(c){switch(c){case e$2.Fill:return c$4;case e$2.DotDensity:return s$4;case e$2.ComplexFill:return h$2;case e$2.PatternFill:return o$4;case e$2.OutlineFill:return h$1;case e$2.PatternOutlineFill:return c$3;case e$2.ComplexOutlineFill:return _;case e$2.Marker:return v$1;case e$2.PieChart:return s$3;case e$2.Text:return N;case e$2.Line:return T;case e$2.TexturedLine:return m$2;case e$2.Heatmap:return i$3;case e$2.Label:return z;case e$2.Test:throw new Error("Internal Error: Found invalid mesh writer")}}}

export { W, r };
